<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>仓库园区立体透视图 - 线框模式</title>l
  <style>
    :root {
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-fg: #222;
      --panel-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #f0f0f0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    }

    #loginOverlay {
      position: fixed;
      inset: 0;
      z-index: 999;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #f7fafc, #eef2f7);
    }

    #loginCard {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      padding: 24px 24px 20px;
      width: 320px;
    }

    #loginCard h2 {
      margin: 0 0 12px;
      font-size: 18px;
      color: #111;
    }

    .form-row {
      margin: 10px 0;
    }

    .form-row label {
      display: block;
      font-size: 13px;
      color: #444;
      margin-bottom: 6px;
    }

    .form-row input {
      width: 100%;
      height: 34px;
      padding: 6px 10px;
      border: 1px solid #d5d7db;
      border-radius: 6px;
      outline: none;
      box-sizing: border-box;
    }

    .form-actions {
      margin-top: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .btn {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .error {
      color: #b91c1c;
      font-size: 12px;
      min-height: 16px;
    }

    #viewport {
      width: 90vw;
      height: 90vh;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #f0f0f0;
    }

    canvas {
      display: block;
    }

    #infoPanel {
      position: fixed;
      display: none;
      z-index: 10;
      left: 0;
      top: 0;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: var(--panel-shadow);
      font-size: 14px;
      pointer-events: none;
      min-width: 120px;
      line-height: 1.5;
    }

    #detailPanel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      min-width: 300px;
      max-width: 400px;
      max-height: 70vh;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.4;
    }

    #compass {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 100px;
      height: 100px;
      z-index: 11;
      background: var(--panel-bg);
      border-radius: 50%;
      box-shadow: var(--panel-shadow);
      display: grid;
      place-items: center;
      user-select: none;
      pointer-events: none;
    }

    #compass svg {
      width: 84px;
      height: 84px;
    }

    #compass .label {
      font-size: 12px;
      font-weight: 600;
      fill: #333;
    }

    .whLabel {
      background: #ffffff;
      border: 1px solid #d0d5dd;
      color: #111;
      font-size: 12px;
      line-height: 1;
      padding: 4px 6px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
    }

    #whPanel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      min-width: 240px;
      font-size: 14px;
    }

    #actionBar {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%) translateY(12px);
      z-index: 12;
      opacity: 0;
      pointer-events: none;
      transition: transform .18s ease, opacity .18s ease;
    }

    #actionBar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    .action-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--panel-bg);
      color: var(--panel-fg);
      box-shadow: var(--panel-shadow);
      border-radius: 999px;
      padding: 8px;
      backdrop-filter: saturate(160%) blur(6px);
    }

    .action-bar .btn {
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 14px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
    }



    #monitorPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      width: 80vw;
      max-width: 800px;
      height: 60vh;
      max-height: 500px;
    }

    #monitorPanel .monitor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      background: #f8f9fa;
      border-radius: 8px 8px 0 0;
    }

    #monitorPanel .monitor-title {
      font-weight: 600;
      color: #2563eb;
      margin: 0;
    }

    #monitorPanel .monitor-close {
      background: #dc2626;
      color: white;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
    }

    #monitorPanel .monitor-close:hover {
      background: #b91c1c;
    }

    #monitorVideoContainer {
      position: relative;
      width: 100%;
      height: calc(100% - 60px);
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0 0 8px 8px;
    }

    #monitorVideo {
      width: 100%;
      height: 100%;
      background: #000;
    }

    .monitor-controls {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      border-radius: 6px;
    }

    .monitor-controls button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .monitor-controls button:hover {
      background: #1d4ed8;
    }

    .monitor-controls button:disabled {
      background: #6b7280;
      cursor: not-allowed;
    }

    .monitor-loading {
      color: #888;
      font-size: 16px;
    }

    #networkErrorPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      display: none;
      background: #fff;
      color: #333;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      padding: 24px;
      width: 300px;
      text-align: center;
    }

    #networkErrorPanel .error-icon {
      font-size: 48px;
      color: #dc2626;
      margin-bottom: 16px;
    }

    #networkErrorPanel .error-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #dc2626;
    }

    #networkErrorPanel .error-message {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
      line-height: 1.5;
    }

    #networkErrorPanel .error-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    #networkErrorPanel .btn-retry {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    #networkErrorPanel .btn-retry:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
<div id="loginOverlay">
  <div id="loginCard">
    <h2>登录</h2>
    <form id="loginForm">
      <div class="form-row">
        <label for="username">用户名</label>
        <input id="username" name="username" autocomplete="username" placeholder="请输入用户名"/>
      </div>
      <div class="form-row">
        <label for="password">密码</label>
        <input id="password" name="password" type="password" autocomplete="current-password"
               placeholder="请输入密码"/>
      </div>
      <div class="form-actions">
        <button type="submit" class="btn">登录</button>
        <span id="loginError" class="error"></span>
      </div>
    </form>
  </div>
</div>

<div id="viewport"></div>
<div id="infoPanel"></div>
<div id="detailPanel"></div>
<div id="compass" aria-label="指南针">
  <svg viewBox="0 0 100 100">
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6"
              orient="auto-start-reverse">
        <path d="M0,0 L10,5 L0,10 z" fill="#d00"/>
      </marker>
    </defs>
    <circle cx="50" cy="50" r="38" fill="none" stroke="#888" stroke-width="2"/>
    <line x1="50" y1="50" x2="50" y2="12" stroke="#d00" stroke-width="3" marker-end="url(#arrow)"/>
    <line x1="50" y1="10" x2="50" y2="20" stroke="#666" stroke-width="2"/>
    <line x1="50" y1="80" x2="50" y2="90" stroke="#666" stroke-width="2"/>
    <line x1="10" y1="50" x2="20" y2="50" stroke="#666" stroke-width="2"/>
    <line x1="80" y1="50" x2="90" y2="50" stroke="#666" stroke-width="2"/>
    <text x="50" y="8" text-anchor="middle" class="label">N</text>
    <text x="92" y="54" text-anchor="middle" class="label">E</text>
    <text x="50" y="98" text-anchor="middle" class="label">S</text>
    <text x="8" y="54" text-anchor="middle" class="label">W</text>
  </svg>
</div>
<div id="whPanel"></div>

<div id="actionBar" aria-live="polite">
  <div class="action-bar">
    <button id="btnLfs" class="btn">查看LFS订单</button>
    <button id="btnTms" class="btn">查看相关TMS运输订单</button>
    <button id="btnFee" class="btn">查看平仓仓储费用</button>
    <button id="btnMonitor" class="btn">查看监控</button>
  </div>
</div>

<!-- 网络错误提示面板 -->
<div id="networkErrorPanel">
  <div class="error-icon">⚠️</div>
  <div class="error-title">网络连接错误</div>
  <div class="error-message">网络繁忙，请稍后再试</div>
  <div class="error-actions">
    <button class="btn-retry" id="retryBtn">重试</button>
  </div>
</div>

<!-- 监控播放面板 -->
<div id="monitorPanel">
  <div class="monitor-header">
    <h3 class="monitor-title">筒仓监控播放</h3>
    <button class="monitor-close" id="monitorClose">×</button>
  </div>
  <div id="monitorVideoContainer">
    <video id="monitorVideo" controls autoplay muted>
      您的浏览器不支持视频播放
    </video>
    <div class="monitor-controls">
      <button id="playBtn">播放</button>
      <button id="pauseBtn">暂停</button>
      <button id="fullscreenBtn">全屏</button>
    </div>
    <div class="monitor-loading" id="monitorLoading" style="display: none;">
      正在加载监控流...
    </div>
  </div>
</div>

<!-- 引入flv.js用于播放萤石监控流 -->
<script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
  import {CSS2DRenderer, CSS2DObject} from 'three/addons/renderers/CSS2DRenderer.js';

  // 登录逻辑
  const loginOverlay = document.getElementById('loginOverlay');
  const loginForm = document.getElementById('loginForm');
  const loginError = document.getElementById('loginError');
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  let currentUser = null;

  loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const u = usernameInput.value.trim();
    const p = passwordInput.value;
    if (u === 'JF' && p === '123456') {
      currentUser = u;
      loginOverlay.style.display = 'none';
    } else {
      currentUser = u;
      loginOverlay.style.display = 'none';
      //loginError.textContent = '用户名或密码不正确';
      //return;
    }
  });

  // 配置获取
  async function fetchYardConfig() {
    return {
      yard: {length: 300, width: 310, roadWidth: 20}, // 将length从350减少到300，缩小西方向50米；width保持290米
      warehouse: {
        count: 1,
        length: 45,
        width: 160,
        height: 20,
        roofHeight: 5,
        gap: 15,
      }
    };
  }

  async function fetchWarehouseStackConfig(warehouseIndex) {
    // P01(101), P02(102), P03(103) 平仓保持原来的18米宽度
    // 其他仓库（#A仓库和单个堆垛的平仓）使用30米宽度
    if (warehouseIndex === 101 || warehouseIndex === 102 || warehouseIndex === 103) {
      return {
        stackSize: {length: 40, width: 18, height: 8},
        spacing: 5,
        margin: 5
      };
    } else {
      return {
        stackSize: {length: 40, width: 30, height: 8},  // 增加堆垛长度从40到60
        spacing: 5,
        margin: 5
      };
    }
  }

  // Three.js 基础设置
  const container = document.getElementById('viewport');
  const infoPanel = document.getElementById('infoPanel');
  const detailPanel = document.getElementById('detailPanel');
  const compass = document.getElementById('compass');
  const whPanel = document.getElementById('whPanel');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  scene.fog = new THREE.Fog(0xf0f0f0, 600, 2500);
  
  // 将scene存储到window对象中，确保全局可访问
  window.globalScene = scene;

  const camera = new THREE.PerspectiveCamera(65, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(600, 600, 600);
  camera.lookAt(0, 0, 0);
  window.globalCamera = camera;

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(container.clientWidth, container.clientHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0';
  labelRenderer.domElement.style.left = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  labelRenderer.domElement.style.zIndex = '10';
  container.appendChild(labelRenderer.domElement);




  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  const polarAngle = Math.PI / 4;
  controls.minPolarAngle = polarAngle;
  controls.maxPolarAngle = polarAngle;
  controls.minDistance = 100;
  controls.maxDistance = 2000;
  controls.target.set(0, 0, 0);

  // 光照系统
  const hemi = new THREE.HemisphereLight(0xffffff, 0xd0d0d0, 0.8);
  scene.add(hemi);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(200, 300, 200);
  dirLight.castShadow = true;
  dirLight.shadow.camera.left = -300;
  dirLight.shadow.camera.right = 300;
  dirLight.shadow.camera.top = 300;
  dirLight.shadow.camera.bottom = -300;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambLight);

  // 线框创建
  function createWireframe(geometry, color = 0x333333) {
    const edges = new THREE.EdgesGeometry(geometry);
    const mat = new THREE.LineBasicMaterial({color});
    return new THREE.LineSegments(edges, mat);
  }


  // 颜色配置
  const lineColors = {
    wall: 0x555555,
    roof: 0x8B4513,
    stack: 0x6b6b6b,
    hover: 0x1e90ff,
    selected: 0xff3333,
    ownerJF: 0x22aa22,
    fence: 0x2f855a,
    tree: 0x2e7d32,
    silo: 0x888888,
    siloOwnerJF: 0x33bb33,
    siloHover: 0x2eb8ff,
    siloSelected: 0xff4444,
    weighbridge: 0x4A4A4A,
    weighbridgeHover: 0x5A5A5A,
    weighbridgeSelected: 0x6A6A6A,
    // 星仓颜色配置
    starSilo: 0xffc75f,           // 星仓基础颜色（金黄色）
    starSiloOwnerJF: 0xffb347,    // 建发集团星仓颜色（橙黄色）
    starSiloHover: 0xffd700,      // 星仓悬浮颜色（金色）
    starSiloSelected: 0xff8c00,   // 星仓选中颜色（深橙色）
  };

  const emptySiloColor = 0xD8D8D0; // Neutral fill for silos without material data
  const noNumberSiloColor = 0xFF6B6B; // 红色，表示没有分配编号的筒仓

  // 颜色转换工具函数
  function getColorCSS(hexColor) {
    return `#${hexColor.toString(16).padStart(6, '0')}`;
  }

  // HSL颜色处理函数
  function parseColor(colorValue) {
    if (!colorValue) return { hex: 0x666666, css: '#666666' };
    
    // 如果是HSL格式
    if (typeof colorValue === 'string' && colorValue.includes('hsl')) {
      const hexValue = hslToHex(colorValue);
      return { hex: hexValue, css: getColorCSS(hexValue) };
    }
    
    // 如果是十六进制数值
    if (typeof colorValue === 'number') {
      return { hex: colorValue, css: getColorCSS(colorValue) };
    }
    
    // 如果是十六进制字符串
    if (typeof colorValue === 'string' && colorValue.startsWith('#')) {
      const hex = parseInt(colorValue.substring(1), 16);
      return { hex: hex, css: colorValue };
    }
    
    // 默认颜色
    return { hex: 0x666666, css: '#666666' };
  }

  // HSL转十六进制
  function hslToHex(hslString) {
    const match = hslString.match(/hsl\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)%,\s*(\d+(?:\.\d+)?)%\)/);
    if (!match) {
      return 0x666666;
    }
    
    const h = parseFloat(match[1]) / 360;
    const s = parseFloat(match[2]) / 100;
    const l = parseFloat(match[3]) / 100;
    
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    let r, g, b;
    if (s === 0) {
      r = g = b = l; // 无饱和度
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    
    const rHex = Math.round(r * 255);
    const gHex = Math.round(g * 255);
    const bHex = Math.round(b * 255);
    
    const result = (rHex << 16) + (gHex << 8) + bHex;
    return result;
  }

  // 颜色解析测试函数
  function testColorParsing() {
    const testColors = [
      'hsl(162.0, 65%, 55%)',
      '#ff0000',
      0x00ff00,
      'hsl(240, 100%, 50%)',
      'invalid-color'
    ];
    
    testColors.forEach(color => {
      const result = parseColor(color);
    });
  }

  // 真实API接口配置
  const API_CONFIG = {
    BASE_URL: 'http://127.0.0.1:8062', // 正式本地API服务`
    // BASE_URL: 'https://6166qiyy8859.vicp.fun', // 远程API服务
    PATH_PREFIX: '/driver-appointment-service',
    ENDPOINTS: {
      ALL_SILOS: '/api/order-driver/obtainTheSiloQinzhou',
      ALL_WEIGHBRIDGES: '/api/order-driver/weighbridgeData' // 正式地磅数据接口
    }
  };

  // 全局筒仓数据缓存
  let globalSiloData = null;
  let lastFetchTime = 0;
  const CACHE_DURATION = 5 * 60 * 1000; // 5分钟缓存
  
  // 请求去重机制：确保同一时间只有一个API请求
  let ongoingFetchPromise = null;

  // 全局地磅数据缓存
  let globalWeighbridgeData = null;
  let lastWeighbridgeFetchTime = 0;
  let ongoingWeighbridgeFetchPromise = null;

  // 从真实API获取所有筒仓数据
  async function fetchAllSilosFromAPI() {
    const now = Date.now();
    
    // 如果有缓存且未过期，直接使用缓存
    if (globalSiloData && (now - lastFetchTime) < CACHE_DURATION) {
      return globalSiloData;
    }
    
    // 如果已经有请求在进行中，等待该请求完成
    if (ongoingFetchPromise) {
      return await ongoingFetchPromise;
    }

    // 创建新的请求Promise
    ongoingFetchPromise = performActualFetch();
    
    try {
      const result = await ongoingFetchPromise;
      return result;
    } finally {
      // 请求完成后清除Promise引用，允许后续请求
      ongoingFetchPromise = null;
    }
    
    async function performActualFetch() {
      try {
        const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.PATH_PREFIX}${API_CONFIG.ENDPOINTS.ALL_SILOS}`;
        
        const response = await fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
        }

        const apiResponse = await response.json();
        
        if (apiResponse.success && apiResponse.data) {
          // 将对象格式的数据转换为数组格式
          const siloList = [];
          const dataKeys = Object.keys(apiResponse.data);
          
          dataKeys.forEach(key => {
            const siloData = apiResponse.data[key];
            if (siloData && siloData.siloInfo) {
              siloList.push(siloData);
            }
          });
          
          // 构造前端期望的数据格式
          globalSiloData = {
            siloList: siloList,
            totalCount: siloList.length,
            timestamp: new Date().toISOString(),
            dataSource: 'production-api'
          };
          
          lastFetchTime = now;
          return globalSiloData;
        } else {
          throw new Error('API返回数据格式错误');
        }
      } catch (error) {
        // 显示网络错误提示
        showNetworkError();
        throw new Error('网络繁忙，请稍后再试');
      }
    }
  }

  // 从真实API获取所有地磅数据
  async function fetchAllWeighbridgesFromAPI() {
    const now = Date.now();
    
    // 如果有缓存且未过期，直接使用缓存
    if (globalWeighbridgeData && (now - lastWeighbridgeFetchTime) < CACHE_DURATION) {
      return globalWeighbridgeData;
    }
    
    // 如果已经有请求在进行中，等待该请求完成
    if (ongoingWeighbridgeFetchPromise) {
      return await ongoingWeighbridgeFetchPromise;
    }

    // 创建新的请求Promise
    ongoingWeighbridgeFetchPromise = performActualWeighbridgeFetch();
    
    try {
      const result = await ongoingWeighbridgeFetchPromise;
      return result;
    } finally {
      // 请求完成后清除Promise引用，允许后续请求
      ongoingWeighbridgeFetchPromise = null;
    }
    
    async function performActualWeighbridgeFetch() {
      try {
        // 构建带参数的API URL
        const params = new URLSearchParams({
          warehouseName: '钦州侨益仓'  // 固定传递库区名称
        });
        const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.PATH_PREFIX}${API_CONFIG.ENDPOINTS.ALL_WEIGHBRIDGES}?${params}`;
        
        const response = await fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`地磅API请求失败: ${response.status} ${response.statusText}`);
        }

        const apiResponse = await response.json();
        
        // 适配正式接口返回格式: { success: true, code: 200, message: "SUCCESS", data: {MZDB11: {record}, MZDB21: {record}} }
        if (apiResponse.success && apiResponse.code === 200 && apiResponse.data) {
          
          const weighbridgeList = [];
          const dataKeys = Object.keys(apiResponse.data);
          
          // 检查是否有实际数据
          if (dataKeys.length === 0) {
            globalWeighbridgeData = {
              weighbridgeList: [],
              totalCount: 0,
              timestamp: new Date().toISOString(),
              dataSource: 'api-empty-data'
            };
            
            lastWeighbridgeFetchTime = now;
            
            // 更新场景中所有地磅的显示状态，清空车辆
            try {
              updateAllWeighbridgesInScene();
            } catch (error) {
              // 静默处理场景更新错误
            }
            
            return globalWeighbridgeData;
          }
          
          // 处理按设备号分组的数据结构
          dataKeys.forEach(equipmentNo => {
            const recordData = apiResponse.data[equipmentNo];
            
            if (recordData) {
              // 新格式：每个设备号对应单个对象，不再是数组
              const record = recordData;
              
              // 设备号到地磅编号的映射 - 更新为新的设备号
              let weighbridgeId;
              if (equipmentNo === 'QZQYCDB11') {
                weighbridgeId = '1号磅'; // 地磅1
              } else if (equipmentNo === 'QZQYCDB21') {
                weighbridgeId = '2号磅'; // 地磅2  
              } else if (equipmentNo === 'QZQYCDB31') {
                weighbridgeId = '3号磅'; // 地磅3
              } else if (equipmentNo === 'QZQYCDB41') {
                weighbridgeId = '4号磅'; // 地磅4
              } else {
                // 其他设备号，尝试从设备号中提取数字
                const match = equipmentNo.match(/(\d+)$/);
                weighbridgeId = match ? `${match[1]}号磅` : equipmentNo;
              }
              
              
          // 将分组后的数据转换为前端期望的格式
            // 将重量从kg转换为吨
            const weightInTons = record.ponderation ? (record.ponderation / 1000).toFixed(2) : 0;
            const correctedWeightInTons = record.correctPonderation ? (record.correctPonderation / 1000).toFixed(2) : null;
            
            // 判断地磅状态
            let status = '空闲';
            if (record.vehicleno && record.ponderation > 0) {
              status = '称重中';
            } else if (record.vehicleno) {
              status = '有车';
            }
            
            const convertedData = {
              weighbridgeInfo: {
                id: weighbridgeId, // 使用地磅编号作为ID
                equipmentNo: equipmentNo, // 保存原始设备号
                type: '地磅',
                status: status,
                currentWeight: parseFloat(weightInTons), // 当前重量（吨）
                plateNumber: record.vehicleno || '', // 车牌号
                vehicleType: '货车', // 默认车辆类型
                arrivalTime: record.regtimeV || record.regtime || '', // 过磅时间
                driver: record.driver || '', // 司机姓名
                driverid: record.driverid || '', // 司机身份证
                warehouseName: '钦州侨益仓', // 库区 - 固定传参
                correctPonderation: correctedWeightInTons, // 纠正重量（吨）
                frontimg: record.frontimg || '', // 前端车牌图片
                backimg: record.backimg || '', // 后端车牌图片
                wholeimg: record.wholeimg || '', // 全景图片
                createTime: record.createOnV || record.createOn || '', // 记录时间
                recordId: record.id // 记录ID
              }
            };
            weighbridgeList.push(convertedData);
            }
          });
          
          // 构造前端期望的数据格式
          globalWeighbridgeData = {
            weighbridgeList: weighbridgeList,
            totalCount: weighbridgeList.length,
            timestamp: apiResponse.timestamp || new Date().toISOString(),
            dataSource: 'real-production-api', // 真实生产环境API
            apiEndpoint: apiUrl
          };
          
          lastWeighbridgeFetchTime = now;
          
          // 更新场景中所有地磅的显示状态
          try {
            updateAllWeighbridgesInScene();
          } catch (error) {
            // 静默处理场景更新错误
          }
          
          return globalWeighbridgeData;
        } else {
          // 返回空的默认数据结构，不抛出错误
          globalWeighbridgeData = {
            weighbridgeList: [],
            totalCount: 0,
            timestamp: new Date().toISOString(),
            dataSource: 'format-error-fallback'
          };
          
          lastWeighbridgeFetchTime = now;
          
          // 更新场景中所有地磅的显示状态，清空车辆
          try {
            updateAllWeighbridgesInScene();
          } catch (error) {
            // 静默处理场景更新错误
          }
          
          return globalWeighbridgeData;
        }
      } catch (error) {
        // 显示网络错误提示
        showNetworkError();
        
        // 返回空的默认数据结构，不抛出错误
        globalWeighbridgeData = {
          weighbridgeList: [],
          totalCount: 0,
          timestamp: new Date().toISOString(),
          dataSource: 'api-error-fallback'
        };
        
        lastWeighbridgeFetchTime = now;
        
        // 更新场景中所有地磅的显示状态，清空车辆
        try {
          updateAllWeighbridgesInScene();
        } catch (error) {
          // 静默处理场景更新错误
        }
        
        return globalWeighbridgeData;
      }
    }
  }

  // 自动刷新定时器
  let autoRefreshTimer = null;

  // 启动5秒定时轮询
  function startAutoRefresh() {
    // 安全检查：确保scene对象已经初始化
    if (typeof scene === 'undefined' || !scene) {
      setTimeout(startAutoRefresh, 1000); // 1秒后重试
      return;
    }
    
    // 清除之前的定时器
    if (autoRefreshTimer) {
      clearInterval(autoRefreshTimer);
    }
    
    
    // 立即获取一次数据
    fetchAllWeighbridgesFromAPI().catch(error => {
    });
    
    // 每5秒自动刷新一次
    autoRefreshTimer = setInterval(async () => {
      try {
        
        // 强制清除缓存，确保每次都发送真实请求
        globalWeighbridgeData = null;
        lastWeighbridgeFetchTime = 0;
        ongoingWeighbridgeFetchPromise = null;
        
        await fetchAllWeighbridgesFromAPI();
      } catch (error) {
      }
    }, 5000); // 5秒 = 5000毫秒
  }
  
  // 手动强制刷新功能（用于调试）
  function forceRefreshWeighbridges() {
    // 清除所有缓存
    globalWeighbridgeData = null;
    lastWeighbridgeFetchTime = 0;
    ongoingWeighbridgeFetchPromise = null;
    
    return fetchAllWeighbridgesFromAPI();
  }
  
  // 暴露到全局作用域供调试使用
  window.forceRefreshWeighbridges = forceRefreshWeighbridges;

  // 停止自动刷新
  function stopAutoRefresh() {
    if (autoRefreshTimer) {
      clearInterval(autoRefreshTimer);
      autoRefreshTimer = null;
    }
  }

  // 根据地磅编号从全局数据中获取单个地磅数据
  async function fetchWeighbridgeData(weighbridgeParams) {
    const { weighbridgeId, weighbridgeNumber, length, width, maxWeight } = weighbridgeParams;
    
    // 如果没有编号，直接返回默认数据
    if (!weighbridgeNumber) {
      return {
        weighbridgeInfo: {
          id: `未分配编号-${weighbridgeId}`,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '空闲',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'no-number-assigned'
      };
    }
    
    // 获取所有地磅数据
    let allWeighbridgesData;
    try {
      allWeighbridgesData = await fetchAllWeighbridgesFromAPI();
    } catch (error) {
      // 如果API调用失败，直接返回默认数据，不抛出错误
      return {
        weighbridgeInfo: {
          id: weighbridgeNumber,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '离线',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'api-failed-fallback'
      };
    }
    
    if (!allWeighbridgesData || !allWeighbridgesData.weighbridgeList) {
      // 如果数据格式异常，返回默认数据，不抛出错误
      return {
        weighbridgeInfo: {
          id: weighbridgeNumber,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '离线',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'data-format-error-fallback'
      };
    }

    // 直接使用传入的地磅编号查找API数据
    let targetWeighbridge;
    if (weighbridgeNumber) {
      // 优先使用传入的编号查找
      targetWeighbridge = allWeighbridgesData.weighbridgeList.find(wb => wb.weighbridgeInfo.id === weighbridgeNumber);
    }
    
    // 如果按编号未找到，返回默认数据
    if (!targetWeighbridge) {
      return {
        weighbridgeInfo: {
          id: weighbridgeNumber,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '空闲',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'api-not-found'
      };
    }
    
    if (targetWeighbridge) {
      const actualId = targetWeighbridge.weighbridgeInfo.id;
      
      return {
        weighbridgeInfo: targetWeighbridge.weighbridgeInfo,
        timestamp: Date.now(),
        dataSource: allWeighbridgesData.dataSource
      };
    }
  }

  // 根据筒仓编号从全局数据中获取单个筒仓数据
  async function fetchSiloAndMaterialData(siloParams) {
    const { siloId, siloNumber, siloType, radius, height, volume, capacity } = siloParams;
    
    // 如果没有编号，直接返回默认数据，表示接口中没有对应数据
    if (!siloNumber) {
      return {
        siloInfo: {
          id: `未分配编号-${siloId}`,
          type: siloType || '筒仓',
          radius: radius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '未配置'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'no-number-assigned'
      };
    }
    
    // 获取所有筒仓数据
    const allSilosData = await fetchAllSilosFromAPI();
    
    if (!allSilosData || !allSilosData.siloList) {
      throw new Error('网络繁忙，请稍后再试');
    }

    // 直接使用传入的筒仓编号查找API数据
    let targetSilo;
    if (siloNumber) {
      // 优先使用传入的编号查找
      targetSilo = allSilosData.siloList.find(silo => silo.siloInfo.id === siloNumber);
    }
    
    // 如果按编号未找到，不使用备用映射，直接返回空数据
    // 这样可以确保只有API中真正存在的编号才会显示数据
    if (!targetSilo) {
    }
    
    if (targetSilo) {
      const actualId = targetSilo.siloInfo.id;
      
      // 特殊处理：P01、P02、P03或以P开头的数据实际上是平仓数据
      const actualType = (actualId === 'P01' || actualId === 'P02' || actualId === 'P03' || actualId.startsWith('P')) ? `平仓${actualId}` : targetSilo.siloInfo.type;
      
      if (actualId === 'P01' || actualId.startsWith('P')) {
      }
      
      // 转换API数据格式为前端需要的格式
      return {
        siloInfo: {
          id: targetSilo.siloInfo.id,
          type: actualType,
          radius: targetSilo.siloInfo.radius,
          height: targetSilo.siloInfo.height,
          volume: targetSilo.siloInfo.volume,
          maxCapacity: targetSilo.siloInfo.maxCapacity,
          currentStorage: targetSilo.siloInfo.currentStorage,
          mainCargo: extractMainCargo(targetSilo.materialDetails),
          storageTime: targetSilo.siloInfo.storageTime,
          temperature: targetSilo.siloInfo.temperature,
          humidity: targetSilo.siloInfo.humidity,
          status: targetSilo.siloInfo.status,
          owner: extractOwner(targetSilo.materialDetails),
          specialMark: targetSilo.siloInfo.specialMark,
          arms: targetSilo.siloInfo.arms
        },
        materialDetails: targetSilo.materialDetails || [],
        timestamp: targetSilo.timestamp,
        dataSource: targetSilo.dataSource || 'production-api'
      };
    } else {
      // 返回默认的空筒仓数据，避免系统崩溃
      return {
        siloInfo: {
          id: `T${String(siloId).padStart(3, '0')}`,
          type: siloType || '筒仓',
          radius: siloParams.radius,
          height: siloParams.height,
          volume: siloParams.volume,
          maxCapacity: siloParams.capacity,
          currentStorage: 0,
          mainCargo: '空仓',
          storageTime: '',
          temperature: '',
          humidity: '',
          status: '空仓',
          owner: null
        },
        materialDetails: [],
        timestamp: new Date().toISOString(),
        dataSource: 'fallback-empty'
      };
    }
  }
  
  // 辅助函数：从物料详情中提取主要货物
  function extractMainCargo(materialDetails) {
    if (!materialDetails || materialDetails.length === 0) return '空仓';
    
    // 找到数量最大的物料
    const maxMaterial = materialDetails.reduce((max, current) => {
      const currentAmount = Math.abs(parseFloat(current.amount) || 0);
      const maxAmount = Math.abs(parseFloat(max.amount) || 0);
      return currentAmount > maxAmount ? current : max;
    }, materialDetails[0]);
    
    return maxMaterial.material || '未知';
  }
  
  // 辅助函数：从物料详情中提取所有者
  function extractOwner(materialDetails) {
    if (!materialDetails || materialDetails.length === 0) return null;
    
    // 获取所有公司名称，去重
    const companies = [...new Set(materialDetails.map(m => m.company).filter(Boolean))];
    return companies.length > 0 ? companies[0] : null;
  }




  // 网络错误处理
  const networkErrorPanel = document.getElementById('networkErrorPanel');
  const retryBtn = document.getElementById('retryBtn');

  function showNetworkError() {
    networkErrorPanel.style.display = 'block';
  }

  function hideNetworkError() {
    networkErrorPanel.style.display = 'none';
  }

  // 重试按钮事件监听
  retryBtn.addEventListener('click', () => {
    hideNetworkError();
    // 重新初始化系统
    location.reload();
  });

  const raycastTargets = [];
  const raycastTargetSet = new Set();
  const interactives = [];
  const interactiveSet = new Set();

  function registerPickable(obj) {
    if (!obj || raycastTargetSet.has(obj)) return;
    raycastTargets.push(obj);
    raycastTargetSet.add(obj);
  }

  function registerInteractive(obj) {
    if (!obj || interactiveSet.has(obj)) return;
    registerPickable(obj);
    interactives.push(obj);
    interactiveSet.add(obj);
    
  }
  let hovered = null;
  let selected = null;

  const actionBar = document.getElementById('actionBar');
  const btnLfs = document.getElementById('btnLfs');
  const btnTms = document.getElementById('btnTms');
  const btnFee = document.getElementById('btnFee');
  const btnMonitor = document.getElementById('btnMonitor');

  const isOwnedByCurrent = (obj) => !!currentUser && obj?.userData?.owner === currentUser;

  // 监控相关元素和变量
  const monitorPanel = document.getElementById('monitorPanel');
  const monitorVideo = document.getElementById('monitorVideo');
  const monitorClose = document.getElementById('monitorClose');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const monitorLoading = document.getElementById('monitorLoading');
  
  let flvPlayer = null;
  const YINGSHI_MONITOR_URL = 'https://rtmp05open.ys7.com:9188/v3/openlive/C54441328_1_1.flv?expire=1761814378&id=901513545338388480&t=d8d642746d1c4827d6a11f1a4cd035c7ae35f3b27af62bb14611d3b9eef52f82&ev=101&supportH265=1';

  // 监控播放器初始化函数
  function initFlvPlayer() {
    if (flvPlayer) {
      flvPlayer.destroy();
      flvPlayer = null;
    }

    if (flvjs.isSupported()) {
      flvPlayer = flvjs.createPlayer({
        type: 'flv',
        url: YINGSHI_MONITOR_URL,
        isLive: true,
        cors: true,
        withCredentials: false,
        hasAudio: false,
        hasVideo: true
      });
      
      flvPlayer.attachMediaElement(monitorVideo);
      
      // 播放器事件监听
      flvPlayer.on(flvjs.Events.LOADING_COMPLETE, () => {
        monitorLoading.style.display = 'none';
      });
      
      flvPlayer.on(flvjs.Events.ERROR, (errorType, errorDetail, errorInfo) => {
        monitorLoading.textContent = '监控流加载失败，请稍后重试';
        monitorLoading.style.color = '#dc2626';
      });
      
      try {
        flvPlayer.load();
      } catch (e) {
        monitorLoading.textContent = '监控播放器初始化失败';
        monitorLoading.style.color = '#dc2626';
      }
    } else {
      monitorLoading.textContent = '当前浏览器不支持FLV视频播放';
      monitorLoading.style.color = '#dc2626';
    }
  }

  // 显示监控面板
  function showMonitorPanel(siloData) {
    const siloType = '筒仓';
    const monitorTitle = monitorPanel.querySelector('.monitor-title');
    monitorTitle.textContent = `${siloType} #${siloData.id} 监控播放`;
    
    monitorPanel.style.display = 'block';
    monitorLoading.style.display = 'block';
    monitorLoading.textContent = '正在连接监控流...';
    monitorLoading.style.color = '#888';
    
    // 延迟初始化播放器，确保面板已显示
    setTimeout(() => {
      initFlvPlayer();
    }, 100);
  }

  // 关闭监控面板
  function closeMonitorPanel() {
    monitorPanel.style.display = 'none';
    if (flvPlayer) {
      flvPlayer.pause();
      flvPlayer.unload();
      flvPlayer.detachMediaElement();
      flvPlayer.destroy();
      flvPlayer = null;
    }
  }

  function updateCompass() {
    const az = controls.getAzimuthalAngle();
    const deg = -THREE.MathUtils.radToDeg(az);
    compass.style.transform = `rotate(${deg}deg)`;
  }

  function fitCameraToYard(yardLength, yardWidth, maxHeight, fillRatio = 1.0) {
    const size = new THREE.Vector3(yardLength, maxHeight, yardWidth);
    const radius = size.length() / 2;
    const vFov = THREE.MathUtils.degToRad(camera.fov);
    const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect);
    const distV = radius / Math.tan(vFov / 2);
    const distH = radius / Math.tan(hFov / 2);
    const distance = Math.max(distV, distH) * fillRatio;

    const az = controls.getAzimuthalAngle();
    const phi = controls.getPolarAngle();
    const target = new THREE.Vector3(0, Math.max(0, maxHeight * 0.5), 0);
    controls.target.copy(target);
    camera.position.set(
      target.x + distance * Math.sin(phi) * Math.sin(az),
      target.y + distance * Math.cos(phi),
      target.z + distance * Math.sin(phi) * Math.cos(az)
    );
    camera.updateProjectionMatrix();

    controls.minDistance = Math.max(10, distance * 0.35);
    controls.maxDistance = distance * 3.0;
    controls.update();
  }

  function buildYardGrid(length, width) {
    const size = Math.max(length, width);
    const divisions = size / 10;
    const grid = new THREE.GridHelper(size, divisions, 0xaaaaaa, 0xcccccc);
    grid.scale.z = width / length;
    scene.add(grid);

    const halfL = length / 2, halfW = width / 2;
    const borderPts = [
      [-halfL, 0, -halfW], [halfL, 0, -halfW],
      [halfL, 0, halfW], [-halfL, 0, halfW],
      [-halfL, 0, -halfW]
    ].map(([x, y, z]) => new THREE.Vector3(x, y, z));
    const geom = new THREE.BufferGeometry().setFromPoints(borderPts);
    const border = new THREE.Line(geom, new THREE.LineBasicMaterial({color: 0x888888}));
    scene.add(border);
  }

  function buildMainRoad(roadWidth, length, zOffset = 0) {
    const halfL = length / 2;
    const halfW = roadWidth / 2;
    const sidewalk = 3;
    const laneEdge = halfW - sidewalk;

    const y = 0.02;
    const mkLine = (pts, material) => {
      const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p[0], y, p[1] + zOffset)));
      const line = new THREE.Line(g, material);
      return line;
    };

    const baseMat = new THREE.LineBasicMaterial({color: 0x444444});
    const dashedMat = new THREE.LineDashedMaterial({color: 0x888888, dashSize: 10, gapSize: 6});

    scene.add(mkLine([[-halfL, -halfW], [halfL, -halfW]], baseMat.clone()));
    scene.add(mkLine([[-halfL, halfW], [halfL, halfW]], baseMat.clone()));
    scene.add(mkLine([[-halfL, -laneEdge], [halfL, -laneEdge]], baseMat.clone()));
    scene.add(mkLine([[-halfL, laneEdge], [halfL, laneEdge]], baseMat.clone()));

    const gCenter = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-halfL, y, 0 + zOffset), new THREE.Vector3(halfL, y, 0 + zOffset)
    ]);
    const centerLine = new THREE.Line(gCenter, dashedMat);
    centerLine.computeLineDistances();
    scene.add(centerLine);
  }

  function buildSidewalkTrees(roadWidth, length, spacing = 10, zOffset = 0) {
    const halfL = length / 2;
    const halfW = roadWidth / 2;
    const sidewalk = 3;
    const zOnSidewalk = halfW - sidewalk / 2;

    for (let x = -halfL; x <= halfL + 1e-6; x += spacing) {
      addTree(x, zOnSidewalk + zOffset);
      addTree(x, -zOnSidewalk + zOffset);
    }

    function addTree(x, z) {
      const group = new THREE.Group();
      const trunkH = 6;
      const canopyH = 2;

      const trunkGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, trunkH, 0)
      ]);
      const trunk = new THREE.Line(trunkGeom, new THREE.LineBasicMaterial({color: lineColors.tree}));
      group.add(trunk);

      const coneGeo = new THREE.ConeGeometry(1.4, canopyH, 10);
      const edges = new THREE.EdgesGeometry(coneGeo);
      const canopy = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: lineColors.tree}));
      canopy.position.y = trunkH + canopyH / 2;
      group.add(canopy);

      group.position.set(x, 0, z);
      scene.add(group);
    }
  }

  // 铁路建造函数
  function buildRailway(length, zOffset = 0, xOffset = 0) {
    const halfL = length / 2;
    const trackGauge = 1.435; // 标准轨距（米）
    const railHeight = 0.15; // 钢轨高度
    const tieWidth = 2.5; // 枕木宽度
    const tieSpacing = 0.6; // 枕木间距
    const tieThickness = 0.2; // 枕木厚度
    
    const y = 0.05; // 铁轨高度
    
    // 钢轨材质（深灰色金属）
    const railMaterial = new THREE.LineBasicMaterial({color: 0x555555});
    
    // 枕木材质（棕色木材）
    const tieMaterial = new THREE.LineBasicMaterial({color: 0x8B4513});
    
    // 创建两条轨道（左右）
    const leftRailZ = -trackGauge / 2;
    const rightRailZ = trackGauge / 2;
    
    // 左侧轨道
    const leftRailGeom = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-halfL + xOffset, y, leftRailZ + zOffset),
      new THREE.Vector3(halfL + xOffset, y, leftRailZ + zOffset)
    ]);
    const leftRail = new THREE.Line(leftRailGeom, railMaterial);
    scene.add(leftRail);
    
    // 右侧轨道
    const rightRailGeom = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-halfL + xOffset, y, rightRailZ + zOffset),
      new THREE.Vector3(halfL + xOffset, y, rightRailZ + zOffset)
    ]);
    const rightRail = new THREE.Line(rightRailGeom, railMaterial);
    scene.add(rightRail);
    
    // 添加枕木
    for (let x = -halfL; x <= halfL; x += tieSpacing) {
      const tieGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(x + xOffset, y - 0.02, -tieWidth / 2 + zOffset),
        new THREE.Vector3(x + xOffset, y - 0.02, tieWidth / 2 + zOffset)
      ]);
      const tie = new THREE.Line(tieGeom, tieMaterial);
      scene.add(tie);
      
      // 添加枕木的横向线条以增加立体感
      const tieTopGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(x - tieThickness / 2 + xOffset, y, -tieWidth / 2 + zOffset),
        new THREE.Vector3(x - tieThickness / 2 + xOffset, y, tieWidth / 2 + zOffset)
      ]);
      const tieTop = new THREE.Line(tieTopGeom, tieMaterial);
      scene.add(tieTop);
    }
  }

  function buildWarehouse({length, width, height, roofHeight}, centerX, centerZ, index) {
    const group = new THREE.Group();
    group.position.set(centerX, 0, centerZ);

    const wall = createWireframe(new THREE.BoxGeometry(length, height, width), lineColors.wall);
    wall.position.set(0, height / 2, 0);
    wall.userData = {type: '仓库', 序号: index + 1, 长: length, 宽: width, 高: height};
    group.add(wall);

    const hx = length / 2, hz = width / 2, yTop = height, yRidge = height + roofHeight;
    const roofColor = lineColors.roof;
    const roofLines = [];
    roofLines.push([[-hx, yTop, -hz], [0, yRidge, -hz], [hx, yTop, -hz], [-hx, yTop, -hz]]);
    roofLines.push([[-hx, yTop, hz], [0, yRidge, hz], [hx, yTop, hz], [-hx, yTop, hz]]);
    roofLines.push([[-hx, yRidge, 0], [hx, yRidge, 0]]);
    roofLines.push([[-hx, yTop, -hz], [-hx, yTop, hz]]);
    roofLines.push([[hx, yTop, -hz], [hx, yTop, hz]]);

    for (const pts of roofLines) {
      const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p[0], p[1], p[2])));
      const line = new THREE.Line(g, new THREE.LineBasicMaterial({color: roofColor}));
      group.add(line);
    }

    const idChar = String.fromCharCode(65 + (index % 26));
    const area = length * width;
    const services = [];
    const temperature = '0.0';
    const phone = '';
    group.userData.whInfo = {id: `#${idChar}`, area, temperature, services, phone};

    // 不添加仓库标签，只显示堆垛名称
    // const labelEl = document.createElement('div');
    // labelEl.className = 'whLabel';
    // labelEl.textContent = group.userData.whInfo.id;
    // const labelObj = new CSS2DObject(labelEl);
    // labelObj.position.set(0, height + roofHeight + 6, 0);
    // group.add(labelObj);

    scene.add(group);
    return group;
  }

  // 保安室构建函数
  function buildSecurityRoom() {
    const securityRoomGeometry = new THREE.BoxGeometry(10, 8, 8);
    const securityRoomMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const securityRoom = new THREE.Mesh(securityRoomGeometry, securityRoomMaterial);
    
    // 设置保安室位置
    securityRoom.position.set(-50, 4, -30);
    
    // 添加门
    const doorGeometry = new THREE.BoxGeometry(2, 6, 0.2);
    const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
    const door = new THREE.Mesh(doorGeometry, doorMaterial);
    door.position.set(0, -1, 4.1);
    securityRoom.add(door);
    
    // 添加窗户
    const windowGeometry = new THREE.BoxGeometry(3, 2, 0.2);
    const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB });
    const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
    window1.position.set(-3, 1, 4.1);
    securityRoom.add(window1);
    
    const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
    window2.position.set(3, 1, 4.1);
    securityRoom.add(window2);
    
    // 添加保安室标识
    const textLoader = new THREE.FontLoader();
    textLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
      const textGeometry = new THREE.TextGeometry('保安室', {
        font: font,
        size: 1,
        height: 0.1,
      });
      const textMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textMesh.position.set(-2.5, 2.5, 4.2);
      securityRoom.add(textMesh);
    });
    
    return securityRoom;
  }

  document.addEventListener('click', (e) => {
    // 不处理canvas区域的点击，避免与Three.js交互冲突
    if (e.target === renderer.domElement || renderer.domElement.contains(e.target)) return;
    
    if (e.target && (e.target.closest && e.target.closest('#actionBar'))) return;
    whPanel.style.display = 'none';
    clearSelection();
  });

  let stackIdSeq = 1;

  async function populateStacks(warehouseGroup, wConf, stackConf, index) {
    const {length, width, height} = wConf;
    const {length: sx, width: sz, height: sy} = stackConf.stackSize;

    const center = new THREE.Vector3();
    warehouseGroup.getWorldPosition(center);
    const cx = center.x, cz = center.z;
    const whInfo = warehouseGroup.userData?.whInfo || null;

    // 根据仓库索引判断是#A仓库还是平仓，并为每个仓库分配独立的堆垛名称
    // index < 100: #A仓库（单个堆垛）
    // index == 101: P01平仓（3个堆垛从南到北排列）
    // index == 102: P02平仓（3个堆垛从南到北排列）
    // index == 103: P03平仓（3个堆垛从南到北排列）
    // index == 104: P04平仓（单个堆垛）
    let stackPositions;
    
    if (index < 100) {
      // #A仓库：2个堆垛，左右各1个
      const stackSpacingX = sx * 1.2;  // 东西方向间距（增大拉开距离）
      stackPositions = [
        { x: cx - stackSpacingX, z: cz, number: '2号库' },  // 左侧堆垛
        { x: cx + stackSpacingX, z: cz, number: '1号库' }   // 右侧堆垛
      ];
    } else if (index === 101) {
      // P01平仓：1个堆垛（保留中间的）
      stackPositions = [
        { x: cx, z: cz, number: '3号库' }                      // 中心堆垛
      ];
    } else if (index === 102) {
      // P02平仓：3个堆垛从南到北排列
      const stackSpacing = sz * 1.2;
      stackPositions = [
        { x: cx, z: cz - stackSpacing, number: '4-1' },      // 南侧堆垛
        { x: cx, z: cz, number: '4-2' },                     // 中心堆垛
        { x: cx, z: cz + stackSpacing, number: '4-3' }       // 北侧堆垛
      ];
    } else if (index === 103) {
      // P03平仓：3个堆垛从南到北排列
      const stackSpacing = sz * 1.2;
      stackPositions = [
        { x: cx, z: cz - stackSpacing, number: '3-1' },      // 南侧堆垛
        { x: cx, z: cz, number: '3-2' },                     // 中心堆垛
        { x: cx, z: cz + stackSpacing, number: '3-3' }       // 北侧堆垛
      ];
    } else if (index === 104) {
      // P04平仓：单个堆垛
      stackPositions = [
        { x: cx, z: cz, number: '1-1' }  // 单个堆垛
      ];
    } else if (index === 105) {
      // P05平仓：单个堆垛
      stackPositions = [
        { x: cx, z: cz, number: '7-1' }  // 单个堆垛
      ];
    } else if (index === 106) {
      // P06平仓：单个堆垛
      stackPositions = [
        { x: cx, z: cz, number: '6-1' }  // 单个堆垛
      ];
    } else {
      // 默认情况：单个堆垛
      stackPositions = [
        { x: cx, z: cz, number: `仓库${index}` }
      ];
    }

    for (let i = 0; i < stackPositions.length; i++) {
      const position = stackPositions[i];
      const stackNumber = position.number;
      
      // 创建平仓几何体
      const stack = createWireframe(new THREE.BoxGeometry(sx, sy, sz), lineColors.stack);
      stack.position.set(position.x, sy / 2, position.z);
      stack.material = new THREE.LineBasicMaterial({color: lineColors.stack});
      const vol = (sx * sy * sz).toFixed(0);
      const id = stackIdSeq++;

      // 从API获取平仓的真实数据
      let apiData;
      try {
        apiData = await fetchSiloAndMaterialData({
          siloId: id,
          siloNumber: stackNumber, // 使用对应的平仓编号
          siloType: `平仓${stackNumber}`,
          radius: Math.max(sx, sz) / 2,
          height: sy,
          volume: vol,
          capacity: (vol * 0.75).toFixed(1) // 假设密度0.75吨/立方米
        });
        
      } catch (error) {
        // API调用失败时，使用空数据
        apiData = {
          siloInfo: {
            id: stackNumber,
            type: `平仓${stackNumber}`,
            maxCapacity: '0.0',
            currentStorage: '0.0'
          },
          materialDetails: [],
          dataSource: 'api-failed'
        };
      }

      const { siloInfo, materialDetails } = apiData;
      const activeMaterials = Array.isArray(materialDetails)
        ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6)
        : [];
      const hasMaterialData = activeMaterials.length > 0;
      
      const finalType = siloInfo.type || `平仓${stackNumber}`;
      
      stack.userData = {
        type: '平仓', // 设置为平仓类型，以便正确处理选中颜色
        originalType: finalType, // 保留原始类型信息用于显示
        id: stackNumber, // 强制使用本地配置的堆垛名称
        编号: stackNumber, // 强制使用本地配置的堆垛名称
        owner: hasMaterialData ? siloInfo.owner : undefined,
        仓库序号: index + 1,
        体积_m3: vol,
        尺寸_m: `${sx}×${sy}×${sz}`,
        最大容量_t: siloInfo.maxCapacity,
        当前储量_t: siloInfo.currentStorage,
        物料详情: hasMaterialData ? activeMaterials : [],
        hasMaterialData: hasMaterialData,
        // 添加接口数据来源标识
        数据来源: apiData.dataSource,
        更新时间: apiData.timestamp,
        whInfo
      };

      // 根据是否有物料数据设置颜色：有数据显示绿色，无数据显示灰色
      const baseColor = hasMaterialData ? lineColors.ownerJF : lineColors.stack;
      setStackColor(stack, baseColor);

      scene.add(stack);
      registerPickable(stack);

      // 所有平仓都注册为可交互对象，无论是否有物料数据
      registerInteractive(stack);
    }
  }

  // 交互逻辑
  const raycaster = new THREE.Raycaster();
  raycaster.params.Line.threshold = 5; // 增加线框检测阈值，提高点击成功率
  const mouse = new THREE.Vector2();
  function resolveInteractiveTarget(object) {
    let current = object;
    let depth = 0;
    const maxDepth = 10; // 限制遍历深度，避免无限循环
    
    while (current && depth < maxDepth) {
      // 检查当前对象是否在可交互集合中
      if (interactiveSet.has(current)) {
        const userData = current.userData;
        if (userData?.type === '筒仓') {
          // 筒仓无论是否有数据都可以悬停显示名称
          return current;
        } else if (userData?.type === '星仓') {
          // 星仓无论是否有数据都可以悬停显示名称
          return current;
        } else if (userData?.type?.startsWith('平仓')) {
          // 所有平仓都可以交互，无论是否有物料数据
          return current;
        } else if (userData?.id?.toString().match(/^[0-9]+-[0-9]+$/)) {
          // 临时修复：如果ID匹配平仓格式（如"5-1", "5-2"），也认为是平仓
          return current;
        } else if (userData?.编号?.toString().match(/^[0-9]+-[0-9]+$/)) {
          // 额外检查：通过编号字段识别堆垛
          return current;
        } else if (userData?.originalType?.includes('平仓')) {
          // 通过原始类型识别平仓堆垛
          return current;
        } else if (userData?.type === '地磅') {
          // 地磅可以交互
          return current;
        }
      }
      current = current.parent;
      depth++;
    }
    return null;
  }

  function showHoverInfo(obj, clientX, clientY) {
    // 移除权限检查，所有对象都可以显示悬停信息

    const type = obj.userData?.type;
    if (type === '筒仓') {
      const cap = obj.userData?.最大容量_t || '-';
      const current = obj.userData?.当前储量_t || '0';
      const materials = obj.userData?.物料详情 || [];
      const label = '筒仓';
      
      let materialInfo = '';
      if (materials.length > 0) {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px;">';
        materials.forEach(m => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          materialInfo += `<div style="margin: 2px 0; display: flex; align-items: center;">
            <div style="width: 10px; height: 10px; background: ${companyColor}; border-radius: 2px; margin-right: 6px; border: 1px solid #ccc;"></div>
            <span style="color: ${companyColor}; font-weight: bold;">${m.company}: <span style="${amountStyle}">${negativeIcon}${m.amount}吨</span> ${m.material}</span>
          </div>`;
        });
        materialInfo += '</div>';
      } else {
        // 当没有物料数据时显示空仓状态
        materialInfo = '<div style="margin-top: 6px; font-size: 12px; color: #888;">暂无物料数据</div>';
      }
      
      infoPanel.innerHTML = `
        <div><b>${label} ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>容量: ${cap} 吨</div>
        <div>当前: ${current} 吨</div>
        ${materialInfo}
      `;
    } else if (type === '地磅') {
      // 地磅悬停信息
      const status = obj.userData?.状态 || '未知';
      const currentWeight = obj.userData?.当前重量_t || 0;
      const plateNumber = obj.userData?.车牌号 || '';
      
      // 状态颜色
      let statusColor = '#666';
      if (status === '称重中') statusColor = '#FF5722';
      else if (status === '有车') statusColor = '#FF9800';
      else if (status === '空闲') statusColor = '#4CAF50';
      
      const vehicleType = obj.userData?.车辆类型 || '';
      const arrivalTime = obj.userData?.到达时间 || '';
      
      let vehicleInfo = '';
      if ((status === '称重中' || status === '有车') && plateNumber) {
        vehicleInfo = `
          <div style="border-top: 1px solid #ccc; margin-top: 4px; padding-top: 4px;">
            <div><b>🚛 车辆信息</b></div>
            <div>车牌号: <span style="color: #1976D2; font-weight: bold;">${plateNumber}</span></div>
            <div>重量: <span style="color: #FF5722; font-weight: bold;">${currentWeight} 吨</span></div>
            ${vehicleType ? `<div>类型: ${vehicleType}</div>` : ''}
            ${arrivalTime ? `<div>时间: ${arrivalTime}</div>` : ''}
          </div>
        `;
      }
      
      infoPanel.innerHTML = `
        <div><b>地磅 ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>状态: <span style="color: ${statusColor}; font-weight: bold;">${status}</span></div>
        ${vehicleInfo}
      `;
    } else if (type === '星仓') {
      // 星仓悬停信息
      const cap = obj.userData?.最大容量_t || '-';
      const current = obj.userData?.当前储量_t || '0';
      const materials = obj.userData?.物料详情 || [];
      const arms = obj.userData?.星角数 || 5;
      const specialMark = obj.userData?.特殊标识;
      
      let materialInfo = '';
      if (materials.length > 0) {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px;">';
        materials.forEach(m => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          materialInfo += `<div style="margin: 2px 0; display: flex; align-items: center;">
            <div style="width: 10px; height: 10px; background: ${companyColor}; border-radius: 2px; margin-right: 6px; border: 1px solid #ccc;"></div>
            <span style="color: ${companyColor}; font-weight: bold;">${m.company}: <span style="${amountStyle}">${negativeIcon}${m.amount}吨</span> ${m.material}</span>
          </div>`;
        });
        materialInfo += '</div>';
      } else {
        // 当没有物料数据时显示空仓状态
        materialInfo = '<div style="margin-top: 6px; font-size: 12px; color: #888;">暂无物料数据</div>';
      }
      
      // 添加星仓特有信息
      let specialInfo = '';
      if (specialMark) {
        specialInfo = `<div style="margin-top: 4px; font-size: 11px; color: #ff6b35; font-weight: bold;">⭐ ${specialMark}</div>`;
      }
      
      infoPanel.innerHTML = `
        <div><b>⭐ 星仓 ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>容量: ${cap} 吨</div>
        <div>当前: ${current} 吨</div>
        <div>星角: ${arms}角</div>
        ${specialInfo}
        ${materialInfo}
      `;
    } else {
      // 平仓悬停信息
      const v = obj.userData?.体积_m3;
      const cap = obj.userData?.最大容量_t || '-';
      const current = obj.userData?.当前储量_t || '0';
      const materials = obj.userData?.物料详情 || [];
      
      let materialInfo = '';
      if (materials.length > 0) {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px;">';
        materials.forEach(m => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          materialInfo += `<div style="margin: 2px 0; display: flex; align-items: center;">
            <div style="width: 10px; height: 10px; background: ${companyColor}; border-radius: 2px; margin-right: 6px; border: 1px solid #ccc;"></div>
            <span style="color: ${companyColor}; font-weight: bold;">${m.company}: <span style="${amountStyle}">${negativeIcon}${m.amount}吨</span> ${m.material}</span>
          </div>`;
        });
        materialInfo += '</div>';
      } else {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px; color: #888;">暂无物料数据</div>';
      }
      
      infoPanel.innerHTML = `
        <div><b>平仓 ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>体积: ${v} m³</div>
        <div>容量: ${cap} 吨</div>
        <div>当前: ${current} 吨</div>
        ${materialInfo}
      `;
    }

    infoPanel.style.display = 'block';
    infoPanel.style.left = (clientX + 14) + 'px';
    infoPanel.style.top = (clientY + 14) + 'px';
  }

  function hideHoverInfo() {
    infoPanel.style.display = 'none';
  }

  // 数字解析：去掉空格/单位，只留数字和小数点、负号
function toNumber(v) {
  if (v == null) return NaN;
  if (typeof v === 'number') return v;
  return parseFloat(String(v).replace(/[^\d.\-]/g, ''));
}

// 是否有有效物料（绝对值 > 0）
function hasActiveMaterials(materialDetails) {
  if (!Array.isArray(materialDetails)) return false;
  return materialDetails.some(item => Number.isFinite(toNumber(item?.amount)) && Math.abs(toNumber(item.amount)) > 1e-6);
}


function setStackColor(obj, color) {
    if (!obj) return;

    const type = obj.userData?.type;
    const isCylindricalSilo = type === '筒仓';
    const isStarSilo = type === '星仓';
    const isSilo = isCylindricalSilo || isStarSilo;
    const hasMaterialData = obj.userData?.hasMaterialData === true;

    let targetColor = color;
    if (isSilo && !hasMaterialData) {
      const looksLikeCompanyTint =
        color === lineColors.silo ||
        color === lineColors.siloOwnerJF;
      if (looksLikeCompanyTint) {
        targetColor = emptySiloColor;
      }
    }

    if (isSilo) {
      // 为筒仓设置颜色 - 同步主体与线框材质
      const isClickable = hasMaterialData; // 有物料数据的筒仓可以点击
      
      obj.children.forEach(child => {
        if (!child.material) return;
        
        // 检查是否是屋顶
        const isRoof = child.userData?.isRoof === true;
        
        if (child.material.type === 'LineBasicMaterial') {
          child.material.color.set(targetColor);
        } else if (child.material.type === 'MeshStandardMaterial') {
          if (isRoof) {
            // 屋顶颜色逻辑：可点击的为绿色，不可点击的为深灰色
            const roofColor = isClickable ? 0x33bb33 : 0xd7d7d7;
            child.material.color.set(roofColor);
          } else {
            // 非屋顶部分使用目标颜色
            child.material.color.set(targetColor);
          }
        }
      });
    } else if (obj.material) {
      // 为平仓设置颜色
      obj.material.color.set(targetColor);
    }
  }

function getStackBaseColor(obj) {
    const type = obj?.userData?.type;
    const owner = obj?.userData?.owner;
    const showCompanyColor = obj?.userData?.hasMaterialData === true;
    const isCylindricalSilo = type === '筒仓';
    const isStarSilo = type === '星仓';
    const isFlat = type === '平仓';
    const hasNumber = obj?.userData?.编号 && obj?.userData?.编号 !== '未分配';

    if (isCylindricalSilo) {
      if (!hasNumber) {
        return noNumberSiloColor; // 没有编号的筒仓使用红色
      }
      if (!showCompanyColor) {
        return emptySiloColor;
      }
      return owner === 'JF' ? lineColors.siloOwnerJF : lineColors.silo;
    }
    
    if (isStarSilo) {
      return getStarSiloBaseColor(obj);
    }
    
    if (isFlat) {
      // 平仓颜色逻辑：有数据显示绿色，无数据显示灰色
      if (!showCompanyColor) {
        return lineColors.stack;
      }
      return lineColors.ownerJF; // 有数据的平仓统一显示绿色
    }
    
    // 其他类型的堆垛
    if (!showCompanyColor) {
      return lineColors.stack;
    }
    return lineColors.ownerJF;
  }

function getSiloHoverColor(obj) {
    const type = obj?.userData?.type;
    return lineColors.siloHover;
  }

function getSiloSelectedColor(obj) {
    const type = obj?.userData?.type;
    return lineColors.siloSelected;
  }

  // 星仓颜色处理函数
  function getStarSiloBaseColor(obj) {
    const owner = obj?.userData?.owner;
    const showCompanyColor = obj?.userData?.hasMaterialData === true;
    
    if (!showCompanyColor) {
      return emptySiloColor; // 没有物料数据时使用空仓颜色
    }
    return owner === 'JF' ? lineColors.starSiloOwnerJF : lineColors.starSilo;
  }

  function getStarSiloHoverColor(obj) {
    return lineColors.starSiloHover;
  }

  function getStarSiloSelectedColor(obj) {
    return lineColors.starSiloSelected;
  }

  function clearHover() {
    if (hovered && hovered !== selected) {
      const hoveredType = hovered.userData?.type;
      if (hoveredType === '地磅') {
        setWeighbridgeColor(hovered, getWeighbridgeBaseColor(hovered));
      } else {
        setStackColor(hovered, getStackBaseColor(hovered));
      }
    }
    hovered = null;
    hideHoverInfo();
  }

  function layoutInfoPanels() {
    const gap = 12;
    const detailShown = detailPanel.style.display !== 'none';
    const whShown = whPanel.style.display !== 'none';
    detailPanel.style.bottom = '16px';
    whPanel.style.bottom = '16px';
    if (detailShown && whShown) {
      const h = detailPanel.offsetHeight || detailPanel.getBoundingClientRect().height || 0;
      whPanel.style.bottom = (16 + h + gap) + 'px';
    }
  }

  function updateActionBar() {
    if (selected) {
      actionBar.classList.add('show'); // 移除权限检查，选中任何对象都显示操作按钮
    } else {
      actionBar.classList.remove('show');
    }
  }

  function updateDetailPanel() {
    if (!selected) {
      detailPanel.style.display = 'none';
      updateActionBar();
      return;
    }
    const wp = new THREE.Vector3();
    selected.getWorldPosition(wp);
    const ud = selected.userData || {};

    if (ud.type === '筒仓') {
      const typeLabel = '筒仓详情';
      const materials = ud.物料详情 || [];
      
      
      let materialsHtml = '';
      if (materials.length > 0) {
        materialsHtml = '<div style="margin-top: 8px;"><b>物料详情:</b></div>';
        materials.forEach((m, index) => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          const negativeLabel = isNegative ? ' (出库)' : '';
          materialsHtml += `
            <div style="background: #f8f9fa; padding: 6px; margin: 4px 0; border-radius: 4px; border-left: 3px solid ${companyColor};">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <div style="width: 12px; height: 12px; background: ${companyColor}; border-radius: 2px; margin-right: 8px; border: 1px solid #ccc;"></div>
                <span style="font-weight: bold; color: ${companyColor};">${m.company}${negativeLabel}</span>
              </div>
              <div style="font-size: 13px;">物料: ${m.material} | 数量: <span style="${amountStyle}">${negativeIcon}${m.amount} 吨</span></div>
              <div style="font-size: 12px; color: #666;">入仓时间: ${m.storageDate}</div>
            </div>
          `;
        });
      } else {
        materialsHtml = '<div style="margin-top: 8px; color: #888;">暂无物料</div>';
      }
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">${typeLabel} ${ud.编号 || '#' + ud.id}</div>
        ${ud.特殊标识 ? `<div style="color: #FFD700; font-weight: bold; text-align: center; margin-bottom: 6px;">${ud.特殊标识}</div>` : ''}        <div>半径: ${ud.半径_m} 米</div>
        <div>高度: ${ud.高度_m} 米</div>
        <div>容积: ${ud.容积_m3} m³</div>
        <div>最大容量: ${ud.最大容量_t} 吨</div>
        <div>当前储量: ${ud.当前储量_t || '-'} 吨</div>
        <div>仓内温度: ${ud.仓内温度_c || '-'} ℃</div>
        <div>仓内湿度: ${ud.仓内湿度_percent || '-'}%</div>
        ${materialsHtml}
      `;
    } else if (ud.type === '地磅') {
      // 处理地磅详情
      let vehicleDetailsHtml = '';
      if ((ud.状态 === '称重中' || ud.状态 === '有车') && ud.车牌号) {
        // 显示车辆图片（如果有）
        let vehicleImagesHtml = '';
        if (ud.frontimg || ud.backimg || ud.wholeimg) {
          vehicleImagesHtml = '<div style="margin-top: 8px;"><b>车辆图片:</b><div style="display: flex; gap: 4px; margin-top: 4px;">';
          if (ud.frontimg) {
            vehicleImagesHtml += `<a href="${ud.frontimg}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px;">前视图</a>`;
          }
          if (ud.backimg) {
            vehicleImagesHtml += `<a href="${ud.backimg}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px;">后视图</a>`;
          }
          if (ud.wholeimg) {
            vehicleImagesHtml += `<a href="${ud.wholeimg}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px;">全景图</a>`;
          }
          vehicleImagesHtml += '</div></div>';
        }
        
        vehicleDetailsHtml = `
          <div style="margin-top: 12px; padding: 8px; background: #f5f5f5; border-radius: 4px;">
            <div style="font-weight: 600; margin-bottom: 4px; color: #2196F3;">🚛 当前车辆信息</div>
            <div>车牌号: <span style="font-weight: bold; color: #1976D2;">${ud.车牌号}</span></div>
            <div>车辆类型: ${ud.车辆类型}</div>
            <div>当前重量: <span style="font-weight: bold; color: #FF5722;">${ud.当前重量_t} 吨</span></div>
            ${ud.correctPonderation ? `<div>纠正重量: <span style="font-weight: bold; color: #4CAF50;">${ud.correctPonderation} 吨</span></div>` : ''}
            <div>过磅时间: ${ud.到达时间}</div>
            ${ud.driver ? `<div>司机: ${ud.driver}</div>` : ''}
            ${ud.warehouseName ? `<div>库区: ${ud.warehouseName}</div>` : ''}
            ${ud.createTime ? `<div>记录时间: ${ud.createTime}</div>` : ''}
            ${vehicleImagesHtml}
          </div>
        `;
      }
      
      // 数据来源信息
      let dataSourceHtml = '';
      if (ud.数据来源) {
        const sourceColor = ud.数据来源 === 'production-api' ? '#4CAF50' : 
                           ud.数据来源 === 'api-not-found' ? '#FF9800' : '#9E9E9E';
        const sourceText = ud.数据来源 === 'production-api' ? '接口数据' : 
                          ud.数据来源 === 'api-not-found' ? '接口无数据' : '默认数据';
        dataSourceHtml = `
          <div style="margin-top: 8px; padding: 6px; background: #f9f9f9; border-radius: 4px; border-left: 3px solid ${sourceColor};">
            <div style="font-size: 12px; color: #666;">数据来源: <span style="color: ${sourceColor}; font-weight: bold;">${sourceText}</span></div>
            ${ud.更新时间 ? `<div style="font-size: 11px; color: #999;">更新时间: ${new Date(ud.更新时间).toLocaleString()}</div>` : ''}
          </div>
        `;
      }

      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">地磅详情 ${ud.编号 || '#' + ud.id}</div>
        <div>状态: <span style="color: ${ud.状态 === '称重中' ? '#FF5722' : '#4CAF50'}; font-weight: bold;">${ud.状态}</span></div>
        ${vehicleDetailsHtml}
        ${dataSourceHtml}
      `;
    } else if (ud.type === '星仓') {
      // 处理星仓详情
      const typeLabel = '⭐ 星仓详情';
      const materials = ud.物料详情 || [];
      
      let materialsHtml = '';
      if (materials.length > 0) {
        materialsHtml = '<div style="margin-top: 8px;"><b>物料详情:</b></div>';
        materials.forEach((m, index) => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          const negativeLabel = isNegative ? ' (出库)' : '';
          materialsHtml += `
            <div style="background: #fff8e1; padding: 6px; margin: 4px 0; border-radius: 4px; border-left: 3px solid ${companyColor};">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <div style="width: 12px; height: 12px; background: ${companyColor}; border-radius: 2px; margin-right: 8px; border: 1px solid #ccc;"></div>
                <span style="font-weight: bold; color: ${companyColor};">${m.company}${negativeLabel}</span>
              </div>
              <div style="font-size: 13px;">物料: ${m.material} | 数量: <span style="${amountStyle}">${negativeIcon}${m.amount} 吨</span></div>
              <div style="font-size: 12px; color: #666;">入仓时间: ${m.storageDate}</div>
            </div>
          `;
        });
      } else {
        materialsHtml = '<div style="margin-top: 8px; color: #888;">暂无物料</div>';
      }
      
      // 数据来源信息
      let dataSourceHtml = '';
      if (ud.数据来源 && ud.更新时间) {
        dataSourceHtml = `
          <div style="margin-top: 8px; padding: 4px; background: #f0f0f0; border-radius: 4px; font-size: 11px; color: #666;">
            数据来源: ${ud.数据来源} | 更新时间: ${ud.更新时间}
          </div>
        `;
      }
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">${typeLabel} ${ud.编号 || '#' + ud.id}</div>
        ${ud.特殊标识 ? `<div style="color: #ff6b35; font-weight: bold; text-align: center; margin-bottom: 6px; background: #fff3e0; padding: 4px; border-radius: 4px;">⭐ ${ud.特殊标识}</div>` : ''}
        <div>半径: ${ud.半径_m} 米</div>
        <div>高度: ${ud.高度_m} 米</div>
        <div>星角数: ${ud.星角数 || 5} 角</div>
        <div>容积: ${ud.容积_m3} m³</div>
        <div>最大容量: ${ud.最大容量_t} 吨</div>
        <div>当前储量: ${ud.当前储量_t || '-'} 吨</div>
        <div>仓内温度: ${ud.仓内温度_c || '-'} ℃</div>
        <div>仓内湿度: ${ud.仓内湿度_percent || '-'}%</div>
        ${materialsHtml}
        ${dataSourceHtml}
      `;
    } else {
      // 处理平仓详情
      const materials = ud.物料详情 || [];
      
      let materialsHtml = '';
      if (materials.length > 0) {
        materialsHtml = '<div style="margin-top: 8px;"><b>物料详情:</b></div>';
        materials.forEach((m, index) => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          const negativeLabel = isNegative ? ' (出库)' : '';
          materialsHtml += `
            <div style="background: #f8f9fa; padding: 6px; margin: 4px 0; border-radius: 4px; border-left: 3px solid ${companyColor};">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <div style="width: 12px; height: 12px; background: ${companyColor}; border-radius: 2px; margin-right: 8px; border: 1px solid #ccc;"></div>
                <span style="font-weight: bold; color: ${companyColor};">${m.company}${negativeLabel}</span>
              </div>
              <div style="font-size: 13px;">物料: ${m.material} | 数量: <span style="${amountStyle}">${negativeIcon}${m.amount} 吨</span></div>
              <div style="font-size: 12px; color: #666;">入仓时间: ${m.storageDate}</div>
            </div>
          `;
        });
      } else {
        materialsHtml = '<div style="margin-top: 8px; color: #888;">暂无物料</div>';
      }
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">详情 #${ud.编号 || ud.id}</div>
        <div>最大堆叠体积: ${ud.体积_m3} m³</div>
        <div>最大堆叠尺寸: ${ud.尺寸_m}</div>
        <div>最大容量: ${ud.最大容量_t || '-'} 吨</div>
        <div>当前储量: ${ud.当前储量_t || '-'} 吨</div>
        ${materialsHtml}
      `;
    }

    detailPanel.style.display = 'block';
    layoutInfoPanels();
    updateActionBar();
  }

  function handlePointerMove(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    // 对所有可交互对象进行射线检测，获取所有相交点
    const allHits = raycaster.intersectObjects(raycastTargets, true);
    let target = null;

    // 只考虑最近的第一个交互对象，避免穿透空筒仓命中后方目标
    if (allHits.length > 0) {
      target = resolveInteractiveTarget(allHits[0].object);
      if (!target && allHits.length > 0) {
      }
    }
    if (target) {
      if (hovered !== target) {
        if (hovered && hovered !== selected) setStackColor(hovered, getStackBaseColor(hovered));
        hovered = target;
      }
      if (hovered !== selected) {
        const hoveredType = hovered.userData?.type;
        let hoverColor;
        if (hoveredType === '筒仓') {
          hoverColor = getSiloHoverColor(hovered);
        } else if (hoveredType === '星仓') {
          hoverColor = getStarSiloHoverColor(hovered);
        } else if (hoveredType === '地磅') {
          hoverColor = lineColors.weighbridgeHover;
        } else {
          hoverColor = lineColors.hover;
        }
        
        if (hoveredType === '地磅') {
          setWeighbridgeColor(hovered, hoverColor);
        } else {
          setStackColor(hovered, hoverColor);
        }
      }
      showHoverInfo(target, e.clientX, e.clientY);
    } else {
      clearHover();
    }
  }

  function handleClickOnTarget(e, targetObject) {
    // 新的更可靠的点击处理函数
    if (!targetObject) {
      return;
    }
    
    // 如果点击的是已选中的对象，则取消选择
    if (selected === targetObject) {
      clearSelection();
      return;
    }
    
    // 清除之前的选择状态
    if (selected) {
      const selectedType = selected.userData?.type;
      if (selectedType === '地磅') {
        setWeighbridgeColor(selected, getWeighbridgeBaseColor(selected));
      } else {
        setStackColor(selected, getStackBaseColor(selected));
      }
    }
    
    // 设置新的选择对象
    selected = targetObject;
    const selectedType = selected.userData?.type;
    let selectedColor;
    
    if (selectedType === '筒仓') {
      selectedColor = getSiloSelectedColor(selected);
    } else if (selectedType === '星仓') {
      selectedColor = getStarSiloSelectedColor(selected);
    } else if (selectedType === '地磅') {
      selectedColor = lineColors.weighbridgeSelected;
    } else if (selectedType === '平仓') {
      // 平仓选中时显示红色
      selectedColor = lineColors.selected;
    } else {
      selectedColor = lineColors.selected;
    }
    
    // 应用选中颜色
    if (selectedType === '地磅') {
      setWeighbridgeColor(selected, selectedColor);
    } else {
      setStackColor(selected, selectedColor);
    }
    
    updateDetailPanel();
    
    // 检查选中的对象类型，只有仓库本身才显示仓库信息，堆垛不显示
    const isWarehouse = selectedType === '仓库';
    const info = selected.userData?.whInfo;
    
    if (info && isWarehouse) {
      whPanel.innerHTML = `
          <div style="font-weight:600;margin-bottom:6px;">仓库 ${info.id}</div>
          <div>面积: ${info.area} m²</div>
          <div>仓内温度: ${info.temperature} ℃</div>
          <div>增值作业: ${info.services.join('、')}</div>
          <div>当日值勤: ${info.phone}</div>
        `;
      whPanel.style.display = 'block';
      layoutInfoPanels();
    } else {
      whPanel.style.display = 'none';
    }
    updateActionBar();
  }

  function handleClick(e) {
    // 保留原handleClick函数以兼容其他可能的调用
    // 事件冒泡已在调用此函数前被阻止，这里不需要再次处理
    
    if (!hovered) {
      return; // 移除权限检查，只要有悬停对象就可以点击
    }
    
    // 使用新的handleClickOnTarget函数处理点击
    handleClickOnTarget(e, hovered);
  }

  renderer.domElement.addEventListener('mousemove', handlePointerMove);
  renderer.domElement.addEventListener('mouseleave', clearHover);
  // 统一的点击处理函数，避免多重事件监听器导致的冒泡问题
  renderer.domElement.addEventListener('click', (ev) => {
    // 阻止事件冒泡和默认行为
    ev.stopPropagation();
    ev.preventDefault();
    
    // 重新计算鼠标位置和射线检测，确保点击时的精确性
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    // 重新进行射线检测以确保获得最新的交互目标
    const allHits = raycaster.intersectObjects(raycastTargets, true);
    let clickTarget = null;
    
    if (allHits.length > 0) {
      clickTarget = resolveInteractiveTarget(allHits[0].object);
    }
    
    // 处理对象选择逻辑 - 使用点击时重新检测到的目标
    if (clickTarget || hovered) {
      // 优先使用点击时检测到的目标，如果没有则使用悬停目标
      const targetToSelect = clickTarget || hovered;
      handleClickOnTarget(ev, targetToSelect);
    } else {
      clearSelection();
    }
    
  });

  function clearSelection() {
    if (!selected) {
      updateActionBar();
      return;
    }
    const selectedType = selected.userData?.type;
    if (selectedType === '地磅') {
      setWeighbridgeColor(selected, getWeighbridgeBaseColor(selected));
    } else {
      setStackColor(selected, getStackBaseColor(selected));
    }
    selected = null;
    updateDetailPanel();
    updateActionBar();
    whPanel.style.display = 'none';
  }

  btnLfs.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '平仓';
    alert(`查看LFS订单：${type} #${id}`);
  });
  btnTms.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '平仓';
    alert(`查看相关TMS运输订单：${type} #${id}`);
  });
  btnFee.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '平仓';
    let feeType;
    if (type === '筒仓') {
      feeType = '筒仓仓储费用';
    } else if (type === '地磅') {
      feeType = '地磅使用费用';
    } else {
      feeType = '平仓仓储费用';
    }
    alert(`查看${feeType}：${type} #${id}`);
  });

  // 监控按钮事件监听
  btnMonitor.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const userData = selected.userData;
    const type = userData?.type;
    
    // 只有筒仓才有监控功能
    if (type === '筒仓') {
      showMonitorPanel(userData);
    } else {
      alert('只有筒仓支持监控查看功能');
    }
  });

  // 监控面板控制按钮事件监听
  monitorClose.addEventListener('click', closeMonitorPanel);

  playBtn.addEventListener('click', () => {
    if (flvPlayer && monitorVideo.paused) {
      flvPlayer.play().catch(e => {
      });
    }
  });

  pauseBtn.addEventListener('click', () => {
    if (flvPlayer && !monitorVideo.paused) {
      flvPlayer.pause();
    }
  });

  fullscreenBtn.addEventListener('click', () => {
    if (monitorVideo.requestFullscreen) {
      monitorVideo.requestFullscreen();
    } else if (monitorVideo.webkitRequestFullscreen) {
      monitorVideo.webkitRequestFullscreen();
    } else if (monitorVideo.msRequestFullscreen) {
      monitorVideo.msRequestFullscreen();
    }
  });

  // 点击面板外部关闭监控面板
  document.addEventListener('click', (e) => {
    if (monitorPanel.style.display === 'block' && 
        !monitorPanel.contains(e.target) && 
        e.target !== btnMonitor) {
      closeMonitorPanel();
    }
  });

  function onResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    labelRenderer.setSize(w, h);


    layoutInfoPanels();
  }

  window.addEventListener('resize', onResize);

  controls.addEventListener('change', () => {
    updateCompass();
  });

  // 车辆3D模型构建函数
  function buildVehicle(type = 'truck') {
    const vehicleGroup = new THREE.Group();
    
    if (type === 'truck') {
      // 卡车车身
      const bodyGeometry = new THREE.BoxGeometry(8, 2.5, 2.2);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 1.25, 0);
      vehicleGroup.add(body);
      
      // 驾驶室
      const cabGeometry = new THREE.BoxGeometry(2.5, 2.8, 2.2);
      const cabMaterial = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
      const cab = new THREE.Mesh(cabGeometry, cabMaterial);
      cab.position.set(-4.75, 1.4, 0);
      vehicleGroup.add(cab);
      
      // 车轮
      const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.3, 12);
      const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
      
      const wheelPositions = [
        [-3.5, 0.6, -1.2], [-3.5, 0.6, 1.2], // 前轮
        [1.5, 0.6, -1.2], [1.5, 0.6, 1.2],   // 后轮1
        [3.5, 0.6, -1.2], [3.5, 0.6, 1.2]    // 后轮2
      ];
      
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.position.set(pos[0], pos[1], pos[2]);
        wheel.rotation.z = Math.PI / 2;
        vehicleGroup.add(wheel);
      });
      
    } else if (type === 'car') {
      // 小轿车车身
      const bodyGeometry = new THREE.BoxGeometry(4.5, 1.5, 1.8);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6347 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.75, 0);
      vehicleGroup.add(body);
      
      // 车顶
      const roofGeometry = new THREE.BoxGeometry(3, 1.2, 1.6);
      const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xDC143C });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.set(-0.3, 1.6, 0);
      vehicleGroup.add(roof);
      
      // 车轮
      const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 12);
      const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
      
      const wheelPositions = [
        [-1.5, 0.4, -1], [-1.5, 0.4, 1], // 前轮
        [1.5, 0.4, -1], [1.5, 0.4, 1]    // 后轮
      ];
      
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.position.set(pos[0], pos[1], pos[2]);
        wheel.rotation.z = Math.PI / 2;
        vehicleGroup.add(wheel);
      });
    }
    
    return vehicleGroup;
  }

  // 地磅构建函数
  function buildWeighbridge(length = 50, width = 58, height = 0.3) {
    const group = new THREE.Group();
    
    // 地磅平台
    const platformGeo = new THREE.BoxGeometry(length, height, width);
    const platformMat = new THREE.MeshStandardMaterial({
      color: 0x4A4A4A,
      roughness: 0.8,
      metalness: 0.2
    });
    const platform = new THREE.Mesh(platformGeo, platformMat);
    platform.position.y = height / 2;
    platform.castShadow = true;
    platform.receiveShadow = true;
    group.add(platform);
    
    // 地磅边框线框
    const platformWireframe = createWireframe(platformGeo, 0x333333);
    platformWireframe.position.y = height / 2;
    group.add(platformWireframe);
    
    // 称重传感器支撑（4个角）
    const sensorGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8);
    const sensorMat = new THREE.MeshStandardMaterial({
      color: 0x666666,
      roughness: 0.7,
      metalness: 0.3
    });
    
    const sensorPositions = [
      [-length/2 + 2, -0.4, -width/2 + 0.5],
      [length/2 - 2, -0.4, -width/2 + 0.5],
      [-length/2 + 2, -0.4, width/2 - 0.5],
      [length/2 - 2, -0.4, width/2 - 0.5]
    ];
    
    sensorPositions.forEach(pos => {
      const sensor = new THREE.Mesh(sensorGeo, sensorMat);
      sensor.position.set(pos[0], pos[1], pos[2]);
      sensor.castShadow = true;
      group.add(sensor);
    });
    
    // 控制箱
    const controlBoxGeo = new THREE.BoxGeometry(1.2, 1.5, 0.8);
    const controlBoxMat = new THREE.MeshStandardMaterial({
      color: 0x2E7D32,
      roughness: 0.6,
      metalness: 0.1
    });
    const controlBox = new THREE.Mesh(controlBoxGeo, controlBoxMat);
    controlBox.position.set(length/2 + 2, 0.75, 0);
    controlBox.castShadow = true;
    group.add(controlBox);
    
    // 控制箱线框
    const controlBoxWireframe = createWireframe(controlBoxGeo, 0x1B5E20);
    controlBoxWireframe.position.set(length/2 + 2, 0.75, 0);
    group.add(controlBoxWireframe);
    
    return group;
  }

  // 筒仓构建函数
  function buildSiloWireframe(radius, height, radialSegments = 24) {
    const cyl = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 1, false);
    const edges = new THREE.EdgesGeometry(cyl);
    const mat = new THREE.LineBasicMaterial({color: lineColors.silo});
    const mesh = new THREE.LineSegments(edges, mat);
    mesh.position.y = height / 2;
    return mesh;
  }

  function buildSiloMesh(radius, height, materials = [], radialSegments = 32) {
    const group = new THREE.Group();

    // 如果没有物料数据，创建空筒仓
    if (!materials || materials.length === 0) {
      const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 8, false);
      const mat = new THREE.MeshStandardMaterial({
        color: emptySiloColor,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = height / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);
      return group;
    }

    // 分离正数和负数物料，3D模型只显示正数物料
    const positiveMaterials = materials.filter(m => parseFloat(m.amount) > 0);
    
    // 如果没有正数物料，显示为空仓
    if (positiveMaterials.length === 0) {
      const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 8, false);
      const mat = new THREE.MeshStandardMaterial({
        color: emptySiloColor,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = height / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);
      return group;
    }
    
    const totalAmount = positiveMaterials.reduce((sum, m) => sum + parseFloat(m.amount), 0);
    let currentY = 0;

    // 为每个公司的正数物料创建分段
    positiveMaterials.forEach((material, index) => {
      const proportion = parseFloat(material.amount) / totalAmount;
      const segmentHeight = height * proportion * 0.8; // 0.8是填充率
      
      if (segmentHeight > 0.1) { // 只显示足够高的分段
        const geo = new THREE.CylinderGeometry(radius, radius, segmentHeight, radialSegments, 1, false);
        const colorData = parseColor(material.companyColor);
        const companyColor = colorData.hex || emptySiloColor;
        
        const mat = new THREE.MeshStandardMaterial({
          color: companyColor,
          roughness: 0.9,
          metalness: 0.05,
          flatShading: false
        });
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = currentY + segmentHeight / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = {
          company: material.company,
          material: material.material,
          amount: material.amount
        };
        
        group.add(mesh);
        currentY += segmentHeight;
      }
    });

    // 如果有剩余空间，添加空的顶部分段
    if (currentY < height) {
      const emptyHeight = height - currentY;
      const geo = new THREE.CylinderGeometry(radius, radius, emptyHeight, radialSegments, 1, false);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xF0F0F0, // 浅灰色表示空仓
        roughness: 0.95,
        metalness: 0.02,
        flatShading: false,
        transparent: true,
        opacity: 0.3
      });
      
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = currentY + emptyHeight / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { isEmpty: true };
      
      group.add(mesh);
    }

    return group;
  }

  function buildSiloRoof(radius, height = 3) {
    const geo = new THREE.ConeGeometry(radius * 1.05, height, 24);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xD0D0D0, // 更亮的灰色，避免看起来太黑
      roughness: 0.6,
      metalness: 0.2
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    mesh.receiveShadow = true; // 添加接受阴影，让光照更自然
    mesh.userData = { isRoof: true }; // 标识这是屋顶
    return mesh;
  }

  function buildSiloLadder(radius, height) {
    const points = [];
    const turns = height / 15;
    const segments = Math.ceil(turns * 32);

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const angle = t * turns * Math.PI * 2;
      const y = t * height;
      const x = Math.cos(angle) * (radius + 0.3);
      const z = Math.sin(angle) * (radius + 0.3);
      points.push(new THREE.Vector3(x, y, z));
    }

    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 2 });
    return new THREE.Line(geo, mat);
  }

  function buildConnectingBridge(x1, z1, x2, z2, height) {
    const dx = x2 - x1;
    const dz = z2 - z1;
    const len = Math.sqrt(dx * dx + dz * dz);
    const angle = Math.atan2(dz, dx);

    const geo = new THREE.CylinderGeometry(0.4, 0.4, len, 8);
    const mat = new THREE.MeshStandardMaterial({
      color: 0x808080,
      roughness: 0.6,
      metalness: 0.4
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.z = Math.PI / 2;
    mesh.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
    mesh.rotation.y = angle;
    return mesh;
  }

  let siloIdSeq = 1;
  
  
  // 筒仓编号映射表 - 按照实际创建顺序排列
  const siloNumberMap = {
    // 所有筒仓编号 - 按照 rowGroupCounts: [1, 1, 1, 1] 的实际创建顺序
    // 共4排，每排1组，每组2个筒仓（从东到西排列）
    silo: [
      // 第1排（最北侧）- 2个筒仓从东到西
      ['05', '01'],
      // 第2排 - 2个筒仓从东到西
      ['06', '02'],
      // 第3排 - 2个筒仓从东到西
      ['07', '03'],
      // 第4排（最南侧）- 2个筒仓从东到西
      ['08', '04']
    ],
    // 星仓编号 - 按照地理位置从西到东、从北到南排列（共20个）
    starSilo: [
      // 第1排（最北侧）：4个星仓，从西到东
      ['X501', 'X502', 'X503', 'X504'],
      // 第2排：4个星仓，从西到东
      ['X401', 'X402', 'X403', 'X404'],
      // 第3排：4个星仓，从西到东
      ['X301', 'X302', 'X303', 'X304'],
      // 第4排：4个星仓，从西到东
      ['X201', 'X202', 'X203', 'X204'],
      // 第5排（最南侧）：4个星仓，从西到东
      ['X101', 'X102', 'X103', 'X104']
    ]
  };



  
  // 筒仓编号计数器
  let siloRowIndex = 0;
  let siloColIndex = 0;
  
  // 星仓编号计数器 - 全局声明
  let starSiloRowIndex = 0;
  let starSiloColIndex = 0;


  async function placeSilo(x, z, radius, height, addDetails = true) {
    const group = new THREE.Group();

    // 计算基本参数
    const volume = Math.PI * radius * radius * height;
    const capacity = (volume * 0.75).toFixed(1); // 假设密度0.75吨/立方米
    
    // 使用新的编号系统
    let siloNumber;
    if (siloRowIndex < siloNumberMap.silo.length && siloColIndex < siloNumberMap.silo[siloRowIndex].length) {
      siloNumber = siloNumberMap.silo[siloRowIndex][siloColIndex];
      siloColIndex++;
      if (siloColIndex >= siloNumberMap.silo[siloRowIndex].length) {
        siloColIndex = 0;
        siloRowIndex++;
      }
    } else {
      siloNumber = null; // 不分配编号，表示接口中没有对应数据
    }
    const siloId = siloIdSeq++;

    // 通过接口获取筒仓和物料数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: siloId,
        siloNumber: siloNumber, // 传递本地编号用于API数据查找
        siloType: '筒仓',
        radius: radius,
        height: height,
        volume: volume,
        capacity: capacity
      });
    } catch (error) {
      // 使用默认数据继续创建筒仓，避免完全失败
      apiData = {
        siloInfo: {
          id: siloNumber,
          type: '筒仓',
          radius: radius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '离线'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'fallback-default'
      };
    }

    const { siloInfo, materialDetails } = apiData;
    const activeMaterials = Array.isArray(materialDetails)
    ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6): [];
    const hasMaterialData = activeMaterials.length > 0;


    // 只有有物料数据时才传递物料详情，否则传递空数组
    const shell = buildSiloMesh(radius, height, activeMaterials);
    const outline = buildSiloWireframe(radius, height);
    group.add(shell);
    group.add(outline);

    if (addDetails) {
      const roof = buildSiloRoof(radius, 3);
      roof.position.y = height + 1.5;
      group.add(roof);

      const ladder = buildSiloLadder(radius, height);
      group.add(ladder);

      const ventGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
      const ventMat = new THREE.MeshStandardMaterial({ 
        color: 0x888888, // 更亮的灰色
        roughness: 0.7,
        metalness: 0.3
      });
      const vent = new THREE.Mesh(ventGeo, ventMat);
      vent.position.y = height + 3.75;
      group.add(vent);
    }

    // 使用接口返回的数据设置筒仓信息
    group.userData = {
      type: siloInfo.type,
      id: siloInfo.id,
      编号: siloNumber || '未分配', // 使用本地编号，如果没有则显示"未分配"
      owner: hasMaterialData ? siloInfo.owner : undefined,
      半径_m: siloInfo.radius,
      高度_m: siloInfo.height,
      容积_m3: siloInfo.volume,
      最大容量_t: siloInfo.maxCapacity,
      当前储量_t: siloInfo.currentStorage,
      仓内温度_c: siloInfo.temperature,
      仓内湿度_percent: siloInfo.humidity,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    group.position.set(x, 0, z);
    scene.add(group);
    registerPickable(group);

    // 所有筒仓都注册为可交互对象，无论是否有物料数据
    registerInteractive(group);
    
    // 根据编号和物料数据设置颜色
    if (!siloNumber) {
      // 没有编号的筒仓使用红色，表示接口中没有对应数据
      setStackColor(group, noNumberSiloColor);
    } else if (hasMaterialData) {
      // 有编号且有物料数据的筒仓设置正常颜色
      setStackColor(group, getStackBaseColor(group));
    } else {
      // 有编号但无物料数据的筒仓使用灰色
      setStackColor(group, emptySiloColor);
    }

    return group;
  }

  // ================ 星仓创建系统 ================

  // 创建星型轮廓点
  function createStarOutlinePoints(outerRadius, innerRadius, arms = 5) {
    const pts = [];
    const total = arms * 2;
    for (let i = 0; i < total; i++) {
      const angle = (i / total) * Math.PI * 2 - Math.PI / 2;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      pts.push(new THREE.Vector2(Math.cos(angle) * radius, Math.sin(angle) * radius));
    }
    return pts;
  }

  // 计算多边形面积
  function computePolygonArea2D(points) {
    let area = 0;
    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % points.length];
      area += p1.x * p2.y - p2.x * p1.y;
    }
    return Math.abs(area) / 2;
  }

  // 构建星仓主体
  function buildStarSiloBody(outerRadius, innerRadius, height, materials = [], arms = 5) {
    const outline = createStarOutlinePoints(outerRadius, innerRadius, arms);
    const shape = new THREE.Shape();
    shape.moveTo(outline[0].x, outline[0].y);
    for (let i = 1; i < outline.length; i++) {
      shape.lineTo(outline[i].x, outline[i].y);
    }
    shape.closePath();

    const extrude = new THREE.ExtrudeGeometry(shape, {
      steps: 1,
      depth: height,
      bevelEnabled: false
    });
    extrude.rotateX(-Math.PI / 2);
    extrude.translate(0, height / 2, 0);

    // 根据是否有物料决定颜色：空星仓用灰色，有物料用金色
    const hasMaterials = materials && materials.length > 0;
    const bodyColor = hasMaterials ? lineColors.starSilo : emptySiloColor;

    const bodyMat = new THREE.MeshStandardMaterial({
      color: bodyColor,
      roughness: 0.55,
      metalness: 0.25
    });
    const body = new THREE.Mesh(extrude, bodyMat);
    body.castShadow = true;
    body.receiveShadow = true;

    return {body, outline};
  }

  // 放置星仓
  async function placeStarSilo(x, z, height, options = {}) {
    const {
      outerRadius = 3.2,
      innerRadius = outerRadius * 0.55,
      arms = 5,
      densityTPerM3 = 0.75,
      addDetails = true
    } = options;

    // 计算基本参数
    const area = computePolygonArea2D(createStarOutlinePoints(outerRadius, innerRadius, arms));
    const volume = area * height;
    const rawCapacity = volume * densityTPerM3;
    const capacity = rawCapacity.toFixed(1);
    
    // 使用星仓专用编号系统
    let starSiloNumber;
    
    if (starSiloRowIndex < siloNumberMap.starSilo.length && starSiloColIndex < siloNumberMap.starSilo[starSiloRowIndex].length) {
      starSiloNumber = siloNumberMap.starSilo[starSiloRowIndex][starSiloColIndex];
      starSiloColIndex++;
      if (starSiloColIndex >= siloNumberMap.starSilo[starSiloRowIndex].length) {
        starSiloColIndex = 0;
        starSiloRowIndex++;
      }
    } else {
      starSiloNumber = `X${String(siloIdSeq).padStart(3, '0')}`;
    }
    const siloId = siloIdSeq++;

    // 通过接口获取星仓和物料数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: siloId,
        siloNumber: starSiloNumber, // 传递本地编号用于API数据查找
        siloType: '星仓',
        radius: outerRadius,
        height: height,
        volume: volume,
        capacity: capacity
      });
    } catch (error) {
      // 使用默认数据继续创建星仓，避免完全失败
      apiData = {
        siloInfo: {
          id: starSiloNumber,
          type: '星仓',
          radius: outerRadius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '离线'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'fallback-default'
      };
    }

    const { siloInfo: rawSiloInfo = {}, materialDetails = [] } = apiData;
    const siloInfo = {
      ...rawSiloInfo,
      type: '星仓',
      arms: rawSiloInfo?.arms ?? arms
    };
    const activeMaterials = Array.isArray(materialDetails)
    ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6)
    : [];
    const hasMaterialData = activeMaterials.length > 0;

    const group = new THREE.Group();
    // 只有有物料数据时才传递物料详情，否则传递空数组
    const {body, outline} = buildStarSiloBody(outerRadius, innerRadius, height, activeMaterials, arms);
    group.add(body);

    // 为星仓添加线框（简化为轮廓线）
    const outlineGeometry = new THREE.BufferGeometry().setFromPoints([
      ...outline.map(p => new THREE.Vector3(p.x, 0, p.y)),
      new THREE.Vector3(outline[0].x, 0, outline[0].y) // 闭合
    ]);
    const outlineBottom = new THREE.Line(outlineGeometry, new THREE.LineBasicMaterial({color: lineColors.starSilo}));

    const outlineTop = outlineBottom.clone();
    outlineTop.position.y = height;

    group.add(outlineBottom);
    group.add(outlineTop);

    if (addDetails) {
      const capBaseGeo = new THREE.CylinderGeometry(innerRadius * 0.6, innerRadius * 0.6, 1.5, arms * 2);
      const capBaseMat = new THREE.MeshStandardMaterial({
        color: 0xffc75f,
        roughness: 0.45,
        metalness: 0.35
      });
      const capBase = new THREE.Mesh(capBaseGeo, capBaseMat);
      capBase.position.y = height + 0.75;
      capBase.castShadow = true;
      capBase.receiveShadow = true;
      group.add(capBase);

      const spireGeo = new THREE.ConeGeometry(innerRadius * 0.45, 2.2, Math.max(arms * 2, 6));
      const spireMat = new THREE.MeshStandardMaterial({
        color: 0xffe59f,
        roughness: 0.35,
        metalness: 0.3
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.y = height + 2.0;
      spire.castShadow = true;
      group.add(spire);
    }

    // 使用接口返回的数据设置星仓信息
    group.userData = {
      type: '星仓',
      id: starSiloNumber, // 使用本地分配的星仓编号
      编号: starSiloNumber, // 使用本地分配的星仓编号，不使用API返回的编号
      owner: hasMaterialData ? siloInfo.owner : undefined,
      半径_m: siloInfo.radius,
      高度_m: siloInfo.height,
      容积_m3: siloInfo.volume,
      最大容量_t: siloInfo.maxCapacity,
      当前储量_t: siloInfo.currentStorage,
      仓内温度_c: siloInfo.temperature,
      仓内湿度_percent: siloInfo.humidity,
      星角数: siloInfo.arms ?? arms,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加特殊标识
      特殊标识: siloInfo.specialMark,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    group.position.set(x, -36, z); // 星仓放置在地面
    scene.add(group);
    registerPickable(group);

    // 所有星仓都注册为可交互对象，无论是否有物料数据
    registerInteractive(group);
    
    // 根据是否有物料数据设置颜色
    if (hasMaterialData) {
      setStackColor(group, getStackBaseColor(group));
    } else {
      // 确保空星仓使用灰色
      setStackColor(group, emptySiloColor);
    }

    return group;
  }

  // ================ 星仓创建系统结束 ================

  // 地磅状态管理
  const weighbridgeStates = new Map(); // 存储每个地磅的状态
  
  // 根据状态更新地磅颜色
  function updateWeighbridgeColor(weighbridge) {
    if (!weighbridge || !weighbridge.userData) return;
    
    const status = weighbridge.userData.状态;
    let color;
    
    switch (status) {
      case '称重中':
        color = 0xFF5722; // 红色 - 正在称重
        break;
      case '有车':
        color = 0xFF9800; // 橙色 - 有车辆但未称重
        break;
      case '空闲':
        color = 0x4CAF50; // 绿色 - 空闲状态
        break;
      default:
        color = lineColors.weighbridge; // 默认颜色
    }
    
    setWeighbridgeColor(weighbridge, color);
  }
  

  // 更新场景中所有地磅的显示状态
  function updateAllWeighbridgesInScene() {
    // 尝试多种方式获取scene对象
    const sceneRef = scene || window.globalScene;
    
    // 安全检查：确保scene对象存在且有traverse方法
    if (typeof sceneRef === 'undefined' || !sceneRef || typeof sceneRef.traverse !== 'function') {
      // 调试信息已被移除
      return;
    }
    
    if (!globalWeighbridgeData || !globalWeighbridgeData.weighbridgeList) {
      return;
    }
    
    // 如果API返回空数据，清空所有地磅的车辆
    if (globalWeighbridgeData.weighbridgeList.length === 0) {
      
      // 使用已验证的sceneRef对象
      sceneRef.traverse((object) => {
        if (object.userData && object.userData.type === '地磅') {
          const weighbridgeId = object.userData.编号 || object.userData.id;
          const state = weighbridgeStates.get(weighbridgeId);
          
          if (state && state.hasVehicle) {
            removeVehicleFromWeighbridge(object, true); // API驱动的清空
          }
        }
      });
      return;
    }
    
    // 遍历场景中的所有对象，找到地磅并更新
    sceneRef.traverse((object) => {
      if (object.userData && object.userData.type === '地磅') {
        const weighbridgeId = object.userData.编号 || object.userData.id;
        
        // 在API数据中查找对应的地磅数据
        const apiData = globalWeighbridgeData.weighbridgeList.find(wb => 
          wb.weighbridgeInfo.id === weighbridgeId
        );
        
        if (apiData) {
          const { weighbridgeInfo } = apiData;
          
          // 获取地磅状态管理器
          const state = weighbridgeStates.get(weighbridgeId);
          if (!state) {
            return;
          }
          
          // 检查状态变化，决定是否需要添加/移除车辆
          const newStatus = weighbridgeInfo.status || '空闲';
          const hasVehicleInAPI = (newStatus === '称重中' || newStatus === '有车') && weighbridgeInfo.plateNumber;
          
          // 更新地磅的userData
          Object.assign(object.userData, {
            状态: newStatus,
            当前重量_t: weighbridgeInfo.currentWeight || 0,
            车牌号: weighbridgeInfo.plateNumber || '',
            车辆类型: weighbridgeInfo.vehicleType || '',
            到达时间: weighbridgeInfo.arrivalTime || '',
            driver: weighbridgeInfo.driver || '',
            driverid: weighbridgeInfo.driverid || '',
            warehouseName: '钦州侨益仓', // 库区 - 固定传参
            correctPonderation: weighbridgeInfo.correctPonderation || null,
            frontimg: weighbridgeInfo.frontimg || '',
            backimg: weighbridgeInfo.backimg || '',
            wholeimg: weighbridgeInfo.wholeimg || '',
            createTime: weighbridgeInfo.createTime || '',
            recordId: weighbridgeInfo.recordId || '',
            数据来源: 'production-api',
            更新时间: Date.now()
          });
          
          // 根据API数据同步车辆3D模型
          if (hasVehicleInAPI && !state.hasVehicle) {
            // API显示有车，但3D场景中没有车辆 -> 添加车辆
            addVehicleToWeighbridgeFromAPI(object, weighbridgeInfo);
          } else if (!hasVehicleInAPI && state.hasVehicle) {
            // API显示无车，但3D场景中有车辆 -> 移除车辆
            removeVehicleFromWeighbridge(object, true); // API驱动的清空
          } else if (hasVehicleInAPI && state.hasVehicle) {
            // 都有车辆，更新车辆信息
            updateVehicleInfo(state, weighbridgeInfo);
          }
          
          // 更新地磅颜色
          updateWeighbridgeColor(object);
          
        } else {
          // API数据中没有找到对应的地磅数据，清空车辆
          const state = weighbridgeStates.get(weighbridgeId);
          if (state && state.hasVehicle) {
            removeVehicleFromWeighbridge(object, true); // API驱动的清空
          }
        }
      }
    });
  }
  
  // 根据API数据添加车辆到地磅
  function addVehicleToWeighbridgeFromAPI(weighbridge, weighbridgeInfo) {
    const weighbridgeId = weighbridge.userData.编号 || weighbridge.userData.id;
    const state = weighbridgeStates.get(weighbridgeId);
    
    if (state.hasVehicle) {
      return;
    }
    
    // 创建车辆信息对象
    const vehicleInfo = {
      type: weighbridgeInfo.vehicleType === '小轿车' ? 'car' : 'truck',
      plateNumber: weighbridgeInfo.plateNumber || '',
      weight: weighbridgeInfo.currentWeight || 0,
      driver: weighbridgeInfo.driver || '',
      arrivalTime: weighbridgeInfo.arrivalTime || ''
    };
    
    // 创建车辆3D模型
    const vehicleModel = buildVehicle(vehicleInfo.type);
    
    // 设置车辆位置（在地磅上）
    const weighbridgePos = weighbridge.position;
    const weighbridgeRotation = weighbridge.rotation.y;
    
    vehicleModel.position.set(
      weighbridgePos.x,
      weighbridgePos.y + 0.4, // 稍微抬高避免z-fighting
      weighbridgePos.z
    );
    vehicleModel.rotation.y = weighbridgeRotation;
    vehicleModel.scale.set(1, 1, 1);  // 车辆放大5倍
    
    // 添加车辆标识
    vehicleModel.userData = {
      type: 'vehicle',
      weighbridgeId: weighbridgeId,
      plateNumber: vehicleInfo.plateNumber,
      vehicleType: vehicleInfo.type
    };
    
    // 添加到场景
    if (typeof scene !== 'undefined' && scene && typeof scene.add === 'function') {
      scene.add(vehicleModel);
    } else {
      return; // 如果无法添加到场景，直接返回
    }
    
    // 更新状态
    state.hasVehicle = true;
    state.vehicle = vehicleInfo;
    state.vehicleModel = vehicleModel;
    state.currentWeight = vehicleInfo.weight;
    state.isWeighing = true;
    
  }
  
  // 更新车辆信息
  function updateVehicleInfo(state, weighbridgeInfo) {
    if (state.vehicle) {
      state.vehicle.plateNumber = weighbridgeInfo.plateNumber || '';
      state.vehicle.weight = weighbridgeInfo.currentWeight || 0;
      state.vehicle.driver = weighbridgeInfo.driver || '';
      state.currentWeight = weighbridgeInfo.currentWeight || 0;
    }
  }
  

  // 地磅放置函数
  async function placeWeighbridge(x, z, id, options = {}) {
    const {
      length = 50,
      width = 58,
      height = 0.3,
      rotation = 0
    } = options;

    const group = buildWeighbridge(length, width, height);
    
    // 初始化地磅状态
    const weighbridgeState = {
      hasVehicle: false,
      vehicle: null,
      vehicleModel: null,
      currentWeight: 0,
      isWeighing: false
    };
    weighbridgeStates.set(id, weighbridgeState);

    // 立即创建默认地磅数据，确保地磅能立即渲染
    let apiData = {
      weighbridgeInfo: {
        id: id,
        type: '地磅',
        status: '空闲',
        currentWeight: 0,
        plateNumber: '',
        vehicleType: '',
        arrivalTime: ''
      },
      timestamp: Date.now(),
      dataSource: 'immediate-default'
    };

    // 异步获取API数据更新地磅信息（不阻塞渲染）
    fetchWeighbridgeData({
      weighbridgeId: id,
      weighbridgeNumber: id
    }).then(fetchedData => {
      // 更新地磅的userData
      if (group && group.userData) {
        const { weighbridgeInfo } = fetchedData;
        Object.assign(group.userData, {
          状态: weighbridgeInfo.status || '空闲',
          当前重量_t: weighbridgeInfo.currentWeight || 0,
          车牌号: weighbridgeInfo.plateNumber || '',
          车辆类型: weighbridgeInfo.vehicleType || '',
          到达时间: weighbridgeInfo.arrivalTime || '',
          driver: weighbridgeInfo.driver || '',
          driverid: weighbridgeInfo.driverid || '',
          warehouseName: '钦州侨益仓', // 库区 - 固定传参
          correctPonderation: weighbridgeInfo.correctPonderation || null,
          frontimg: weighbridgeInfo.frontimg || '',
          backimg: weighbridgeInfo.backimg || '',
          wholeimg: weighbridgeInfo.wholeimg || '',
          createTime: weighbridgeInfo.createTime || '',
          recordId: weighbridgeInfo.recordId || '',
          数据来源: fetchedData.dataSource,
          更新时间: fetchedData.timestamp
        });
        
        // 根据状态更新地磅颜色
        updateWeighbridgeColor(group);
      }
    }).catch(error => {
    });

    const { weighbridgeInfo } = apiData;

    // 设置地磅信息（使用接口返回的数据）
    group.userData = {
      type: '地磅',
      id: weighbridgeInfo.id,
      编号: weighbridgeInfo.id,
      状态: weighbridgeInfo.status || '空闲',
      当前重量_t: weighbridgeInfo.currentWeight || 0,
      车牌号: weighbridgeInfo.plateNumber || '',
      车辆类型: weighbridgeInfo.vehicleType || '',
      到达时间: weighbridgeInfo.arrivalTime || '',
      hasMaterialData: true, // 地磅总是有基本数据
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    // 设置位置和旋转
    group.position.set(x, 0, z);
    if (rotation !== 0) {
      group.rotation.y = rotation;
    }

    scene.add(group);
    registerPickable(group);
    registerInteractive(group);

    // 设置地磅颜色
    setWeighbridgeColor(group, lineColors.weighbridge);

    // 添加车辆上磅功能（定时模拟）- 已注释
    // setTimeout(() => {
    //   if (Math.random() < 0.7) { // 70%概率有车辆上磅
    //     addVehicleToWeighbridge(group);
    //   }
    // }, Math.random() * 10000 + 5000); // 5-15秒后可能有车辆上磅

    return group;
  }

  // 车辆上磅函数 - 模拟功能已注释
  function addVehicleToWeighbridge(weighbridge) {
    const weighbridgeId = weighbridge.userData.编号 || weighbridge.userData.id;
    const state = weighbridgeStates.get(weighbridgeId);
    
    if (state.hasVehicle) return; // 已有车辆
    
    // 模拟车辆称重功能已禁用，仅使用API数据
    return;
    
    // 以下模拟代码已注释 - 仅使用API数据
    // // 创建车辆3D模型
    // const vehicleModel = buildVehicle(vehicleInfo.type);
    // 
    // // 设置车辆位置（在地磅上）
    // const weighbridgePos = weighbridge.position;
    // const weighbridgeRotation = weighbridge.rotation.y;
    // 
    // vehicleModel.position.set(
    //   weighbridgePos.x,
    //   weighbridgePos.y + 0.4, // 稍微抬高避免z-fighting
    //   weighbridgePos.z
    // );
    // vehicleModel.rotation.y = weighbridgeRotation;
    // // 在第2897行后添加
    // vehicleModel.scale.set(1, 1, 1);  // 车辆与1号磅相同尺寸
    // 
    // // 添加到场景
    // if (typeof scene !== 'undefined' && scene && typeof scene.add === 'function') {
    //   scene.add(vehicleModel);
    // } else {
    //   return; // 如果无法添加到场景，直接返回
    // }
    // 
    // // 更新状态
    // state.hasVehicle = true;
    // state.vehicle = vehicleInfo;
    // state.vehicleModel = vehicleModel;
    // state.currentWeight = vehicleInfo.weight;
    // state.isWeighing = true;
    // 
    // // 更新地磅userData
    // weighbridge.userData.状态 = '称重中';
    // weighbridge.userData.当前重量_t = vehicleInfo.weight;
    // weighbridge.userData.车牌号 = vehicleInfo.plateNumber;
    // weighbridge.userData.车辆类型 = vehicleInfo.type === 'truck' ? '卡车' : '轿车';
    // weighbridge.userData.到达时间 = vehicleInfo.arrivalTime;
    // 
    // // 设置车辆离开定时器
    // setTimeout(() => {
    //   removeVehicleFromWeighbridge(weighbridge);
    // }, Math.random() * 15000 + 10000); // 10-25秒后车辆离开
    // 
  }
  
  // 车辆下磅函数
  function removeVehicleFromWeighbridge(weighbridge, isApiDriven = false) {
    const weighbridgeId = weighbridge.userData.编号 || weighbridge.userData.id;
    const state = weighbridgeStates.get(weighbridgeId);
    
    // 安全检查：确保state存在
    if (!state) {
      return;
    }
    
    if (!state.hasVehicle) return; // 没有车辆
    
    // 移除车辆模型
    if (state.vehicleModel) {
      // 安全检查scene对象
      if (typeof scene !== 'undefined' && scene && typeof scene.remove === 'function') {
        scene.remove(state.vehicleModel);
      } else {
      }
    }
    
    // 重置状态
    state.hasVehicle = false;
    state.vehicle = null;
    state.vehicleModel = null;
    state.currentWeight = 0;
    state.isWeighing = false;
    
    // 更新地磅userData
    weighbridge.userData.状态 = '空闲';
    weighbridge.userData.当前重量_t = 0;
    weighbridge.userData.车牌号 = '';
    weighbridge.userData.车辆类型 = '';
    weighbridge.userData.到达时间 = '';
    weighbridge.userData.使用次数++;
    
    
    // 模拟定时器已注释 - 仅使用API数据
    // // 只有在非API驱动的情况下才设置下一辆车上磅的定时器
    // if (!isApiDriven) {
    //   setTimeout(() => {
    //     if (Math.random() < 0.8) { // 80%概率有下一辆车
    //       addVehicleToWeighbridge(weighbridge);
    //     }
    //   }, Math.random() * 20000 + 5000); // 5-25秒后可能有下一辆车
    // }
  }

  // 地磅颜色设置函数
  function setWeighbridgeColor(obj, color) {
    if (!obj) return;
    
    obj.children.forEach(child => {
      if (child.material && child.material.type === 'LineBasicMaterial') {
        child.material.color.set(color);
      }
    });
  }

  // 获取地磅基础颜色
  function getWeighbridgeBaseColor(obj) {
    return lineColors.weighbridge;
  }


  async function addSiloGroup(centerX, centerZ, D, spacingIntra, height) {
    const r = D / 2;
    const step = D + spacingIntra;
    const offsets = [-0.5, 0.5]; // 每组固定2个筒仓（在X方向）
    const silos = [];

    // 并行创建所有筒仓
    const siloPromises = offsets.map(k => 
      placeSilo(centerX + k * step, centerZ, r, height, true)
    );

    const createdSilos = await Promise.all(siloPromises);
    silos.push(...createdSilos);

    const bridgeHeight = height * 0.65;
    for (let i = 0; i < silos.length - 1; i++) {
      const pos1 = silos[i].position;
      const pos2 = silos[i + 1].position;
      const bridge = buildConnectingBridge(pos1.x, pos1.z, pos2.x, pos2.z, bridgeHeight);
      scene.add(bridge);
    }

    const platformGeo = new THREE.PlaneGeometry(step * 4, D * 0.8); // 平台宽度适配4个筒仓
    const platformMat = new THREE.MeshStandardMaterial({
      color: 0xC0C0C0,
      roughness: 0.85,
      side: THREE.DoubleSide
    });
    const platform = new THREE.Mesh(platformGeo, platformMat);
    platform.rotation.x = -Math.PI / 2;
    platform.position.set(centerX, 0.05, centerZ + D * 0.6);
    platform.receiveShadow = true;
    scene.add(platform);

    return silos;
  }

  async function layoutSilosAtEastOfWarehouses(warehouses, warehouseConfig, options = {}) {
    const densityTPerM3 = options.densityTPerM3 ?? 0.75;
    const capacityTons = options.capacityTons ?? 5000;
    const height = options.height ?? 35;
    const spacingIntra = options.spacingIntra ?? 5;
    const spacingInter = options.spacingInter ?? 10;
    const rowGroupCounts = options.rowGroupCounts ?? [1, 1, 2, 4];
    const roadSouthMargin = options.roadSouthMargin ?? 5;
    const xOffset = options.xOffset ?? 0; // X方向偏移量
    const zOffset = options.zOffset ?? 0; // Z方向偏移量

    const volumeM3 = capacityTons / densityTPerM3;
    const radius = options.radius ?? Math.sqrt(volumeM3 / (Math.PI * height));
    const D = radius * 2;
    const groupWidth = 2 * D + 1 * spacingIntra; // 每组2个筒仓，1个间距
    const groupDepth = D;

    // 计算筒仓位置时使用仓库的原始位置，不受仓库移动影响
    const {length: wL, width: wW, gap} = warehouseConfig;
    const cols = 1;
    const totalRowSpan = cols * wL + (cols - 1) * gap;
    const originalLeftStart = -totalRowSpan / 122 + wL / 2 - 100; // 仓库的原始位置
    const originalXEast = originalLeftStart + wL / 2; // 原始仓库东侧边界
    const xEast = originalXEast;
    const corridor = 20;

    let zStart = -(roadSouthMargin + groupDepth / 2) + zOffset; // 应用Z方向偏移量

    // 收集所有筒仓组创建的Promise
    const groupPromises = [];

    for (let row = 0; row < rowGroupCounts.length; row++) {
      const groupsInRow = rowGroupCounts[row];
      let xStart = xEast + corridor + (groupWidth / 2) + xOffset; // 应用X方向偏移量

      for (let gi = 0; gi < groupsInRow; gi++) {
        const cx = xStart - gi * (groupWidth + spacingInter); // 向西扩展（负方向）
        groupPromises.push(addSiloGroup(cx, zStart, D, spacingIntra, height));
      }
      zStart -= (groupDepth + spacingInter);
    }

    // 并行创建所有筒仓组
    await Promise.all(groupPromises);

    return {D, height, radius, count: rowGroupCounts.reduce((a, b) => a + b, 0) * 2}; // 每组2个筒仓
  }

  async function init() {
    // 测试颜色解析功能
    testColorParsing();
    
    const cfg = await fetchYardConfig();
    const {length: yardL, width: yardW, roadWidth} = cfg.yard;
    buildYardGrid(yardL, yardW);
    const roadZOffset = 40; // 道路向北移动40米（正值向北）
    buildMainRoad(roadWidth, yardL, roadZOffset);
    buildSidewalkTrees(roadWidth, yardL, 10, roadZOffset);
    
    // 添加2条铁路
    // 第一条铁路：位于道路南侧
    buildRailway(yardL, -30, 0); // Z偏移-30米（道路南侧）
    // 第二条铁路：位于道路更南侧
    buildRailway(yardL, -40, 0); // Z偏移-40米（更南侧）

    const {length: wL, width: wW, height: wH, roofHeight: rH, gap} = cfg.warehouse;
    const cols = 1;
    const rows = 1;
    const totalRowSpan = cols * wL + (cols - 1) * gap;
    const leftStart = -totalRowSpan / 2 + wL / 2 + 60; // 将仓库#A向东移动（增加X坐标）

    const zRowOffset = -(roadWidth / 2 + wW / 2 + 5) + -25; // 向北移动20米（增加Z坐标）
    const rowZs = [zRowOffset];

    // 创建#A仓库（主仓库）- 保持原始位置不变
    const warehouses = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const warehouseIndex = r * cols + c;
        const cz = rowZs[r];
        const cx = leftStart + c * (wL + gap);
        
        const wh = buildWarehouse({length: wL, width: wW, height: wH, roofHeight: rH}, cx, cz, warehouseIndex);
        wh.rotation.y = Math.PI / 2; // 旋转90度，使仓库沿东西方向摆放
        warehouses.push(wh);
        const stkConf = await fetchWarehouseStackConfig(warehouseIndex);
        await populateStacks(wh, {length: wL, width: wW, height: wH}, stkConf, warehouseIndex);
      }
    }

    // 独立的平仓配置 - 每个平仓都是完全独立的
    const flatWarehouseConfigs = {
      'P01': { 
        xOffset:-160, // 相对于#A仓库的偏移量(东西)
        zOffset:20, // 南北方向偏移量(南北)
        scale: 2, // 模型缩放比例
        enabled: true // 是否启用此平仓
      },
      // 'P02': { 
      //   xOffset: -163, 
      //   zOffset: -10,
      //   scale: 1.5, // 模型缩放比例
      //   enabled: true
      // },
      // 'P03': { 
      //   xOffset: -70, 
      //   zOffset: -10,
      //   scale: 1.5, // 模型缩放比例
      //   enabled: true
      // },
      // 'P04': { 
      //   xOffset: 0, 
      //   zOffset: -115,
      //   scale: 1, // 模型缩放比例
      //   enabled: true
      // },
      // 'P05': { 
      //   xOffset: -70, 
      //   zOffset: -115,
      //   scale: 1, // 模型缩放比例
      //   enabled: true
      // },
      // 'P06': { 
      //   xOffset: -140, 
      //   zOffset: -115,
      //   scale: 1, // 模型缩放比例
      //   enabled: true
      // },
    };

    // 创建独立的平仓
    const flatWarehouses = [];
    const mainWarehouseCx = leftStart; // #A仓库的X坐标
    const mainWarehouseCz = rowZs[0];  // #A仓库的Z坐标

    // 为每个平仓创建完整的仓库功能（包括堆垛）
    for (const [warehouseName, config] of Object.entries(flatWarehouseConfigs)) {
      if (!config.enabled) continue; // 跳过未启用的平仓
      
      const flatCx = mainWarehouseCx + config.xOffset;
      const flatCz = mainWarehouseCz + config.zOffset;
      const flatWarehouseIndex = parseInt(warehouseName.substring(1)) + 100; // P01->101, P02->102等
      
      // P01平仓使用独立的建筑尺寸（50米×50米），其他平仓与#A仓库相同
      const flatLength = flatWarehouseIndex === 101 ? 40 : wL;
      const flatWidth = flatWarehouseIndex === 101 ? 50 : wW;
      const flatHeight = flatWarehouseIndex === 101 ? 15 : wH;
      const flatRoofHeight = flatWarehouseIndex === 101 ? 5 : rH;
      
      // 创建平仓建筑
      const flatWarehouse = buildWarehouse(
        {length: flatLength, width: flatWidth, height: flatHeight, roofHeight: flatRoofHeight}, 
        flatCx, 
        flatCz, 
        flatWarehouseIndex
      );
      
      // 应用缩放比例
      if (config.scale && config.scale !== 1) {
        flatWarehouse.scale.set(config.scale, config.scale, config.scale);
      }
      
      // 更新平仓标识为"仓库"类型
      if (flatWarehouse.children && flatWarehouse.children.length > 0) {
        // 找到墙体对象并更新其userData
        const wallObject = flatWarehouse.children.find(child => child.userData && child.userData.type);
        if (wallObject) {
          wallObject.userData = {
            type: '仓库', // 与#A仓库相同的类型
            序号: warehouseName,
            长: flatLength,
            宽: flatWidth,
            高: flatHeight,
            位置: `X:${flatCx.toFixed(1)}, Z:${flatCz.toFixed(1)}`
          };
        }
      }
      
      // 为平仓添加堆垛系统（与#A仓库完全相同）
      try {
        const stkConf = await fetchWarehouseStackConfig(flatWarehouseIndex);
        await populateStacks(flatWarehouse, {length: flatLength, width: flatWidth, height: flatHeight}, stkConf, flatWarehouseIndex);
      } catch (error) {
        // 如果没有特定配置，使用默认堆垛配置
        // P01(101), P02(102), P03(103) 平仓保持原来的18米宽度
        // 其他仓库使用30米宽度
        const defaultStackConfig = {
          stackSize: {
            length: flatWarehouseIndex === 101 ? 100 : 40,  // P01平仓长度增加到100米（南北方向）
            width: flatWarehouseIndex === 101 ? 100 : ((flatWarehouseIndex === 102 || flatWarehouseIndex === 103) ? 18 : 30),  // P01平仓宽度增加到100米（东西方向）
            height: flatWarehouseIndex === 101 ? 12 : 8    // P01平仓高度增加到12米
          },
          spacing: 5,
          margin: 5
        };
        await populateStacks(flatWarehouse, {length: flatLength, width: flatWidth, height: flatHeight}, defaultStackConfig, flatWarehouseIndex);
      }
      
      // 不添加额外的标签，使用模型自带的 #Y、#X、#Z 标签
      
      flatWarehouses.push(flatWarehouse);
    }

    try {
      await layoutSilosAtEastOfWarehouses(warehouses, {length: wL, width: wW, gap}, {
        radius: 4.5,
        height: 35,
        spacingIntra: 0.5,
        spacingInter: 1.5,
        rowGroupCounts: [1, 1, 1, 1], // 筒仓 - Z方向4排，每排1组，每组2个筒仓（在X方向）
        roadSouthMargin: 15, // 减少南侧边距，更好地利用空间
        xOffset: -20, // X方向偏移量（正值向东，负值向西）- 向西移动更多以容纳新增筒仓
        zOffset: -90  // Z方向偏移量（正值向北，负值向南）
      });


      // 添加地磅 - 立即渲染，不等待任何条件
      
      // 立即创建地磅，不使用await等待，确保立即渲染
      placeWeighbridge(110, -75, '1号磅', {       // 1号磅在-60米(-往西)，-40米处(-往南)
        length: 20, 
        width: 10, 
        rotation: 0 // 0度旋转，使车辆沿东西方向行驶
      }).then(() => {
      }).catch(error => {
      });
      
      placeWeighbridge(110, -55, '2号磅', {       // 2号磅在-10米(-往西)，-20米处(-往南)
        length: 20, 
        width: 10, 
        // rotation: Math.PI / 2 // 90度旋转，使地磅垂直于道路
        rotation:  0 // 0度旋转，使车辆沿东西方向行驶
      }).then(() => {
      }).catch(error => {
      });
      
      // placeWeighbridge(-105, -75, '3号磅', {       // 3号磅在110米(往东)，-25米处(往南)
      //   length: 20, 
      //   width: 10, 
      //   rotation: 0 // 0度旋转，使车辆沿东西方向行驶
      // }).then(() => {
      // }).catch(error => {
      // });
      
      // placeWeighbridge(-105, -55, '4号磅', {       // 4号磅在110米(往东)，25米处(往北)
      //   length: 20, 
      //   width: 10, 
      //   rotation: 0 // 0度旋转，使车辆沿东西方向行驶
      // }).then(() => {
      // }).catch(error => {
      // });
      

      // ================= 添加星仓 =================
      
      // 星仓偏移量配置
      const starSiloConfig = {
        xOffset: -80, // X方向偏移量（正值向东，负值向西）
        zOffset: -70  // Z方向偏移量（正值向北，负值向南）
      };

      // 并行创建所有星仓（共18个）
      // const starSiloPromises = [
      //   // 一排星仓（4个）
      //   placeStarSilo(-35 + starSiloConfig.xOffset, -24.30 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-35 + starSiloConfig.xOffset, -35.00 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-35 + starSiloConfig.xOffset, -45.00 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-35 + starSiloConfig.xOffset, -56.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   // 二排星仓（4个）
      //   placeStarSilo(-25 + starSiloConfig.xOffset, -24.30 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-25 + starSiloConfig.xOffset, -35.00 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-25 + starSiloConfig.xOffset, -45.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-25 + starSiloConfig.xOffset, -56.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   // 三排星仓（4个）
      //   placeStarSilo(-15 + starSiloConfig.xOffset, -24.30 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-15 + starSiloConfig.xOffset, -35.00 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-15 + starSiloConfig.xOffset, -45.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-15 + starSiloConfig.xOffset, -56.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   // 四排星仓（2个）
      //   placeStarSilo(-6 + starSiloConfig.xOffset, -24.30 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-6 + starSiloConfig.xOffset, -35.00 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-6 + starSiloConfig.xOffset, -45.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(-6 + starSiloConfig.xOffset, -56.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   // 四排星仓（2个）
      //   // 五排星仓（2个）
      //   placeStarSilo(2 + starSiloConfig.xOffset, -24.30 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(2 + starSiloConfig.xOffset, -35.00 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(2 + starSiloConfig.xOffset, -45.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      //   placeStarSilo(2 + starSiloConfig.xOffset, -56.50 + starSiloConfig.zOffset, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
      
      // ];

      // await Promise.all(starSiloPromises);
      // ================= 星仓创建完成 =================

      // 添加保安室
      const securityRoom = buildSecurityRoom();
      scene.add(securityRoom);

    } catch (error) {
      // 网络错误已在API调用中显示，这里不再重复显示
      return; // 停止初始化过程
    }
   


    fitCameraToYard(yardL, yardW, wH + rH, 1.0);
    updateCompass();
    
    // 初始化完成后启动自动刷新
    startAutoRefresh();
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);

  }

  init();
  animate();
</script>
</body>
</html>