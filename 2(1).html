<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>仓库园区立体透视图 - 线框模式</title>l
  <style>
    :root {
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-fg: #222;
      --panel-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #f0f0f0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    }

    #loginOverlay {
      position: fixed;
      inset: 0;
      z-index: 999;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #f7fafc, #eef2f7);
    }

    #loginCard {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      padding: 24px 24px 20px;
      width: 320px;
    }

    #loginCard h2 {
      margin: 0 0 12px;
      font-size: 18px;
      color: #111;
    }

    .form-row {
      margin: 10px 0;
    }

    .form-row label {
      display: block;
      font-size: 13px;
      color: #444;
      margin-bottom: 6px;
    }

    .form-row input {
      width: 100%;
      height: 34px;
      padding: 6px 10px;
      border: 1px solid #d5d7db;
      border-radius: 6px;
      outline: none;
      box-sizing: border-box;
    }

    .form-actions {
      margin-top: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .btn {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .error {
      color: #b91c1c;
      font-size: 12px;
      min-height: 16px;
    }

    #viewport {
      width: 90vw;
      height: 90vh;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #f0f0f0;
    }

    canvas {
      display: block;
    }

    #infoPanel {
      position: fixed;
      display: none;
      z-index: 10;
      left: 0;
      top: 0;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: var(--panel-shadow);
      font-size: 14px;
      pointer-events: none;
      min-width: 120px;
      line-height: 1.5;
    }

    #detailPanel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      min-width: 300px;
      max-width: 400px;
      max-height: 70vh;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.4;
    }

    #compass {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 100px;
      height: 100px;
      z-index: 11;
      background: var(--panel-bg);
      border-radius: 50%;
      box-shadow: var(--panel-shadow);
      display: grid;
      place-items: center;
      user-select: none;
      pointer-events: none;
    }

    #compass svg {
      width: 84px;
      height: 84px;
    }

    #compass .label {
      font-size: 12px;
      font-weight: 600;
      fill: #333;
    }

    .whLabel {
      background: #ffffff;
      border: 1px solid #d0d5dd;
      color: #111;
      font-size: 12px;
      line-height: 1;
      padding: 4px 6px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
    }

    #whPanel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      min-width: 240px;
      font-size: 14px;
    }

    #actionBar {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%) translateY(12px);
      z-index: 12;
      opacity: 0;
      pointer-events: none;
      transition: transform .18s ease, opacity .18s ease;
    }

    #actionBar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    .action-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--panel-bg);
      color: var(--panel-fg);
      box-shadow: var(--panel-shadow);
      border-radius: 999px;
      padding: 8px;
      backdrop-filter: saturate(160%) blur(6px);
    }

    .action-bar .btn {
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 14px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
    }


    #modelPanel {
      position: fixed;
      right: 16px;
      top: 130px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      width: 280px;
      height: 200px;
    }

    #modelPanel .model-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #2563eb;
      text-align: center;
    }

    #modelViewport {
      width: 100%;
      height: 160px;
      border: 1px solid #d5d7db;
      border-radius: 6px;
      background: #f8f9fa;
    }

    #monitorPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      width: 80vw;
      max-width: 800px;
      height: 60vh;
      max-height: 500px;
    }

    #monitorPanel .monitor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      background: #f8f9fa;
      border-radius: 8px 8px 0 0;
    }

    #monitorPanel .monitor-title {
      font-weight: 600;
      color: #2563eb;
      margin: 0;
    }

    #monitorPanel .monitor-close {
      background: #dc2626;
      color: white;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
    }

    #monitorPanel .monitor-close:hover {
      background: #b91c1c;
    }

    #monitorVideoContainer {
      position: relative;
      width: 100%;
      height: calc(100% - 60px);
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0 0 8px 8px;
    }

    #monitorVideo {
      width: 100%;
      height: 100%;
      background: #000;
    }

    .monitor-controls {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      border-radius: 6px;
    }

    .monitor-controls button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .monitor-controls button:hover {
      background: #1d4ed8;
    }

    .monitor-controls button:disabled {
      background: #6b7280;
      cursor: not-allowed;
    }

    .monitor-loading {
      color: #888;
      font-size: 16px;
    }

    #networkErrorPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      display: none;
      background: #fff;
      color: #333;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      padding: 24px;
      width: 300px;
      text-align: center;
    }

    #networkErrorPanel .error-icon {
      font-size: 48px;
      color: #dc2626;
      margin-bottom: 16px;
    }

    #networkErrorPanel .error-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #dc2626;
    }

    #networkErrorPanel .error-message {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
      line-height: 1.5;
    }

    #networkErrorPanel .error-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    #networkErrorPanel .btn-retry {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    #networkErrorPanel .btn-retry:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
<div id="loginOverlay">
  <div id="loginCard">
    <h2>登录</h2>
    <form id="loginForm">
      <div class="form-row">
        <label for="username">用户名</label>
        <input id="username" name="username" autocomplete="username" placeholder="请输入用户名"/>
      </div>
      <div class="form-row">
        <label for="password">密码</label>
        <input id="password" name="password" type="password" autocomplete="current-password"
               placeholder="请输入密码"/>
      </div>
      <div class="form-actions">
        <button type="submit" class="btn">登录</button>
        <span id="loginError" class="error"></span>
      </div>
    </form>
  </div>
</div>

<div id="viewport"></div>
<div id="infoPanel"></div>
<div id="detailPanel"></div>
<div id="modelPanel">
  <div class="model-title">筒仓模型预览</div>
  <div id="modelViewport"></div>
</div>
<div id="compass" aria-label="指南针">
  <svg viewBox="0 0 100 100">
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6"
              orient="auto-start-reverse">
        <path d="M0,0 L10,5 L0,10 z" fill="#d00"/>
      </marker>
    </defs>
    <circle cx="50" cy="50" r="38" fill="none" stroke="#888" stroke-width="2"/>
    <line x1="50" y1="50" x2="50" y2="12" stroke="#d00" stroke-width="3" marker-end="url(#arrow)"/>
    <line x1="50" y1="10" x2="50" y2="20" stroke="#666" stroke-width="2"/>
    <line x1="50" y1="80" x2="50" y2="90" stroke="#666" stroke-width="2"/>
    <line x1="10" y1="50" x2="20" y2="50" stroke="#666" stroke-width="2"/>
    <line x1="80" y1="50" x2="90" y2="50" stroke="#666" stroke-width="2"/>
    <text x="50" y="8" text-anchor="middle" class="label">N</text>
    <text x="92" y="54" text-anchor="middle" class="label">E</text>
    <text x="50" y="98" text-anchor="middle" class="label">S</text>
    <text x="8" y="54" text-anchor="middle" class="label">W</text>
  </svg>
</div>
<div id="whPanel"></div>

<div id="actionBar" aria-live="polite">
  <div class="action-bar">
    <button id="btnLfs" class="btn">查看LFS订单</button>
    <button id="btnTms" class="btn">查看相关TMS运输订单</button>
    <button id="btnFee" class="btn">查看堆垛仓储费用</button>
    <button id="btnMonitor" class="btn">查看监控</button>
  </div>
</div>

<!-- 网络错误提示面板 -->
<div id="networkErrorPanel">
  <div class="error-icon">⚠️</div>
  <div class="error-title">网络连接错误</div>
  <div class="error-message">网络繁忙，请稍后再试</div>
  <div class="error-actions">
    <button class="btn-retry" id="retryBtn">重试</button>
  </div>
</div>

<!-- 监控播放面板 -->
<div id="monitorPanel">
  <div class="monitor-header">
    <h3 class="monitor-title">筒仓监控播放</h3>
    <button class="monitor-close" id="monitorClose">×</button>
  </div>
  <div id="monitorVideoContainer">
    <video id="monitorVideo" controls autoplay muted>
      您的浏览器不支持视频播放
    </video>
    <div class="monitor-controls">
      <button id="playBtn">播放</button>
      <button id="pauseBtn">暂停</button>
      <button id="fullscreenBtn">全屏</button>
    </div>
    <div class="monitor-loading" id="monitorLoading" style="display: none;">
      正在加载监控流...
    </div>
  </div>
</div>

<!-- 引入flv.js用于播放萤石监控流 -->
<script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
  import {CSS2DRenderer, CSS2DObject} from 'three/addons/renderers/CSS2DRenderer.js';

  // 登录逻辑
  const loginOverlay = document.getElementById('loginOverlay');
  const loginForm = document.getElementById('loginForm');
  const loginError = document.getElementById('loginError');
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  let currentUser = null;

  loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const u = usernameInput.value.trim();
    const p = passwordInput.value;
    if (u === 'JF' && p === '123456') {
      currentUser = u;
      loginOverlay.style.display = 'none';
    } else {
      currentUser = u;
      loginOverlay.style.display = 'none';
      //loginError.textContent = '用户名或密码不正确';
      //return;
    }
  });

  // 配置获取
  async function fetchYardConfig() {
    return {
      yard: {length: 300, width: 290, roadWidth: 20}, // 将length从350减少到300，缩小西方向50米；width保持290米
      warehouse: {
        count: 1,
        length: 40,
        width: 50,
        height: 15,
        roofHeight: 5,
        gap: 15,
      }
    };
  }

  async function fetchWarehouseStackConfig(warehouseIndex) {
    return {
      stackSize: {length: 25, width: 25, height: 12},
      spacing: 5,
      margin: 5
    };
  }

  // Three.js 基础设置
  const container = document.getElementById('viewport');
  const infoPanel = document.getElementById('infoPanel');
  const detailPanel = document.getElementById('detailPanel');
  const modelPanel = document.getElementById('modelPanel');
  const modelViewport = document.getElementById('modelViewport');
  const compass = document.getElementById('compass');
  const whPanel = document.getElementById('whPanel');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  scene.fog = new THREE.Fog(0xf0f0f0, 600, 2500);

  const camera = new THREE.PerspectiveCamera(65, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(600, 600, 600);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(container.clientWidth, container.clientHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0';
  labelRenderer.domElement.style.left = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  labelRenderer.domElement.style.zIndex = '10';
  container.appendChild(labelRenderer.domElement);

  // 模型预览渲染器
  let modelRenderer = null;
  let modelScene = null;
  let modelCamera = null;
  let modelControls = null;

  function initModelRenderer() {
    if (modelRenderer) return;

    modelScene = new THREE.Scene();
    modelScene.background = new THREE.Color(0xf8f9fa);

    const width = 248; // modelViewport width minus padding
    const height = 160; // modelViewport height

    modelCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    modelCamera.position.set(15, 15, 15);

    modelRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    modelRenderer.setSize(width, height);
    modelRenderer.setPixelRatio(window.devicePixelRatio);
    modelRenderer.shadowMap.enabled = true;
    modelRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // 添加光照
    const modelHemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    modelScene.add(modelHemiLight);

    const modelDirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    modelDirLight.position.set(10, 10, 10);
    modelDirLight.castShadow = true;
    modelDirLight.shadow.mapSize.width = 512;
    modelDirLight.shadow.mapSize.height = 512;
    modelScene.add(modelDirLight);

    modelViewport.appendChild(modelRenderer.domElement);

    modelControls = new OrbitControls(modelCamera, modelRenderer.domElement);
    modelControls.enableDamping = true;
    modelControls.dampingFactor = 0.05;
    modelControls.enablePan = false;
    modelControls.minDistance = 8;
    modelControls.maxDistance = 40;
  }

  function showSiloModel(siloObj) {
    if (!siloObj || !siloObj.userData) return;

    initModelRenderer();

    // 清空之前的模型
    while (modelScene.children.length > 2) { // 保留光照
      modelScene.remove(modelScene.children[2]);
    }

    const userData = siloObj.userData;
    const type = userData.type;
    const radius = parseFloat(userData.半径_m) || 4.5;
    const height = parseFloat(userData.高度_m) || 35;
    const materials = userData.物料详情 || [];

    // 缩放因子使模型适合预览窗口
    const scale = 0.15;

    if (type === '星仓') {
      // 创建星仓模型
      const outerRadius = radius * scale;
      const innerRadius = outerRadius * 0.55;
      const modelHeight = height * scale;
      
      const starOutline = createStarOutlinePoints(outerRadius, innerRadius, 5);
      const shape = new THREE.Shape();
      shape.moveTo(starOutline[0].x, starOutline[0].y);
      for (let i = 1; i < starOutline.length; i++) {
        shape.lineTo(starOutline[i].x, starOutline[i].y);
      }
      shape.closePath();

      const extrude = new THREE.ExtrudeGeometry(shape, {
        steps: 1,
        depth: modelHeight,
        bevelEnabled: false
      });
      extrude.rotateX(-Math.PI / 2);
      extrude.translate(0, modelHeight / 2, 0);

      const bodyMat = new THREE.MeshStandardMaterial({
        color: lineColors.starSilo,
        roughness: 0.55,
        metalness: 0.25
      });
      const starModel = new THREE.Mesh(extrude, bodyMat);
      starModel.castShadow = true;
      starModel.receiveShadow = true;
      modelScene.add(starModel);
      
      // 添加顶部装饰
      const capGeo = new THREE.ConeGeometry(innerRadius * 0.45, 0.33, 6);
      const capMat = new THREE.MeshStandardMaterial({
        color: 0xffe59f,
        roughness: 0.35,
        metalness: 0.3
      });
      const cap = new THREE.Mesh(capGeo, capMat);
      cap.position.y = modelHeight * 1.1;
      cap.castShadow = true;
      modelScene.add(cap);
      
    } else {
      // 创建普通筒仓模型
      const modelRadius = radius * scale;
      const modelHeight = height * scale;
      
      if (materials.length === 0) {
        // 空筒仓
        const geo = new THREE.CylinderGeometry(modelRadius, modelRadius, modelHeight, 16);
        const mat = new THREE.MeshStandardMaterial({
          color: emptySiloColor,
          roughness: 0.9,
          metalness: 0.05
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = modelHeight / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        modelScene.add(mesh);
      } else {
        // 有物料的筒仓，显示分层
        const totalAmount = materials.reduce((sum, m) => sum + parseFloat(m.amount), 0);
        let currentY = 0;
        
        materials.forEach((material) => {
          const proportion = parseFloat(material.amount) / totalAmount;
          const segmentHeight = modelHeight * proportion * 0.8;
          
          if (segmentHeight > 0.01) {
            const geo = new THREE.CylinderGeometry(modelRadius, modelRadius, segmentHeight, 16);
            const colorData = parseColor(material.companyColor);
            const companyColor = colorData.hex || emptySiloColor;
            const mat = new THREE.MeshStandardMaterial({
              color: companyColor,
              roughness: 0.9,
              metalness: 0.05
            });
            
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = currentY + segmentHeight / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            modelScene.add(mesh);
            currentY += segmentHeight;
          }
        });
      }
      
      // 添加屋顶
      const roofGeo = new THREE.ConeGeometry(modelRadius * 1.05, 0.45, 12);
      const roofMat = new THREE.MeshStandardMaterial({
        color: 0xA0A0A0,
        roughness: 0.7,
        metalness: 0.3
      });
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.y = modelHeight + 0.225;
      roof.castShadow = true;
      roof.userData = { isRoof: true }; // 标识这是屋顶
      modelScene.add(roof);
    }

    // 添加地面
    const groundGeo = new THREE.PlaneGeometry(20, 20);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0xe8e8e8,
      roughness: 1.0,
      metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    modelScene.add(ground);

    // 设置相机位置
    const maxDim = Math.max(radius * scale * 2, height * scale);
    const distance = maxDim * 2.5;
    modelCamera.position.set(distance, distance * 0.8, distance);
    modelCamera.lookAt(0, height * scale / 2, 0);
    modelControls.target.set(0, height * scale / 2, 0);
    modelControls.update();

    // 更新标题
    const titleEl = modelPanel.querySelector('.model-title');
    const typeLabel = type === '星仓' ? '★星仓模型预览' : '筒仓模型预览';
    titleEl.textContent = `${typeLabel} ${userData.编号 || '#' + userData.id}`;

    // 显示面板
    modelPanel.style.display = 'block';
  }

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  const polarAngle = Math.PI / 4;
  controls.minPolarAngle = polarAngle;
  controls.maxPolarAngle = polarAngle;
  controls.minDistance = 100;
  controls.maxDistance = 2000;
  controls.target.set(0, 0, 0);

  // 光照系统
  const hemi = new THREE.HemisphereLight(0xffffff, 0xd0d0d0, 0.8);
  scene.add(hemi);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(200, 300, 200);
  dirLight.castShadow = true;
  dirLight.shadow.camera.left = -300;
  dirLight.shadow.camera.right = 300;
  dirLight.shadow.camera.top = 300;
  dirLight.shadow.camera.bottom = -300;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambLight);

  // 线框创建
  function createWireframe(geometry, color = 0x333333) {
    const edges = new THREE.EdgesGeometry(geometry);
    const mat = new THREE.LineBasicMaterial({color});
    return new THREE.LineSegments(edges, mat);
  }

  // 随机工具
  const random = {
    pick: (arr) => arr[Math.floor(Math.random() * arr.length)],
    float: (min, max) => Math.random() * (max - min) + min,
    dateBetween(start, end) {
      const t = start.getTime() + Math.random() * (end.getTime() - start.getTime());
      return new Date(t);
    },
    dateWithinDays(days) {
      const now = new Date();
      const past = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
      return this.dateBetween(past, now);
    },
    fmtDate(d) {
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    },
    subset(arr) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      const count = Math.max(1, Math.floor(Math.random() * copy.length));
      return copy.slice(0, count);
    },
    phone() {
      const starts = ['3', '5', '6', '7', '8', '9'];
      let s = '1' + this.pick(starts);
      for (let i = 0; i < 9; i++) s += Math.floor(Math.random() * 10);
      return s;
    }
  };

  // 颜色配置
  const lineColors = {
    wall: 0x555555,
    roof: 0x8B4513,
    stack: 0x6b6b6b,
    hover: 0x1e90ff,
    selected: 0xff3333,
    ownerJF: 0x22aa22,
    fence: 0x2f855a,
    tree: 0x2e7d32,
    silo: 0x888888,
    siloOwnerJF: 0x33bb33,
    siloHover: 0x2eb8ff,
    siloSelected: 0xff4444,
    starSilo: 0xf2b134,
    starSiloOwnerJF: 0xffc75f,
    starSiloHover: 0xffe59f,
    starSiloSelected: 0xff7f50,
  };

  const emptySiloColor = 0xD8D8D0; // Neutral fill for silos without material data

  // 物料数据模拟系统
  const companyNames = ['建发集团', '国贸集团', '中粮集团', '华润集团', '新希望集团', '正邦集团'];
  const materialTypes = ['玉米', '小麦', '大豆', '稻谷', '菜籽', '高粱'];
  
  // 公司颜色映射（已弃用，现在使用API返回的companyColor字段）
  const companyColors = {
    '建发集团': 0x22aa22,  // 绿色
    '国贸集团': 0x2563eb,  // 蓝色
    '中粮集团': 0xf59e0b,  // 黄色
    '华润集团': 0xef4444,  // 红色
    '新希望集团': 0x8b5cf6, // 紫色
    '正邦集团': 0x06b6d4,  // 青色
    // 新增的公司颜色映射
    '广州市储备粮管理中心': 0x22aa22,  // 绿色
    '黄埔区发展和改革局': 0x32b67a,  // hsl(162.0, 65%, 55%) - 绿蓝色
    '河南华穗农产品有限公司': 0xf59e0b,  // 黄色
    '粤海永顺泰（广州）麦芽有限公司': 0xef4444  // 红色
  };
  
  // 颜色转换工具函数
  function getColorCSS(hexColor) {
    return `#${hexColor.toString(16).padStart(6, '0')}`;
  }

  // HSL颜色处理函数
  function parseColor(colorValue) {
    if (!colorValue) return { hex: 0x666666, css: '#666666' };
    
    // 如果是HSL格式
    if (typeof colorValue === 'string' && colorValue.includes('hsl')) {
      const hexValue = hslToHex(colorValue);
      return { hex: hexValue, css: getColorCSS(hexValue) };
    }
    
    // 如果是十六进制数值
    if (typeof colorValue === 'number') {
      return { hex: colorValue, css: getColorCSS(colorValue) };
    }
    
    // 如果是十六进制字符串
    if (typeof colorValue === 'string' && colorValue.startsWith('#')) {
      const hex = parseInt(colorValue.substring(1), 16);
      return { hex: hex, css: colorValue };
    }
    
    // 默认颜色
    return { hex: 0x666666, css: '#666666' };
  }

  // HSL转十六进制
  function hslToHex(hslString) {
    const match = hslString.match(/hsl\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)%,\s*(\d+(?:\.\d+)?)%\)/);
    if (!match) {
      console.warn('无法解析HSL颜色:', hslString);
      return 0x666666;
    }
    
    const h = parseFloat(match[1]) / 360;
    const s = parseFloat(match[2]) / 100;
    const l = parseFloat(match[3]) / 100;
    
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    let r, g, b;
    if (s === 0) {
      r = g = b = l; // 无饱和度
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    
    const rHex = Math.round(r * 255);
    const gHex = Math.round(g * 255);
    const bHex = Math.round(b * 255);
    
    const result = (rHex << 16) + (gHex << 8) + bHex;
    console.log(`HSL转换: ${hslString} -> RGB(${rHex}, ${gHex}, ${bHex}) -> 0x${result.toString(16)}`);
    return result;
  }

  // 颜色解析测试函数
  function testColorParsing() {
    console.log('=== 颜色解析测试 ===');
    const testColors = [
      'hsl(162.0, 65%, 55%)',
      '#ff0000',
      0x00ff00,
      'hsl(240, 100%, 50%)',
      'invalid-color'
    ];
    
    testColors.forEach(color => {
      const result = parseColor(color);
      console.log(`输入: ${color} -> hex: 0x${result.hex.toString(16)}, css: ${result.css}`);
    });
    console.log('=== 测试结束 ===');
  }

  // 真实API接口配置
  const API_CONFIG = {
    BASE_URL: 'http://127.0.0.1:8062',
    // BASE_URL: 'https://6166qiyy8859.vicp.fun',
    PATH_PREFIX: '/driver-appointment-service',
    ENDPOINTS: {
      ALL_SILOS: '/api/order-driver/siloStarWarehouseData'
    }
  };

  // 全局筒仓数据缓存
  let globalSiloData = null;
  let lastFetchTime = 0;
  const CACHE_DURATION = 5 * 60 * 1000; // 5分钟缓存
  
  // 请求去重机制：确保同一时间只有一个API请求
  let ongoingFetchPromise = null;

  // 从真实API获取所有筒仓数据
  async function fetchAllSilosFromAPI() {
    const now = Date.now();
    
    // 如果有缓存且未过期，直接使用缓存
    if (globalSiloData && (now - lastFetchTime) < CACHE_DURATION) {
      return globalSiloData;
    }
    
    // 如果已经有请求在进行中，等待该请求完成
    if (ongoingFetchPromise) {
      console.log('等待进行中的API请求完成...');
      return await ongoingFetchPromise;
    }

    // 创建新的请求Promise
    ongoingFetchPromise = performActualFetch();
    
    try {
      const result = await ongoingFetchPromise;
      return result;
    } finally {
      // 请求完成后清除Promise引用，允许后续请求
      ongoingFetchPromise = null;
    }
    
    async function performActualFetch() {
      try {
        const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.PATH_PREFIX}${API_CONFIG.ENDPOINTS.ALL_SILOS}`;
        console.log('正在从API获取筒仓数据:', apiUrl);
        
        const response = await fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
        }

        const apiResponse = await response.json();
        
        if (apiResponse.success && apiResponse.data) {
          // 将对象格式的数据转换为数组格式
          const siloList = [];
          const dataKeys = Object.keys(apiResponse.data);
          
          dataKeys.forEach(key => {
            const siloData = apiResponse.data[key];
            if (siloData && siloData.siloInfo) {
              siloList.push(siloData);
            }
          });
          
          // 构造前端期望的数据格式
          globalSiloData = {
            siloList: siloList,
            totalCount: siloList.length,
            timestamp: new Date().toISOString(),
            dataSource: 'production-api'
          };
          
          lastFetchTime = now;
          console.log(`成功获取 ${globalSiloData.totalCount} 个筒仓数据`);
          return globalSiloData;
        } else {
          throw new Error('API返回数据格式错误');
        }
      } catch (error) {
        console.error('获取API数据失败:', error);
        // 显示网络错误提示
        showNetworkError();
        throw new Error('网络繁忙，请稍后再试');
      }
    }
  }

  // 根据筒仓编号从全局数据中获取单个筒仓数据
  async function fetchSiloAndMaterialData(siloParams) {
    const { siloId, siloNumber, siloType } = siloParams;
    
    // 获取所有筒仓数据
    const allSilosData = await fetchAllSilosFromAPI();
    
    if (!allSilosData || !allSilosData.siloList) {
      console.error('无法获取筒仓数据');
      throw new Error('网络繁忙，请稍后再试');
    }

    // 直接使用传入的筒仓编号查找API数据
    let targetSilo;
    if (siloNumber) {
      // 优先使用传入的编号查找
      targetSilo = allSilosData.siloList.find(silo => silo.siloInfo.id === siloNumber);
      console.log(`使用编号查找筒仓: ${siloNumber}`, targetSilo ? '找到' : '未找到');
    }
    
    // 如果按编号未找到，则使用原有的数字ID映射逻辑作为备用
    if (!targetSilo) {
      const apiSiloIds = allSilosData.siloList.map(silo => silo.siloInfo.id).sort(); // 按字母顺序排序，确保一致性
      let targetApiId;
      if (siloId <= apiSiloIds.length) {
        targetApiId = apiSiloIds[siloId - 1]; // siloId从1开始，数组从0开始
      }
      console.log(`备用映射: 数字ID ${siloId} -> API ID ${targetApiId}`);
      targetSilo = allSilosData.siloList.find(silo => silo.siloInfo.id === targetApiId);
    }
    
    if (targetSilo) {
      const actualId = targetSilo.siloInfo.id;
      console.log(`成功找到筒仓数据: ${actualId}`, targetSilo);
      // 转换API数据格式为前端需要的格式
      return {
        siloInfo: {
          id: targetSilo.siloInfo.id,
          type: targetSilo.siloInfo.type,
          radius: targetSilo.siloInfo.radius,
          height: targetSilo.siloInfo.height,
          volume: targetSilo.siloInfo.volume,
          maxCapacity: targetSilo.siloInfo.maxCapacity,
          currentStorage: targetSilo.siloInfo.currentStorage,
          mainCargo: extractMainCargo(targetSilo.materialDetails),
          storageTime: targetSilo.siloInfo.storageTime,
          temperature: targetSilo.siloInfo.temperature,
          humidity: targetSilo.siloInfo.humidity,
          status: targetSilo.siloInfo.status,
          owner: extractOwner(targetSilo.materialDetails),
          specialMark: targetSilo.siloInfo.specialMark,
          arms: targetSilo.siloInfo.arms
        },
        materialDetails: targetSilo.materialDetails || [],
        timestamp: targetSilo.timestamp,
        dataSource: targetSilo.dataSource || 'production-api'
      };
    } else {
      console.warn(`未找到映射的筒仓数据: 数字ID ${siloId} -> API ID ${targetApiId}`);
      // 返回默认的空筒仓数据，避免系统崩溃
      return {
        siloInfo: {
          id: `T${String(siloId).padStart(3, '0')}`,
          type: siloType || '筒仓',
          radius: siloParams.radius,
          height: siloParams.height,
          volume: siloParams.volume,
          maxCapacity: siloParams.capacity,
          currentStorage: 0,
          mainCargo: '空仓',
          storageTime: '',
          temperature: '',
          humidity: '',
          status: '空仓',
          owner: null
        },
        materialDetails: [],
        timestamp: new Date().toISOString(),
        dataSource: 'fallback-empty'
      };
    }
  }
  
  // 辅助函数：从物料详情中提取主要货物
  function extractMainCargo(materialDetails) {
    if (!materialDetails || materialDetails.length === 0) return '空仓';
    
    // 找到数量最大的物料
    const maxMaterial = materialDetails.reduce((max, current) => {
      const currentAmount = Math.abs(parseFloat(current.amount) || 0);
      const maxAmount = Math.abs(parseFloat(max.amount) || 0);
      return currentAmount > maxAmount ? current : max;
    }, materialDetails[0]);
    
    return maxMaterial.material || '未知';
  }
  
  // 辅助函数：从物料详情中提取所有者
  function extractOwner(materialDetails) {
    if (!materialDetails || materialDetails.length === 0) return null;
    
    // 获取所有公司名称，去重
    const companies = [...new Set(materialDetails.map(m => m.company).filter(Boolean))];
    return companies.length > 0 ? companies[0] : null;
  }




  // 网络错误处理
  const networkErrorPanel = document.getElementById('networkErrorPanel');
  const retryBtn = document.getElementById('retryBtn');

  function showNetworkError() {
    networkErrorPanel.style.display = 'block';
  }

  function hideNetworkError() {
    networkErrorPanel.style.display = 'none';
  }

  // 重试按钮事件监听
  retryBtn.addEventListener('click', () => {
    hideNetworkError();
    // 重新初始化系统
    location.reload();
  });

  const raycastTargets = [];
  const raycastTargetSet = new Set();
  const interactives = [];
  const interactiveSet = new Set();

  function registerPickable(obj) {
    if (!obj || raycastTargetSet.has(obj)) return;
    raycastTargets.push(obj);
    raycastTargetSet.add(obj);
  }

  function registerInteractive(obj) {
    if (!obj || interactiveSet.has(obj)) return;
    registerPickable(obj);
    interactives.push(obj);
    interactiveSet.add(obj);
  }
  let hovered = null;
  let selected = null;

  const actionBar = document.getElementById('actionBar');
  const btnLfs = document.getElementById('btnLfs');
  const btnTms = document.getElementById('btnTms');
  const btnFee = document.getElementById('btnFee');
  const btnMonitor = document.getElementById('btnMonitor');

  const isOwnedByCurrent = (obj) => !!currentUser && obj?.userData?.owner === currentUser;

  // 监控相关元素和变量
  const monitorPanel = document.getElementById('monitorPanel');
  const monitorVideo = document.getElementById('monitorVideo');
  const monitorClose = document.getElementById('monitorClose');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const monitorLoading = document.getElementById('monitorLoading');
  
  let flvPlayer = null;
  const YINGSHI_MONITOR_URL = 'https://rtmp05open.ys7.com:9188/v3/openlive/C54441328_1_1.flv?expire=1761814378&id=901513545338388480&t=d8d642746d1c4827d6a11f1a4cd035c7ae35f3b27af62bb14611d3b9eef52f82&ev=101&supportH265=1';

  // 监控播放器初始化函数
  function initFlvPlayer() {
    if (flvPlayer) {
      flvPlayer.destroy();
      flvPlayer = null;
    }

    if (flvjs.isSupported()) {
      flvPlayer = flvjs.createPlayer({
        type: 'flv',
        url: YINGSHI_MONITOR_URL,
        isLive: true,
        cors: true,
        withCredentials: false,
        hasAudio: false,
        hasVideo: true
      });
      
      flvPlayer.attachMediaElement(monitorVideo);
      
      // 播放器事件监听
      flvPlayer.on(flvjs.Events.LOADING_COMPLETE, () => {
        console.log('监控流加载完成');
        monitorLoading.style.display = 'none';
      });
      
      flvPlayer.on(flvjs.Events.ERROR, (errorType, errorDetail, errorInfo) => {
        console.error('监控播放错误:', errorType, errorDetail, errorInfo);
        monitorLoading.textContent = '监控流加载失败，请稍后重试';
        monitorLoading.style.color = '#dc2626';
      });
      
      try {
        flvPlayer.load();
      } catch (e) {
        console.error('FLV播放器加载失败:', e);
        monitorLoading.textContent = '监控播放器初始化失败';
        monitorLoading.style.color = '#dc2626';
      }
    } else {
      console.error('浏览器不支持FLV播放');
      monitorLoading.textContent = '当前浏览器不支持FLV视频播放';
      monitorLoading.style.color = '#dc2626';
    }
  }

  // 显示监控面板
  function showMonitorPanel(siloData) {
    const siloType = siloData.type === '星仓' ? '★星仓' : '筒仓';
    const monitorTitle = monitorPanel.querySelector('.monitor-title');
    monitorTitle.textContent = `${siloType} #${siloData.id} 监控播放`;
    
    monitorPanel.style.display = 'block';
    monitorLoading.style.display = 'block';
    monitorLoading.textContent = '正在连接监控流...';
    monitorLoading.style.color = '#888';
    
    // 延迟初始化播放器，确保面板已显示
    setTimeout(() => {
      initFlvPlayer();
    }, 100);
  }

  // 关闭监控面板
  function closeMonitorPanel() {
    monitorPanel.style.display = 'none';
    if (flvPlayer) {
      flvPlayer.pause();
      flvPlayer.unload();
      flvPlayer.detachMediaElement();
      flvPlayer.destroy();
      flvPlayer = null;
    }
  }

  function updateCompass() {
    const az = controls.getAzimuthalAngle();
    const deg = -THREE.MathUtils.radToDeg(az);
    compass.style.transform = `rotate(${deg}deg)`;
  }

  function fitCameraToYard(yardLength, yardWidth, maxHeight, fillRatio = 1.0) {
    const size = new THREE.Vector3(yardLength, maxHeight, yardWidth);
    const radius = size.length() / 2;
    const vFov = THREE.MathUtils.degToRad(camera.fov);
    const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect);
    const distV = radius / Math.tan(vFov / 2);
    const distH = radius / Math.tan(hFov / 2);
    const distance = Math.max(distV, distH) * fillRatio;

    const az = controls.getAzimuthalAngle();
    const phi = controls.getPolarAngle();
    const target = new THREE.Vector3(0, Math.max(0, maxHeight * 0.5), 0);
    controls.target.copy(target);
    camera.position.set(
      target.x + distance * Math.sin(phi) * Math.sin(az),
      target.y + distance * Math.cos(phi),
      target.z + distance * Math.sin(phi) * Math.cos(az)
    );
    camera.updateProjectionMatrix();

    controls.minDistance = Math.max(10, distance * 0.35);
    controls.maxDistance = distance * 3.0;
    controls.update();
  }

  function buildYardGrid(length, width) {
    const size = Math.max(length, width);
    const divisions = size / 10;
    const grid = new THREE.GridHelper(size, divisions, 0xaaaaaa, 0xcccccc);
    grid.scale.z = width / length;
    scene.add(grid);

    const halfL = length / 2, halfW = width / 2;
    const borderPts = [
      [-halfL, 0, -halfW], [halfL, 0, -halfW],
      [halfL, 0, halfW], [-halfL, 0, halfW],
      [-halfL, 0, -halfW]
    ].map(([x, y, z]) => new THREE.Vector3(x, y, z));
    const geom = new THREE.BufferGeometry().setFromPoints(borderPts);
    const border = new THREE.Line(geom, new THREE.LineBasicMaterial({color: 0x888888}));
    scene.add(border);
  }

  function buildMainRoad(roadWidth, length) {
    const halfL = length / 2;
    const halfW = roadWidth / 2;
    const sidewalk = 3;
    const laneEdge = halfW - sidewalk;

    const y = 0.02;
    const mkLine = (pts, material) => {
      const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p[0], y, p[1])));
      const line = new THREE.Line(g, material);
      return line;
    };

    const baseMat = new THREE.LineBasicMaterial({color: 0x444444});
    const dashedMat = new THREE.LineDashedMaterial({color: 0x888888, dashSize: 10, gapSize: 6});

    scene.add(mkLine([[-halfL, -halfW], [halfL, -halfW]], baseMat.clone()));
    scene.add(mkLine([[-halfL, halfW], [halfL, halfW]], baseMat.clone()));
    scene.add(mkLine([[-halfL, -laneEdge], [halfL, -laneEdge]], baseMat.clone()));
    scene.add(mkLine([[-halfL, laneEdge], [halfL, laneEdge]], baseMat.clone()));

    const gCenter = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-halfL, y, 0), new THREE.Vector3(halfL, y, 0)
    ]);
    const centerLine = new THREE.Line(gCenter, dashedMat);
    centerLine.computeLineDistances();
    scene.add(centerLine);
  }

  function buildSidewalkTrees(roadWidth, length, spacing = 10) {
    const halfL = length / 2;
    const halfW = roadWidth / 2;
    const sidewalk = 3;
    const zOnSidewalk = halfW - sidewalk / 2;

    for (let x = -halfL; x <= halfL + 1e-6; x += spacing) {
      addTree(x, zOnSidewalk);
      addTree(x, -zOnSidewalk);
    }

    function addTree(x, z) {
      const group = new THREE.Group();
      const trunkH = 6;
      const canopyH = 2;

      const trunkGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, trunkH, 0)
      ]);
      const trunk = new THREE.Line(trunkGeom, new THREE.LineBasicMaterial({color: lineColors.tree}));
      group.add(trunk);

      const coneGeo = new THREE.ConeGeometry(1.4, canopyH, 10);
      const edges = new THREE.EdgesGeometry(coneGeo);
      const canopy = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: lineColors.tree}));
      canopy.position.y = trunkH + canopyH / 2;
      group.add(canopy);

      group.position.set(x, 0, z);
      scene.add(group);
    }
  }

  function buildWarehouse({length, width, height, roofHeight}, centerX, centerZ, index) {
    const group = new THREE.Group();
    group.position.set(centerX, 0, centerZ);

    const wall = createWireframe(new THREE.BoxGeometry(length, height, width), lineColors.wall);
    wall.position.set(0, height / 2, 0);
    wall.userData = {type: '仓库', 序号: index + 1, 长: length, 宽: width, 高: height};
    group.add(wall);

    const hx = length / 2, hz = width / 2, yTop = height, yRidge = height + roofHeight;
    const roofColor = lineColors.roof;
    const roofLines = [];
    roofLines.push([[-hx, yTop, -hz], [0, yRidge, -hz], [hx, yTop, -hz], [-hx, yTop, -hz]]);
    roofLines.push([[-hx, yTop, hz], [0, yRidge, hz], [hx, yTop, hz], [-hx, yTop, hz]]);
    roofLines.push([[-hx, yRidge, 0], [hx, yRidge, 0]]);
    roofLines.push([[-hx, yTop, -hz], [-hx, yTop, hz]]);
    roofLines.push([[hx, yTop, -hz], [hx, yTop, hz]]);

    for (const pts of roofLines) {
      const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p[0], p[1], p[2])));
      const line = new THREE.Line(g, new THREE.LineBasicMaterial({color: roofColor}));
      group.add(line);
    }

    const idChar = String.fromCharCode(65 + (index % 26));
    const area = length * width;
    const services = random.subset(['熏蒸', '干燥', '复核堆芯温度']);
    const temperature = random.float(12, 28).toFixed(1);
    const phone = random.phone();
    group.userData.whInfo = {id: `#${idChar}`, area, temperature, services, phone};

    const labelEl = document.createElement('div');
    labelEl.className = 'whLabel';
    labelEl.textContent = group.userData.whInfo.id;
    const labelObj = new CSS2DObject(labelEl);
    labelObj.position.set(0, height + roofHeight + 6, 0);
    group.add(labelObj);

    scene.add(group);
    return group;
  }

  document.addEventListener('click', (e) => {
    if (e.target && (e.target.closest && e.target.closest('#actionBar'))) return;
    if (e.target && (e.target.closest && e.target.closest('#modelPanel'))) return;
    whPanel.style.display = 'none';
    clearSelection();
  });

  let stackIdSeq = 1;

  function populateStacks(warehouseGroup, wConf, stackConf, index) {
    const {length, width, height} = wConf;
    const {length: sx, width: sz, height: sy} = stackConf.stackSize;

    const center = new THREE.Vector3();
    warehouseGroup.getWorldPosition(center);
    const cx = center.x, cz = center.z;

    // 只生成一个堆垛在仓库中心
    const stack = createWireframe(new THREE.BoxGeometry(sx, sy, sz), lineColors.stack);
    stack.position.set(cx, sy / 2, cz);
    stack.material = new THREE.LineBasicMaterial({color: lineColors.stack});
    const vol = (sx * sy * sz).toFixed(0);
    const id = stackIdSeq++;
    const isJF = Math.random() < 0.2;
    const whInfo = warehouseGroup.userData?.whInfo || null;

    const 委托客户 = random.pick(['建发', '国贸']);
    const 货权方 = random.pick(['广东粮油', '中国粮食']);
    const 货类 = random.pick(['袋装玉米', '袋装小麦', '袋装鱼粉']);
    // 15% 的概率生成空堆垛
    const 当前质量 = Math.random() < 0.15 ? '0.0' : random.float(5, 50).toFixed(1);
    const 入库 = random.dateWithinDays(180);
    const 出库 = random.dateBetween(入库, new Date());

    stack.userData = {
      type: '堆垛', id,
      owner: isJF ? 'JF' : undefined,
      仓库序号: index + 1,
      体积_m3: vol,
      尺寸_m: `${sx}×${sy}×${sz}`,
      委托客户,
      货权方,
      货类,
      当前质量_t: 当前质量,
      最后入库时间: random.fmtDate(入库),
      最后出库时间: random.fmtDate(出库),
      whInfo
    };
    setStackColor(stack, isJF ? lineColors.ownerJF : lineColors.stack);

    scene.add(stack);
    registerPickable(stack);

    // 只有有货物的堆垛才能交互
    if (parseFloat(当前质量) > 0) {
      registerInteractive(stack);
    }
  }

  // 交互逻辑
  const raycaster = new THREE.Raycaster();
  raycaster.params.Line.threshold = 2;
  const mouse = new THREE.Vector2();
  function resolveInteractiveTarget(object) {
    let current = object;
    let depth = 0;
    const maxDepth = 10; // 限制遍历深度，避免无限循环
    
    while (current && depth < maxDepth) {
      // 检查当前对象是否在可交互集合中
      if (interactiveSet.has(current)) {
        const userData = current.userData;
        if (userData?.type === '筒仓' || userData?.type === '星仓') {
          // 筒仓/星仓无论是否有数据都可以悬停显示名称
          return current;
        } else if (userData?.type === '堆垛') {
          // 堆垛必须有非零质量才可交互
          const 质量 = parseFloat(userData?.当前质量_t || '0');
          if (质量 > 0) {
            return current;
          }
        }
      }
      current = current.parent;
      depth++;
    }
    return null;
  }

  function showHoverInfo(obj, clientX, clientY) {
    // 移除权限检查，所有对象都可以显示悬停信息

    const type = obj.userData?.type;
    if (type === '筒仓' || type === '星仓') {
      const cap = obj.userData?.最大容量_t || '-';
      const current = obj.userData?.当前储量_t || '0';
      const materials = obj.userData?.物料详情 || [];
      const label = type === '星仓' ? '★星仓' : '筒仓';
      
      let materialInfo = '';
      if (materials.length > 0) {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px;">';
        materials.forEach(m => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          console.log(`悬停面板颜色: 公司=${m.company}, 原始颜色=${m.companyColor}, 解析结果=${companyColor}`);
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          materialInfo += `<div style="margin: 2px 0; display: flex; align-items: center;">
            <div style="width: 10px; height: 10px; background: ${companyColor}; border-radius: 2px; margin-right: 6px; border: 1px solid #ccc;"></div>
            <span style="color: ${companyColor}; font-weight: bold;">${m.company}: <span style="${amountStyle}">${negativeIcon}${m.amount}吨</span> ${m.material}</span>
          </div>`;
        });
        materialInfo += '</div>';
      } else {
        // 当没有物料数据时显示空仓状态
        materialInfo = '<div style="margin-top: 6px; font-size: 12px; color: #888;">暂无物料数据</div>';
      }
      
      infoPanel.innerHTML = `
        <div><b>${label} ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>容量: ${cap} 吨</div>
        <div>当前: ${current} 吨</div>
        ${materialInfo}
      `;
    } else {
      const v = obj.userData?.体积_m3;
      infoPanel.innerHTML = `<div><b>堆垛 ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div><div>体积: ${v} m³</div>`;
    }

    infoPanel.style.display = 'block';
    infoPanel.style.left = (clientX + 14) + 'px';
    infoPanel.style.top = (clientY + 14) + 'px';
  }

  function hideHoverInfo() {
    infoPanel.style.display = 'none';
  }

  // 数字解析：去掉空格/单位，只留数字和小数点、负号
function toNumber(v) {
  if (v == null) return NaN;
  if (typeof v === 'number') return v;
  return parseFloat(String(v).replace(/[^\d.\-]/g, ''));
}

// 是否有有效物料（绝对值 > 0）
function hasActiveMaterials(materialDetails) {
  if (!Array.isArray(materialDetails)) return false;
  return materialDetails.some(item => Number.isFinite(toNumber(item?.amount)) && Math.abs(toNumber(item.amount)) > 1e-6);
}


function setStackColor(obj, color) {
    if (!obj) return;

    const type = obj.userData?.type;
    const isCylindricalSilo = type === '筒仓';
    const isStarSilo = type === '星仓';
    const isSilo = isCylindricalSilo || isStarSilo;
    const hasMaterialData = obj.userData?.hasMaterialData === true;

    let targetColor = color;
    if (isSilo && !hasMaterialData) {
      const looksLikeCompanyTint =
        color === lineColors.silo ||
        color === lineColors.siloOwnerJF ||
        color === lineColors.starSilo ||
        color === lineColors.starSiloOwnerJF;
      if (looksLikeCompanyTint) {
        targetColor = emptySiloColor;
      }
    }

    if (isSilo) {
      // 为筒仓/星仓设置颜色 - 同步主体与线框材质
      const isClickable = hasMaterialData; // 有物料数据的筒仓可以点击
      
      obj.children.forEach(child => {
        if (!child.material) return;
        
        // 检查是否是屋顶
        const isRoof = child.userData?.isRoof === true;
        
        if (child.material.type === 'LineBasicMaterial') {
          child.material.color.set(targetColor);
        } else if (child.material.type === 'MeshStandardMaterial') {
          if (isRoof) {
            // 屋顶颜色逻辑：可点击的为绿色，不可点击的为深灰色
            const roofColor = isClickable ? 0x33bb33 : 0xd7d7d7;
            child.material.color.set(roofColor);
          } else {
            // 非屋顶部分使用目标颜色
            child.material.color.set(targetColor);
          }
        }
      });
    } else if (obj.material) {
      // 为堆垛设置颜色
      obj.material.color.set(targetColor);
    }
  }

function getStackBaseColor(obj) {
    const type = obj?.userData?.type;
    const owner = obj?.userData?.owner;
    const showCompanyColor = obj?.userData?.hasMaterialData === true;
    const isCylindricalSilo = type === '筒仓';
    const isStarSilo = type === '星仓';

    if (isCylindricalSilo) {
      if (!showCompanyColor) {
        return emptySiloColor;
      }
      return owner === 'JF' ? lineColors.siloOwnerJF : lineColors.silo;
    }
  if (isStarSilo) {
    if (!showCompanyColor) {
      return emptySiloColor; // 空星仓使用灰色
    }
    return owner === 'JF' ? lineColors.starSiloOwnerJF : lineColors.starSilo;
  }
    if (!showCompanyColor) {
      return lineColors.stack;
    }
    return owner === 'JF' ? lineColors.ownerJF : lineColors.stack;
  }

function getSiloHoverColor(obj) {
    const type = obj?.userData?.type;
    if (type === '星仓') {
      return lineColors.starSiloHover;
    }
    return lineColors.siloHover;
  }

function getSiloSelectedColor(obj) {
    const type = obj?.userData?.type;
    if (type === '星仓') {
      return lineColors.starSiloSelected;
    }
    return lineColors.siloSelected;
  }

  function clearHover() {
    if (hovered && hovered !== selected) {
      setStackColor(hovered, getStackBaseColor(hovered));
    }
    hovered = null;
    hideHoverInfo();
  }

  function layoutInfoPanels() {
    const gap = 12;
    const detailShown = detailPanel.style.display !== 'none';
    const whShown = whPanel.style.display !== 'none';
    detailPanel.style.bottom = '16px';
    whPanel.style.bottom = '16px';
    if (detailShown && whShown) {
      const h = detailPanel.offsetHeight || detailPanel.getBoundingClientRect().height || 0;
      whPanel.style.bottom = (16 + h + gap) + 'px';
    }
  }

  function updateActionBar() {
    if (selected) {
      actionBar.classList.add('show'); // 移除权限检查，选中任何对象都显示操作按钮
    } else {
      actionBar.classList.remove('show');
    }
  }

  function updateDetailPanel() {
    if (!selected) {
      detailPanel.style.display = 'none';
      modelPanel.style.display = 'none';
      updateActionBar();
      return;
    }
    const wp = new THREE.Vector3();
    selected.getWorldPosition(wp);
    const ud = selected.userData || {};

    if (ud.type === '筒仓' || ud.type === '星仓') {
      const typeLabel = ud.type === '星仓' ? '★星仓详情' : '筒仓详情';
      const materials = ud.物料详情 || [];
      
      // 显示筒仓/星仓的3D模型
      showSiloModel(selected);
      
      let materialsHtml = '';
      if (materials.length > 0) {
        materialsHtml = '<div style="margin-top: 8px;"><b>物料详情:</b></div>';
        materials.forEach((m, index) => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          console.log(`详情面板颜色: 公司=${m.company}, 原始颜色=${m.companyColor}, 解析结果=${companyColor}`);
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          const negativeLabel = isNegative ? ' (出库)' : '';
          materialsHtml += `
            <div style="background: #f8f9fa; padding: 6px; margin: 4px 0; border-radius: 4px; border-left: 3px solid ${companyColor};">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <div style="width: 12px; height: 12px; background: ${companyColor}; border-radius: 2px; margin-right: 8px; border: 1px solid #ccc;"></div>
                <span style="font-weight: bold; color: ${companyColor};">${m.company}${negativeLabel}</span>
              </div>
              <div style="font-size: 13px;">物料: ${m.material} | 数量: <span style="${amountStyle}">${negativeIcon}${m.amount} 吨</span></div>
              <div style="font-size: 12px; color: #666;">
                入库: ${m.storageDate} | 等级: ${m.qualityGrade}<br/>
                水分: ${m.moistureContent} | 温度: ${m.temperature}
              </div>
            </div>
          `;
        });
      } else {
        materialsHtml = '<div style="margin-top: 8px; color: #888;">暂无物料</div>';
      }
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">${typeLabel} ${ud.编号 || '#' + ud.id}</div>
        ${ud.特殊标识 ? `<div style="color: #FFD700; font-weight: bold; text-align: center; margin-bottom: 6px;">${ud.特殊标识}</div>` : ''}        <div>半径: ${ud.半径_m} 米</div>
        <div>高度: ${ud.高度_m} 米</div>
        <div>容积: ${ud.容积_m3} m³</div>
        <div>最大容量: ${ud.最大容量_t} 吨</div>
        <div>主要货类: ${ud.货类 || '-'}</div>
        <div>当前储量: ${ud.当前储量_t || '-'} 吨</div>
        <div>入仓时间: ${ud.入仓时间 || '-'}</div>
        <div>仓内温度: ${ud.仓内温度_c || '-'} ℃</div>
        <div>仓内湿度: ${ud.仓内湿度_percent || '-'}%</div>
        <div>状态: ${ud.状态 || '-'}</div>
        ${materialsHtml}
        <div style="margin-top: 8px; font-size: 12px; color: #666;">位置(米): X=${wp.x.toFixed(1)}, Y=${wp.y.toFixed(1)}, Z=${wp.z.toFixed(1)}</div>
      `;
    } else {
      // 如果不是筒仓/星仓，隐藏模型面板
      modelPanel.style.display = 'none';
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">堆垛详情 #${ud.id}</div>
        <div>最大堆叠体积: ${ud.体积_m3} m³</div>
        <div>最大堆叠尺寸: ${ud.尺寸_m}</div>
        <div>所在仓库: #${ud.仓库序号}</div>
        <div>委托客户: ${ud.委托客户 || '-'}</div>
        <div>货权方: ${ud.货权方 || '-'}</div>
        <div>货类: ${ud.货类 || '-'}</div>
        <div>当前质量: ${ud.当前质量_t || '-'} 吨</div>
        <div>最后入库时间: ${ud.最后入库时间 || '-'}</div>
        <div>最后出库时间: ${ud.最后出库时间 || '-'}</div>
        <div>位置(米): X=${wp.x.toFixed(1)}, Y=${wp.y.toFixed(1)}, Z=${wp.z.toFixed(1)}</div>
      `;
    }

    detailPanel.style.display = 'block';
    layoutInfoPanels();
    updateActionBar();
  }

  function handlePointerMove(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    // 对所有可交互对象进行射线检测，获取所有相交点
    const allHits = raycaster.intersectObjects(raycastTargets, true);
    let target = null;

    // 只考虑最近的第一个交互对象，避免穿透空筒仓命中后方目标
    if (allHits.length > 0) {
      target = resolveInteractiveTarget(allHits[0].object);
    }
    if (target) {
      if (hovered !== target) {
        if (hovered && hovered !== selected) setStackColor(hovered, getStackBaseColor(hovered));
        hovered = target;
      }
      if (hovered !== selected) {
        const hoveredType = hovered.userData?.type;
        const hoverColor = (hoveredType === '筒仓' || hoveredType === '星仓') ? getSiloHoverColor(hovered) : lineColors.hover;
        setStackColor(hovered, hoverColor);
      }
      showHoverInfo(target, e.clientX, e.clientY);
    } else {
      clearHover();
    }
  }

  function handleClick(e) {
    // 事件冒泡已在调用此函数前被阻止，这里不需要再次处理
    if (!hovered) return; // 移除权限检查，只要有悬停对象就可以点击
    if (selected === hovered) {
      clearSelection();
      return;
    }
    if (selected) setStackColor(selected, getStackBaseColor(selected));
    selected = hovered;
    const selectedType = selected.userData?.type;
    const selectedColor = (selectedType === '筒仓' || selectedType === '星仓') ? getSiloSelectedColor(selected) : lineColors.selected;
    setStackColor(selected, selectedColor);
    updateDetailPanel();
    const info = selected.userData?.whInfo;
    if (info) {
      whPanel.innerHTML = `
          <div style="font-weight:600;margin-bottom:6px;">仓库 ${info.id}</div>
          <div>面积: ${info.area} m²</div>
          <div>仓内温度: ${info.temperature} ℃</div>
          <div>增值作业: ${info.services.join('、')}</div>
          <div>当日值勤: ${info.phone}</div>
        `;
      whPanel.style.display = 'block';
      layoutInfoPanels();
    } else {
      whPanel.style.display = 'none';
    }
    updateActionBar();
  }

  renderer.domElement.addEventListener('mousemove', handlePointerMove);
  renderer.domElement.addEventListener('mouseleave', clearHover);
  // 统一的点击处理函数，避免多重事件监听器导致的冒泡问题
  renderer.domElement.addEventListener('click', (ev) => {
    // 阻止事件冒泡和默认行为
    ev.stopPropagation();
    ev.preventDefault();
    
    // 处理对象选择逻辑
    if (hovered) {
      handleClick(ev);
    } else {
      clearSelection();
    }
    
  });

  function clearSelection() {
    if (!selected) {
      updateActionBar();
      return;
    }
    setStackColor(selected, getStackBaseColor(selected));
    selected = null;
    updateDetailPanel();
    updateActionBar();
    whPanel.style.display = 'none';
    modelPanel.style.display = 'none';
  }

  btnLfs.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '堆垛';
    alert(`查看LFS订单：${type} #${id}`);
  });
  btnTms.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '堆垛';
    alert(`查看相关TMS运输订单：${type} #${id}`);
  });
  btnFee.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '堆垛';
    const feeType = (type === '筒仓' || type === '星仓') ? '筒仓仓储费用' : '堆垛仓储费用';
    alert(`查看${feeType}：${type} #${id}`);
  });

  // 监控按钮事件监听
  btnMonitor.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const userData = selected.userData;
    const type = userData?.type;
    
    // 只有筒仓和星仓才有监控功能
    if (type === '筒仓' || type === '星仓') {
      showMonitorPanel(userData);
    } else {
      alert('只有筒仓和星仓支持监控查看功能');
    }
  });

  // 监控面板控制按钮事件监听
  monitorClose.addEventListener('click', closeMonitorPanel);

  playBtn.addEventListener('click', () => {
    if (flvPlayer && monitorVideo.paused) {
      flvPlayer.play().catch(e => {
        console.error('播放失败:', e);
      });
    }
  });

  pauseBtn.addEventListener('click', () => {
    if (flvPlayer && !monitorVideo.paused) {
      flvPlayer.pause();
    }
  });

  fullscreenBtn.addEventListener('click', () => {
    if (monitorVideo.requestFullscreen) {
      monitorVideo.requestFullscreen();
    } else if (monitorVideo.webkitRequestFullscreen) {
      monitorVideo.webkitRequestFullscreen();
    } else if (monitorVideo.msRequestFullscreen) {
      monitorVideo.msRequestFullscreen();
    }
  });

  // 点击面板外部关闭监控面板
  document.addEventListener('click', (e) => {
    if (monitorPanel.style.display === 'block' && 
        !monitorPanel.contains(e.target) && 
        e.target !== btnMonitor) {
      closeMonitorPanel();
    }
  });

  function onResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    labelRenderer.setSize(w, h);

    // 调整模型渲染器大小
    if (modelRenderer) {
      const modelWidth = 248;
      const modelHeight = 160;
      modelCamera.aspect = modelWidth / modelHeight;
      modelCamera.updateProjectionMatrix();
      modelRenderer.setSize(modelWidth, modelHeight);
    }

    layoutInfoPanels();
  }

  window.addEventListener('resize', onResize);

  controls.addEventListener('change', () => {
    updateCompass();
  });

  // 筒仓构建函数
  function buildSiloWireframe(radius, height, radialSegments = 24) {
    const cyl = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 1, false);
    const edges = new THREE.EdgesGeometry(cyl);
    const mat = new THREE.LineBasicMaterial({color: lineColors.silo});
    const mesh = new THREE.LineSegments(edges, mat);
    mesh.position.y = height / 2;
    return mesh;
  }

  function buildSiloMesh(radius, height, materials = [], radialSegments = 32) {
    const group = new THREE.Group();

    // 如果没有物料数据，创建空筒仓
    if (!materials || materials.length === 0) {
      const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 8, false);
      const mat = new THREE.MeshStandardMaterial({
        color: emptySiloColor,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = height / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);
      return group;
    }

    // 分离正数和负数物料，3D模型只显示正数物料
    const positiveMaterials = materials.filter(m => parseFloat(m.amount) > 0);
    
    // 如果没有正数物料，显示为空仓
    if (positiveMaterials.length === 0) {
      const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 8, false);
      const mat = new THREE.MeshStandardMaterial({
        color: emptySiloColor,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = height / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);
      return group;
    }
    
    const totalAmount = positiveMaterials.reduce((sum, m) => sum + parseFloat(m.amount), 0);
    let currentY = 0;

    // 为每个公司的正数物料创建分段
    positiveMaterials.forEach((material, index) => {
      const proportion = parseFloat(material.amount) / totalAmount;
      const segmentHeight = height * proportion * 0.8; // 0.8是填充率
      
      if (segmentHeight > 0.1) { // 只显示足够高的分段
        const geo = new THREE.CylinderGeometry(radius, radius, segmentHeight, radialSegments, 1, false);
        const colorData = parseColor(material.companyColor);
        const companyColor = colorData.hex || emptySiloColor;
        
        const mat = new THREE.MeshStandardMaterial({
          color: companyColor,
          roughness: 0.9,
          metalness: 0.05,
          flatShading: false
        });
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = currentY + segmentHeight / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = {
          company: material.company,
          material: material.material,
          amount: material.amount
        };
        
        group.add(mesh);
        currentY += segmentHeight;
      }
    });

    // 如果有剩余空间，添加空的顶部分段
    if (currentY < height) {
      const emptyHeight = height - currentY;
      const geo = new THREE.CylinderGeometry(radius, radius, emptyHeight, radialSegments, 1, false);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xF0F0F0, // 浅灰色表示空仓
        roughness: 0.95,
        metalness: 0.02,
        flatShading: false,
        transparent: true,
        opacity: 0.3
      });
      
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = currentY + emptyHeight / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { isEmpty: true };
      
      group.add(mesh);
    }

    return group;
  }

  function buildSiloRoof(radius, height = 3) {
    const geo = new THREE.ConeGeometry(radius * 1.05, height, 24);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xD0D0D0, // 更亮的灰色，避免看起来太黑
      roughness: 0.6,
      metalness: 0.2
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    mesh.receiveShadow = true; // 添加接受阴影，让光照更自然
    mesh.userData = { isRoof: true }; // 标识这是屋顶
    return mesh;
  }

  function buildSiloLadder(radius, height) {
    const points = [];
    const turns = height / 15;
    const segments = Math.ceil(turns * 32);

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const angle = t * turns * Math.PI * 2;
      const y = t * height;
      const x = Math.cos(angle) * (radius + 0.3);
      const z = Math.sin(angle) * (radius + 0.3);
      points.push(new THREE.Vector3(x, y, z));
    }

    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 2 });
    return new THREE.Line(geo, mat);
  }

  function buildConnectingBridge(x1, z1, x2, z2, height) {
    const dx = x2 - x1;
    const dz = z2 - z1;
    const len = Math.sqrt(dx * dx + dz * dz);
    const angle = Math.atan2(dz, dx);

    const geo = new THREE.CylinderGeometry(0.4, 0.4, len, 8);
    const mat = new THREE.MeshStandardMaterial({
      color: 0x808080,
      roughness: 0.6,
      metalness: 0.4
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.z = Math.PI / 2;
    mesh.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
    mesh.rotation.y = angle;
    return mesh;
  }

  let siloIdSeq = 1;
  
  // 星仓编号计数器 - 全局声明
  let starSiloRowIndex = 0;
  let starSiloColIndex = 0;
  
  // 筒仓编号映射表 - 按照用户提供的精确格式
  const siloNumberMap = {
    // 所有筒仓编号 - 按照用户指定的顺序排列
    silo: [
      ['T105', 'T205', 'T305', 'T405'],
      ['T503', 'T603', 'T703', 'T803'],
      ['T104', 'T204', 'T304', 'T404'],
      ['T502', 'T602', 'T702', 'T802'],
      ['T103', 'T203', 'T303', 'T403'],
      ['T501', 'T601', 'T701', 'T801'],
      ['T102', 'T202', 'T302', 'T402'],
      ['T101', 'T201', 'T301', 'T401'],
    ],
    // 星仓编号 - 按照实际创建顺序分配（共18个）
    starSilo: [
      // 第一组（一排星仓）：4个星仓 - 对应代码第2547-2551行
      ['X104', 'X101', 'X103', 'X102'],
      // 第二组（二排星仓）：4个星仓 - 对应代码第2552-2556行
      ['X204', 'X203', 'X202', 'X201'],
      // 第三组（三排星仓）：4个星仓 - 对应代码第2557-2561行
      ['X304', 'X303', 'X302', 'X301'],
      // 第四组（四排星仓）：2个星仓 - 对应代码第2562-2564行
      ['X402', 'X401'],
      // 第五组（五排星仓）：2个星仓 - 对应代码第2565-2567行
      ['X502', 'X501'],
      // 第六组（六排星仓）：2个星仓 - 对应代码第2568-2570行
      ['X602', 'X601']
    ]
  };

  // ================== 星仓位置与编号对应关系说明 ==================
  /**
   * 星仓布局说明（共18个星仓）：
   * 
   * 根据用户提供的编号规则和实际代码创建顺序：
   * 
   * 第一组（一排星仓，X=-31.92）：4个星仓
   * - X104: 位置(-31.92, -24.30, 49) - 代码第2548行
   * - X101: 位置(-31.92, -56.50, 49) - 代码第2549行  
   * - X103: 位置(-31.92, -35.00, 49) - 代码第2550行
   * - X102: 位置(-31.92, -45.00, 49) - 代码第2551行
   * 
   * 第二组（二排星仓，X≈-21.92）：4个星仓
   * - X204: 位置(-21.92, -24.30, 49) - 代码第2553行
   * - X203: 位置(-21.92, -35.00, 49) - 代码第2554行
   * - X202: 位置(-21.92, -45.50, 49) - 代码第2555行
   * - X201: 位置(-22.92, -56.50, 49) - 代码第2556行
   * 
   * 第三组（三排星仓，X≈-11.92）：4个星仓
   * - X304: 位置(-11.92, -24.30, 49) - 代码第2558行
   * - X303: 位置(-11.92, -35.00, 49) - 代码第2559行
   * - X302: 位置(-11.92, -45.50, 49) - 代码第2560行
   * - X301: 位置(-12.92, -56.50, 49) - 代码第2561行
   * 
   * 第四组（四排星仓，X=8.92）：2个星仓
   * - X402: 位置(8.92, -24.30, 49) - 代码第2563行
   * - X401: 位置(8.92, -35.00, 49) - 代码第2564行
   * 
   * 第五组（五排星仓，X=18.92）：2个星仓
   * - X502: 位置(18.92, -24.30, 49) - 代码第2566行
   * - X501: 位置(18.92, -35.00, 49) - 代码第2567行
   * 
   * 第六组（六排星仓，X=28.92）：2个星仓
   * - X602: 位置(28.92, -24.30, 49) - 代码第2569行
   * - X601: 位置(28.92, -35.00, 49) - 代码第2570行
   * 
   * 编号规则：
   * - 格式：X + 数字编号（X101-X602）
   * - 第一位数字：表示排号（1-6）
   * - 第二、三位数字：表示该排内的序号（01-04）
   * - 编号按照实际创建顺序分配，确保与代码中的placeStarSilo调用顺序一致
   */

  /**
   * 星仓编号验证和查询功能
   */
  
  // 调试：检查场景中的星仓对象
  function debugStarSilos() {
    const starSilos = [];
    scene.traverse((child) => {
      if (child.userData?.type === '星仓') {
        starSilos.push({
          编号: child.userData.编号 || child.userData.id,
          位置: {
            x: child.position.x.toFixed(2),
            y: child.position.y.toFixed(2), 
            z: child.position.z.toFixed(2)
          },
          状态: child.userData.状态,
          数据来源: child.userData.数据来源
        });
      }
    });
    
    console.log('=== 场景中的星仓对象 ===');
    console.log(`找到 ${starSilos.length} 个星仓:`);
    starSilos.forEach((silo, index) => {
      console.log(`${index + 1}. ${silo.编号} - 位置(${silo.位置.x}, ${silo.位置.y}, ${silo.位置.z}) - 状态: ${silo.状态} - 数据来源: ${silo.数据来源}`);
    });
    
    // 检查缺失的星仓
    const expectedSilos = siloNumberMap.starSilo.flat();
    const foundSilos = starSilos.map(s => s.编号);
    const missingSilos = expectedSilos.filter(expected => !foundSilos.includes(expected));
    
    if (missingSilos.length > 0) {
      console.log(`\n⚠️ 缺失的星仓: ${missingSilos.join(', ')}`);
    } else {
      console.log(`\n✅ 所有星仓都已创建`);
    }
    
    return { found: starSilos, missing: missingSilos };
  }
  
  // 将调试函数暴露到全局
  window.debugStarSilos = debugStarSilos;
  
  /**
   * 调试星仓编号分配过程
   */
  function debugStarSiloNumbering() {
    console.log('=== 星仓编号分配调试 ===');
    console.log(`当前星仓行索引: ${starSiloRowIndex}`);
    console.log(`当前星仓列索引: ${starSiloColIndex}`);
    console.log('星仓编号映射表:');
    siloNumberMap.starSilo.forEach((group, index) => {
      console.log(`  第${index + 1}组: [${group.join(', ')}]`);
    });
    
    // 模拟下一个星仓编号分配
    if (starSiloRowIndex < siloNumberMap.starSilo.length && starSiloColIndex < siloNumberMap.starSilo[starSiloRowIndex].length) {
      const nextNumber = siloNumberMap.starSilo[starSiloRowIndex][starSiloColIndex];
      console.log(`下一个分配的编号: ${nextNumber}`);
    } else {
      console.log('已超出预定义编号范围，将使用自动生成编号');
    }
  }
  
  // 暴露到全局
  window.debugStarSiloNumbering = debugStarSiloNumbering;
  
  /**
   * 重置星仓编号计数器
   */
  function resetStarSiloCounters() {
    starSiloRowIndex = 0;
    starSiloColIndex = 0;
    console.log('星仓编号计数器已重置');
    debugStarSiloNumbering();
  }
  
  // 暴露到全局
  window.resetStarSiloCounters = resetStarSiloCounters;
  function validateStarSiloNumbering() {
    const expectedTotal = 18;
    const actualTotal = siloNumberMap.starSilo.flat().length;
    
    console.log('=== 星仓编号验证 ===');
    console.log(`预期总数: ${expectedTotal}`);
    console.log(`实际总数: ${actualTotal}`);
    console.log(`验证结果: ${actualTotal === expectedTotal ? '✓ 通过' : '✗ 失败'}`);
    
    // 打印每组编号
    siloNumberMap.starSilo.forEach((group, index) => {
      console.log(`第${index + 1}组: [${group.join(', ')}] (${group.length}个)`);
    });
    
    return actualTotal === expectedTotal;
  }

  /**
   * 根据编号获取星仓位置信息（调试用）
   */
  function getStarSiloPositionByNumber(number) {
    // 位置映射表（与代码中的placeStarSilo调用对应）
    const positionMap = {
      // 第一组
      'X104': { x: -31.92, y: -24.30, z: 49, line: 2548 },
      'X101': { x: -31.92, y: -56.50, z: 49, line: 2549 },
      'X103': { x: -31.92, y: -35.00, z: 49, line: 2550 },
      'X102': { x: -31.92, y: -45.00, z: 49, line: 2551 },
      // 第二组
      'X204': { x: -21.92, y: -24.30, z: 49, line: 2553 },
      'X203': { x: -21.92, y: -35.00, z: 49, line: 2554 },
      'X202': { x: -21.92, y: -45.50, z: 49, line: 2555 },
      'X201': { x: -22.92, y: -56.50, z: 49, line: 2556 },
      // 第三组
      'X304': { x: -11.92, y: -24.30, z: 49, line: 2558 },
      'X303': { x: -11.92, y: -35.00, z: 49, line: 2559 },
      'X302': { x: -11.92, y: -45.50, z: 49, line: 2560 },
      'X301': { x: -12.92, y: -56.50, z: 49, line: 2561 },
      // 第四组
      'X402': { x: 8.92, y: -24.30, z: 49, line: 2563 },
      'X401': { x: 8.92, y: -35.00, z: 49, line: 2564 },
      // 第五组
      'X502': { x: 18.92, y: -24.30, z: 49, line: 2566 },
      'X501': { x: 18.92, y: -35.00, z: 49, line: 2567 },
      // 第六组
      'X602': { x: 28.92, y: -24.30, z: 49, line: 2569 },
      'X601': { x: 28.92, y: -35.00, z: 49, line: 2570 }
    };
    
    return positionMap[number] || null;
  }


  
  // 筒仓编号计数器
  let siloRowIndex = 0;
  let siloColIndex = 0;

  function createStarOutlinePoints(outerRadius, innerRadius, arms = 5) {
    const pts = [];
    const total = arms * 2;
    for (let i = 0; i < total; i++) {
      const angle = (i / total) * Math.PI * 2 - Math.PI / 2;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      pts.push(new THREE.Vector2(Math.cos(angle) * radius, Math.sin(angle) * radius));
    }
    return pts;
  }

  function computePolygonArea2D(points) {
    let area = 0;
    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % points.length];
      area += p1.x * p2.y - p2.x * p1.y;
    }
    return Math.abs(area) / 2;
  }

  function buildStarSiloBody(outerRadius, innerRadius, height, materials = [], arms = 5) {
    const outline = createStarOutlinePoints(outerRadius, innerRadius, arms);
    const shape = new THREE.Shape();
    shape.moveTo(outline[0].x, outline[0].y);
    for (let i = 1; i < outline.length; i++) {
      shape.lineTo(outline[i].x, outline[i].y);
    }
    shape.closePath();

    const extrude = new THREE.ExtrudeGeometry(shape, {
      steps: 1,
      depth: height,
      bevelEnabled: false
    });
    extrude.rotateX(-Math.PI / 2);
    extrude.translate(0, height / 2, 0);

    // 根据是否有物料决定颜色：空星仓用灰色，有物料用金色
    const hasMaterials = materials && materials.length > 0;
    const bodyColor = hasMaterials ? lineColors.starSilo : emptySiloColor;

    const bodyMat = new THREE.MeshStandardMaterial({
      color: bodyColor,
      roughness: 0.55,
      metalness: 0.25
    });
    const body = new THREE.Mesh(extrude, bodyMat);
    body.castShadow = true;
    body.receiveShadow = true;

    return {body, outline};
  }

  async function placeSilo(x, z, radius, height, addDetails = true) {
    const group = new THREE.Group();

    // 计算基本参数
    const volume = Math.PI * radius * radius * height;
    const capacity = (volume * 0.75).toFixed(1); // 假设密度0.75吨/立方米
    
    // 使用新的编号系统
    let siloNumber;
    if (siloRowIndex < siloNumberMap.silo.length && siloColIndex < siloNumberMap.silo[siloRowIndex].length) {
      siloNumber = siloNumberMap.silo[siloRowIndex][siloColIndex];
      siloColIndex++;
      if (siloColIndex >= siloNumberMap.silo[siloRowIndex].length) {
        siloColIndex = 0;
        siloRowIndex++;
      }
    } else {
      siloNumber = `T${siloIdSeq}`;
    }
    const siloId = siloIdSeq++;

    // 通过接口获取筒仓和物料数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: siloId,
        siloNumber: siloNumber, // 传递本地编号用于API数据查找
        siloType: '筒仓',
        radius: radius,
        height: height,
        volume: volume,
        capacity: capacity
      });
    } catch (error) {
      console.error(`获取筒仓 ${siloNumber} 数据失败:`, error);
      // 使用默认数据继续创建筒仓，避免完全失败
      apiData = {
        siloInfo: {
          id: siloNumber,
          type: '筒仓',
          radius: radius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '离线'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'fallback-default'
      };
    }

    const { siloInfo, materialDetails } = apiData;
    const activeMaterials = Array.isArray(materialDetails)
    ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6): [];
    const hasMaterialData = activeMaterials.length > 0;


    // 只有有物料数据时才传递物料详情，否则传递空数组
    const shell = buildSiloMesh(radius, height, activeMaterials);
    const outline = buildSiloWireframe(radius, height);
    group.add(shell);
    group.add(outline);

    if (addDetails) {
      const roof = buildSiloRoof(radius, 3);
      roof.position.y = height + 1.5;
      group.add(roof);

      const ladder = buildSiloLadder(radius, height);
      group.add(ladder);

      const ventGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
      const ventMat = new THREE.MeshStandardMaterial({ 
        color: 0x888888, // 更亮的灰色
        roughness: 0.7,
        metalness: 0.3
      });
      const vent = new THREE.Mesh(ventGeo, ventMat);
      vent.position.y = height + 3.75;
      group.add(vent);
    }

    // 使用接口返回的数据设置筒仓信息
    group.userData = {
      type: siloInfo.type,
      id: siloInfo.id,
      编号: siloInfo.id, // 直接使用API返回的编号
      owner: hasMaterialData ? siloInfo.owner : undefined,
      半径_m: siloInfo.radius,
      高度_m: siloInfo.height,
      容积_m3: siloInfo.volume,
      最大容量_t: siloInfo.maxCapacity,
      货类: siloInfo.mainCargo,
      当前储量_t: siloInfo.currentStorage,
      入仓时间: siloInfo.storageTime,
      仓内温度_c: siloInfo.temperature,
      仓内湿度_percent: siloInfo.humidity,
      状态: siloInfo.status,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    group.position.set(x, 0, z);
    scene.add(group);
    registerPickable(group);

    // 所有筒仓都注册为可交互对象，无论是否有物料数据
    registerInteractive(group);
    
    // 根据是否有物料数据设置颜色
    if (hasMaterialData) {
      // 设置初始颜色
      setStackColor(group, getStackBaseColor(group));
    } else {
      // 确保空仓使用灰色
      setStackColor(group, emptySiloColor);
    }

    return group;
  }

  async function placeStarSilo(x, z, height, options = {}) {
    const {
      outerRadius = 3.2,
      innerRadius = outerRadius * 0.55,
      arms = 5,
      densityTPerM3 = 0.75,
      addDetails = true
    } = options;

    // 计算基本参数
    const area = computePolygonArea2D(createStarOutlinePoints(outerRadius, innerRadius, arms));
    const volume = area * height;
    const rawCapacity = volume * densityTPerM3;
    const capacity = rawCapacity.toFixed(1);
    
    // 使用星仓专用编号系统
    let starSiloNumber;
    
    if (starSiloRowIndex < siloNumberMap.starSilo.length && starSiloColIndex < siloNumberMap.starSilo[starSiloRowIndex].length) {
      starSiloNumber = siloNumberMap.starSilo[starSiloRowIndex][starSiloColIndex];
      starSiloColIndex++;
      if (starSiloColIndex >= siloNumberMap.starSilo[starSiloRowIndex].length) {
        starSiloColIndex = 0;
        starSiloRowIndex++;
      }
    } else {
      starSiloNumber = `X${String(siloIdSeq).padStart(3, '0')}`;
    }
    const siloId = siloIdSeq++;

    // 通过接口获取星仓和物料数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: siloId,
        siloNumber: starSiloNumber, // 传递本地编号用于API数据查找
        siloType: '星仓',
        radius: outerRadius,
        height: height,
        volume: volume,
        capacity: capacity
      });
    } catch (error) {
      console.error(`获取星仓 ${starSiloNumber} 数据失败:`, error);
      // 使用默认数据继续创建星仓，避免完全失败
      apiData = {
        siloInfo: {
          id: starSiloNumber,
          type: '星仓',
          radius: outerRadius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '离线'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'fallback-default'
      };
    }

    const { siloInfo: rawSiloInfo = {}, materialDetails = [] } = apiData;
    const siloInfo = {
      ...rawSiloInfo,
      type: '星仓',
      arms: rawSiloInfo?.arms ?? arms
    };
    const activeMaterials = Array.isArray(materialDetails)
    ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6)
    : [];
    const hasMaterialData = activeMaterials.length > 0;


    const group = new THREE.Group();
    // 只有有物料数据时才传递物料详情，否则传递空数组
    const {body, outline} = buildStarSiloBody(outerRadius, innerRadius, height, activeMaterials, arms);
    group.add(body);

    // 为星仓添加线框（简化为轮廓线）
    const outlineGeometry = new THREE.BufferGeometry().setFromPoints([
      ...outline.map(p => new THREE.Vector3(p.x, 0, p.y)),
      new THREE.Vector3(outline[0].x, 0, outline[0].y) // 闭合
    ]);
    const outlineBottom = new THREE.Line(outlineGeometry, new THREE.LineBasicMaterial({color: lineColors.starSilo}));

    const outlineTop = outlineBottom.clone();
    outlineTop.position.y = height;

    group.add(outlineBottom);
    group.add(outlineTop);

    if (addDetails) {
      const capBaseGeo = new THREE.CylinderGeometry(innerRadius * 0.6, innerRadius * 0.6, 1.5, arms * 2);
      const capBaseMat = new THREE.MeshStandardMaterial({
        color: 0xffc75f,
        roughness: 0.45,
        metalness: 0.35
      });
      const capBase = new THREE.Mesh(capBaseGeo, capBaseMat);
      capBase.position.y = height + 0.75;
      capBase.castShadow = true;
      capBase.receiveShadow = true;
      group.add(capBase);

      const spireGeo = new THREE.ConeGeometry(innerRadius * 0.45, 2.2, Math.max(arms * 2, 6));
      const spireMat = new THREE.MeshStandardMaterial({
        color: 0xffe59f,
        roughness: 0.35,
        metalness: 0.3
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.y = height + 2.0;
      spire.castShadow = true;
      group.add(spire);
    }

    // 使用接口返回的数据设置星仓信息
    group.userData = {
      type: '星仓',
      id: starSiloNumber, // 使用本地分配的星仓编号
      编号: starSiloNumber, // 使用本地分配的星仓编号，不使用API返回的编号
      owner: hasMaterialData ? siloInfo.owner : undefined,
      半径_m: siloInfo.radius,
      高度_m: siloInfo.height,
      容积_m3: siloInfo.volume,
      最大容量_t: siloInfo.maxCapacity,
      货类: siloInfo.mainCargo,
      当前储量_t: siloInfo.currentStorage,
      入仓时间: siloInfo.storageTime,
      仓内温度_c: siloInfo.temperature,
      仓内湿度_percent: siloInfo.humidity,
      状态: siloInfo.status,
      星角数: siloInfo.arms ?? arms,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加特殊标识
      特殊标识: siloInfo.specialMark,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    group.position.set(x,-36, z); // 星仓放置在地面
    scene.add(group);
    registerPickable(group);

    // 所有星仓都注册为可交互对象，无论是否有物料数据
    registerInteractive(group);
    
    // 根据是否有物料数据设置颜色
    if (hasMaterialData) {
      setStackColor(group, getStackBaseColor(group));
    } else {
      // 确保空星仓使用灰色
      setStackColor(group, emptySiloColor);
    }

    return group;
  }

  async function addSiloGroup(centerX, centerZ, D, spacingIntra, height) {
    const r = D / 2;
    const step = D + spacingIntra;
    const offsets = [-1.5, -0.5, 0.5, 1.5];
    const silos = [];

    // 并行创建所有筒仓
    const siloPromises = offsets.map(k => 
      placeSilo(centerX + k * step, centerZ, r, height, true)
    );

    const createdSilos = await Promise.all(siloPromises);
    silos.push(...createdSilos);

    const bridgeHeight = height * 0.65;
    for (let i = 0; i < silos.length - 1; i++) {
      const pos1 = silos[i].position;
      const pos2 = silos[i + 1].position;
      const bridge = buildConnectingBridge(pos1.x, pos1.z, pos2.x, pos2.z, bridgeHeight);
      scene.add(bridge);
    }

    const platformGeo = new THREE.PlaneGeometry(step * 4, D * 0.8);
    const platformMat = new THREE.MeshStandardMaterial({
      color: 0xC0C0C0,
      roughness: 0.85,
      side: THREE.DoubleSide
    });
    const platform = new THREE.Mesh(platformGeo, platformMat);
    platform.rotation.x = -Math.PI / 2;
    platform.position.set(centerX, 0.05, centerZ + D * 0.6);
    platform.receiveShadow = true;
    scene.add(platform);

    return silos;
  }

  async function layoutSilosAtEastOfWarehouses(warehouses, warehouseConfig, options = {}) {
    const densityTPerM3 = options.densityTPerM3 ?? 0.75;
    const capacityTons = options.capacityTons ?? 5000;
    const height = options.height ?? 35;
    const spacingIntra = options.spacingIntra ?? 5;
    const spacingInter = options.spacingInter ?? 10;
    const rowGroupCounts = options.rowGroupCounts ?? [1, 1, 2, 4];
    const roadSouthMargin = options.roadSouthMargin ?? 5;

    const volumeM3 = capacityTons / densityTPerM3;
    const radius = options.radius ?? Math.sqrt(volumeM3 / (Math.PI * height));
    const D = radius * 2;
    const groupWidth = 4 * D + 3 * spacingIntra;
    const groupDepth = D;

    // 计算筒仓位置时使用仓库的原始位置，不受仓库移动影响
    const {length: wL, width: wW, gap} = warehouseConfig;
    const cols = 1;
    const totalRowSpan = cols * wL + (cols - 1) * gap;
    const originalLeftStart = -totalRowSpan / 122 + wL / 2 - 100; // 仓库的原始位置
    const originalXEast = originalLeftStart + wL / 2; // 原始仓库东侧边界
    const xEast = originalXEast;
    const corridor = 20;

    let zStart = -(roadSouthMargin + groupDepth / 2);

    // 收集所有筒仓组创建的Promise
    const groupPromises = [];

    for (let row = 0; row < rowGroupCounts.length; row++) {
      const groupsInRow = rowGroupCounts[row];
      let xStart = xEast + corridor + (groupWidth / 2);

      for (let gi = 0; gi < groupsInRow; gi++) {
        const cx = xStart + gi * (groupWidth + spacingInter);
        groupPromises.push(addSiloGroup(cx, zStart, D, spacingIntra, height));
      }
      zStart -= (groupDepth + spacingInter);
    }

    // 并行创建所有筒仓组
    await Promise.all(groupPromises);

    return {D, height, radius, count: rowGroupCounts.reduce((a, b) => a + b, 0) * 4};
  }

  async function init() {
    // 测试颜色解析功能
    testColorParsing();
    
    const cfg = await fetchYardConfig();
    const {length: yardL, width: yardW, roadWidth} = cfg.yard;
    buildYardGrid(yardL, yardW);
    buildMainRoad(roadWidth, yardL);
    buildSidewalkTrees(roadWidth, yardL);

    const {length: wL, width: wW, height: wH, roofHeight: rH, gap} = cfg.warehouse;
    const cols = 1;
    const rows = 1;
    const totalRowSpan = cols * wL + (cols - 1) * gap;
    const leftStart = -totalRowSpan / 2 + wL / 2 + 90; // 将仓库#A向右移动米

    const zRowOffset = -(roadWidth / 2 + wW / 2 + 5);
    const rowZs = [zRowOffset];

    const warehouses = [];
    for (let r = 0; r < rows; r++) {
      const cz = rowZs[r];
      for (let c = 0; c < cols; c++) {
        const cx = leftStart + c * (wL + gap);
        const wh = buildWarehouse({length: wL, width: wW, height: wH, roofHeight: rH}, cx, cz, r * cols + c);
        warehouses.push(wh);
        const stkConf = await fetchWarehouseStackConfig(r * cols + c);
        populateStacks(wh, {length: wL, width: wW, height: wH}, stkConf, r * cols + c);
      }
    }

    try {
      await layoutSilosAtEastOfWarehouses(warehouses, {length: wL, width: wW, gap}, {
        radius: 4.5,
        height: 35,
        spacingIntra: 0.5,
        spacingInter: 1.5,
        rowGroupCounts: [2, 2, 2, 1, 1], // 减少一排筒仓（8个）
        roadSouthMargin: 15 // 减少南侧边距，更好地利用空间
      });

      // 并行创建所有星仓
      const starSiloPromises = [
         // 一排星仓
        placeStarSilo(-31.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-31.92, -56.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-31.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-31.92, -45.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 二排星仓
        placeStarSilo(-21.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-21.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-21.92, -45.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-22.92, -56.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 三排星仓
        placeStarSilo(-11.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-11.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-11.92, -45.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-12.92, -56.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 四排星仓
        placeStarSilo(8.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(8.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 五排星仓
        placeStarSilo(18.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(18.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 六排星仓
        placeStarSilo(28.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(28.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false })
      ];

      await Promise.all(starSiloPromises);
    } catch (error) {
      console.error('初始化失败:', error);
      // 网络错误已在API调用中显示，这里不再重复显示
      return; // 停止初始化过程
    }
   


    fitCameraToYard(yardL, yardW, wH + rH, 1.0);
    updateCompass();
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);

    // 渲染模型预览
    if (modelRenderer && modelScene && modelCamera && modelPanel.style.display !== 'none') {
      modelControls.update();
      modelRenderer.render(modelScene, modelCamera);
    }
  }

  init();
  animate();
</script>
</body>
</html>










