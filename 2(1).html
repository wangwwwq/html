<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>仓库园区立体透视图 - 线框模式</title>l
  <style>
    :root {
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-fg: #222;
      --panel-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #f0f0f0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    }

    #loginOverlay {
      position: fixed;
      inset: 0;
      z-index: 999;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #f7fafc, #eef2f7);
    }

    #loginCard {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      padding: 24px 24px 20px;
      width: 320px;
    }

    #loginCard h2 {
      margin: 0 0 12px;
      font-size: 18px;
      color: #111;
    }

    .form-row {
      margin: 10px 0;
    }

    .form-row label {
      display: block;
      font-size: 13px;
      color: #444;
      margin-bottom: 6px;
    }

    .form-row input {
      width: 100%;
      height: 34px;
      padding: 6px 10px;
      border: 1px solid #d5d7db;
      border-radius: 6px;
      outline: none;
      box-sizing: border-box;
    }

    .form-actions {
      margin-top: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .btn {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .error {
      color: #b91c1c;
      font-size: 12px;
      min-height: 16px;
    }

    #viewport {
      width: 90vw;
      height: 90vh;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #f0f0f0;
    }

    canvas {
      display: block;
    }

    #infoPanel {
      position: fixed;
      display: none;
      z-index: 10;
      left: 0;
      top: 0;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: var(--panel-shadow);
      font-size: 14px;
      pointer-events: none;
      min-width: 120px;
      line-height: 1.5;
    }

    #detailPanel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      min-width: 300px;
      max-width: 400px;
      max-height: 70vh;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.4;
    }

    #compass {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 100px;
      height: 100px;
      z-index: 11;
      background: var(--panel-bg);
      border-radius: 50%;
      box-shadow: var(--panel-shadow);
      display: grid;
      place-items: center;
      user-select: none;
      pointer-events: none;
    }

    #compass svg {
      width: 84px;
      height: 84px;
    }

    #compass .label {
      font-size: 12px;
      font-weight: 600;
      fill: #333;
    }

    .whLabel {
      background: #ffffff;
      border: 1px solid #d0d5dd;
      color: #111;
      font-size: 12px;
      line-height: 1;
      padding: 4px 6px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
    }

    #whPanel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 10;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      min-width: 240px;
      font-size: 14px;
    }

    #actionBar {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%) translateY(12px);
      z-index: 12;
      opacity: 0;
      pointer-events: none;
      transition: transform .18s ease, opacity .18s ease;
    }

    #actionBar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    .action-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--panel-bg);
      color: var(--panel-fg);
      box-shadow: var(--panel-shadow);
      border-radius: 999px;
      padding: 8px;
      backdrop-filter: saturate(160%) blur(6px);
    }

    .action-bar .btn {
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 14px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
    }



    #monitorPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      display: none;
      background: var(--panel-bg);
      color: var(--panel-fg);
      border-radius: 8px;
      box-shadow: var(--panel-shadow);
      width: 80vw;
      max-width: 800px;
      height: 60vh;
      max-height: 500px;
    }

    #monitorPanel .monitor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      background: #f8f9fa;
      border-radius: 8px 8px 0 0;
    }

    #monitorPanel .monitor-title {
      font-weight: 600;
      color: #2563eb;
      margin: 0;
    }

    #monitorPanel .monitor-close {
      background: #dc2626;
      color: white;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
    }

    #monitorPanel .monitor-close:hover {
      background: #b91c1c;
    }

    #monitorVideoContainer {
      position: relative;
      width: 100%;
      height: calc(100% - 60px);
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0 0 8px 8px;
    }

    #monitorVideo {
      width: 100%;
      height: 100%;
      background: #000;
    }

    .monitor-controls {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      border-radius: 6px;
    }

    .monitor-controls button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .monitor-controls button:hover {
      background: #1d4ed8;
    }

    .monitor-controls button:disabled {
      background: #6b7280;
      cursor: not-allowed;
    }

    .monitor-loading {
      color: #888;
      font-size: 16px;
    }

    #networkErrorPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      display: none;
      background: #fff;
      color: #333;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      padding: 24px;
      width: 300px;
      text-align: center;
    }

    #networkErrorPanel .error-icon {
      font-size: 48px;
      color: #dc2626;
      margin-bottom: 16px;
    }

    #networkErrorPanel .error-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #dc2626;
    }

    #networkErrorPanel .error-message {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
      line-height: 1.5;
    }

    #networkErrorPanel .error-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    #networkErrorPanel .btn-retry {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    #networkErrorPanel .btn-retry:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
<div id="loginOverlay">
  <div id="loginCard">
    <h2>登录</h2>
    <form id="loginForm">
      <div class="form-row">
        <label for="username">用户名</label>
        <input id="username" name="username" autocomplete="username" placeholder="请输入用户名"/>
      </div>
      <div class="form-row">
        <label for="password">密码</label>
        <input id="password" name="password" type="password" autocomplete="current-password"
               placeholder="请输入密码"/>
      </div>
      <div class="form-actions">
        <button type="submit" class="btn">登录</button>
        <span id="loginError" class="error"></span>
      </div>
    </form>
  </div>
</div>

<div id="viewport"></div>
<div id="infoPanel"></div>
<div id="detailPanel"></div>
<div id="compass" aria-label="指南针">
  <svg viewBox="0 0 100 100">
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6"
              orient="auto-start-reverse">
        <path d="M0,0 L10,5 L0,10 z" fill="#d00"/>
      </marker>
    </defs>
    <circle cx="50" cy="50" r="38" fill="none" stroke="#888" stroke-width="2"/>
    <line x1="50" y1="50" x2="50" y2="12" stroke="#d00" stroke-width="3" marker-end="url(#arrow)"/>
    <line x1="50" y1="10" x2="50" y2="20" stroke="#666" stroke-width="2"/>
    <line x1="50" y1="80" x2="50" y2="90" stroke="#666" stroke-width="2"/>
    <line x1="10" y1="50" x2="20" y2="50" stroke="#666" stroke-width="2"/>
    <line x1="80" y1="50" x2="90" y2="50" stroke="#666" stroke-width="2"/>
    <text x="50" y="8" text-anchor="middle" class="label">N</text>
    <text x="92" y="54" text-anchor="middle" class="label">E</text>
    <text x="50" y="98" text-anchor="middle" class="label">S</text>
    <text x="8" y="54" text-anchor="middle" class="label">W</text>
  </svg>
</div>
<div id="whPanel"></div>

<div id="actionBar" aria-live="polite">
  <div class="action-bar">
    <button id="btnLfs" class="btn">查看LFS订单</button>
    <button id="btnTms" class="btn">查看相关TMS运输订单</button>
    <button id="btnFee" class="btn">查看平仓P01仓储费用</button>
    <button id="btnMonitor" class="btn">查看监控</button>
  </div>
</div>

<!-- 网络错误提示面板 -->
<div id="networkErrorPanel">
  <div class="error-icon">⚠️</div>
  <div class="error-title">网络连接错误</div>
  <div class="error-message">网络繁忙，请稍后再试</div>
  <div class="error-actions">
    <button class="btn-retry" id="retryBtn">重试</button>
  </div>
</div>

<!-- 监控播放面板 -->
<div id="monitorPanel">
  <div class="monitor-header">
    <h3 class="monitor-title">筒仓监控播放</h3>
    <button class="monitor-close" id="monitorClose">×</button>
  </div>
  <div id="monitorVideoContainer">
    <video id="monitorVideo" controls autoplay muted>
      您的浏览器不支持视频播放
    </video>
    <div class="monitor-controls">
      <button id="playBtn">播放</button>
      <button id="pauseBtn">暂停</button>
      <button id="fullscreenBtn">全屏</button>
    </div>
    <div class="monitor-loading" id="monitorLoading" style="display: none;">
      正在加载监控流...
    </div>
  </div>
</div>

<!-- 引入flv.js用于播放萤石监控流 -->
<script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
  import {CSS2DRenderer, CSS2DObject} from 'three/addons/renderers/CSS2DRenderer.js';

  // 登录逻辑
  const loginOverlay = document.getElementById('loginOverlay');
  const loginForm = document.getElementById('loginForm');
  const loginError = document.getElementById('loginError');
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  let currentUser = null;

  loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const u = usernameInput.value.trim();
    const p = passwordInput.value;
    if (u === 'JF' && p === '123456') {
      currentUser = u;
      loginOverlay.style.display = 'none';
    } else {
      currentUser = u;
      loginOverlay.style.display = 'none';
      //loginError.textContent = '用户名或密码不正确';
      //return;
    }
  });

  // 配置获取
  async function fetchYardConfig() {
    return {
      yard: {length: 300, width: 290, roadWidth: 20}, // 将length从350减少到300，缩小西方向50米；width保持290米
      warehouse: {
        count: 1,
        length: 40,
        width: 50,
        height: 15,
        roofHeight: 5,
        gap: 15,
      }
    };
  }

  async function fetchWarehouseStackConfig(warehouseIndex) {
    return {
      stackSize: {length: 25, width: 25, height: 12},
      spacing: 5,
      margin: 5
    };
  }

  // Three.js 基础设置
  const container = document.getElementById('viewport');
  const infoPanel = document.getElementById('infoPanel');
  const detailPanel = document.getElementById('detailPanel');
  const compass = document.getElementById('compass');
  const whPanel = document.getElementById('whPanel');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  scene.fog = new THREE.Fog(0xf0f0f0, 600, 2500);
  
  // 将scene存储到window对象中，确保全局可访问
  window.globalScene = scene;

  const camera = new THREE.PerspectiveCamera(65, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(600, 600, 600);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(container.clientWidth, container.clientHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0';
  labelRenderer.domElement.style.left = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  labelRenderer.domElement.style.zIndex = '10';
  container.appendChild(labelRenderer.domElement);




  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  const polarAngle = Math.PI / 4;
  controls.minPolarAngle = polarAngle;
  controls.maxPolarAngle = polarAngle;
  controls.minDistance = 100;
  controls.maxDistance = 2000;
  controls.target.set(0, 0, 0);

  // 光照系统
  const hemi = new THREE.HemisphereLight(0xffffff, 0xd0d0d0, 0.8);
  scene.add(hemi);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(200, 300, 200);
  dirLight.castShadow = true;
  dirLight.shadow.camera.left = -300;
  dirLight.shadow.camera.right = 300;
  dirLight.shadow.camera.top = 300;
  dirLight.shadow.camera.bottom = -300;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambLight);

  // 线框创建
  function createWireframe(geometry, color = 0x333333) {
    const edges = new THREE.EdgesGeometry(geometry);
    const mat = new THREE.LineBasicMaterial({color});
    return new THREE.LineSegments(edges, mat);
  }


  // 颜色配置
  const lineColors = {
    wall: 0x555555,
    roof: 0x8B4513,
    stack: 0x6b6b6b,
    hover: 0x1e90ff,
    selected: 0xff3333,
    ownerJF: 0x22aa22,
    fence: 0x2f855a,
    tree: 0x2e7d32,
    silo: 0x888888,
    siloOwnerJF: 0x33bb33,
    siloHover: 0x2eb8ff,
    siloSelected: 0xff4444,
    starSilo: 0xf2b134,
    starSiloOwnerJF: 0xffc75f,
    starSiloHover: 0xffe59f,
    starSiloSelected: 0xff7f50,
    weighbridge: 0x4A4A4A,
    weighbridgeHover: 0x5A5A5A,
    weighbridgeSelected: 0x6A6A6A,
  };

  const emptySiloColor = 0xD8D8D0; // Neutral fill for silos without material data
  const noNumberSiloColor = 0xFF6B6B; // 红色，表示没有分配编号的筒仓

  
  // 公司颜色映射（已弃用，现在使用API返回的companyColor字段）
  const companyColors = {
    '建发集团': 0x22aa22,  // 绿色
    '国贸集团': 0x2563eb,  // 蓝色
    '中粮集团': 0xf59e0b,  // 黄色
    '华润集团': 0xef4444,  // 红色
    '新希望集团': 0x8b5cf6, // 紫色
    '正邦集团': 0x06b6d4,  // 青色
    // 新增的公司颜色映射
    '广州市储备粮管理中心': 0x22aa22,  // 绿色
    '黄埔区发展和改革局': 0x32b67a,  // hsl(162.0, 65%, 55%) - 绿蓝色
    '河南华穗农产品有限公司': 0xf59e0b,  // 黄色
    '粤海永顺泰（广州）麦芽有限公司': 0xef4444  // 红色
  };
  
  // 颜色转换工具函数
  function getColorCSS(hexColor) {
    return `#${hexColor.toString(16).padStart(6, '0')}`;
  }

  // HSL颜色处理函数
  function parseColor(colorValue) {
    if (!colorValue) return { hex: 0x666666, css: '#666666' };
    
    // 如果是HSL格式
    if (typeof colorValue === 'string' && colorValue.includes('hsl')) {
      const hexValue = hslToHex(colorValue);
      return { hex: hexValue, css: getColorCSS(hexValue) };
    }
    
    // 如果是十六进制数值
    if (typeof colorValue === 'number') {
      return { hex: colorValue, css: getColorCSS(colorValue) };
    }
    
    // 如果是十六进制字符串
    if (typeof colorValue === 'string' && colorValue.startsWith('#')) {
      const hex = parseInt(colorValue.substring(1), 16);
      return { hex: hex, css: colorValue };
    }
    
    // 默认颜色
    return { hex: 0x666666, css: '#666666' };
  }

  // HSL转十六进制
  function hslToHex(hslString) {
    const match = hslString.match(/hsl\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)%,\s*(\d+(?:\.\d+)?)%\)/);
    if (!match) {
      console.warn('无法解析HSL颜色:', hslString);
      return 0x666666;
    }
    
    const h = parseFloat(match[1]) / 360;
    const s = parseFloat(match[2]) / 100;
    const l = parseFloat(match[3]) / 100;
    
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    let r, g, b;
    if (s === 0) {
      r = g = b = l; // 无饱和度
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    
    const rHex = Math.round(r * 255);
    const gHex = Math.round(g * 255);
    const bHex = Math.round(b * 255);
    
    const result = (rHex << 16) + (gHex << 8) + bHex;
    console.log(`HSL转换: ${hslString} -> RGB(${rHex}, ${gHex}, ${bHex}) -> 0x${result.toString(16)}`);
    return result;
  }

  // 颜色解析测试函数
  function testColorParsing() {
    console.log('=== 颜色解析测试 ===');
    const testColors = [
      'hsl(162.0, 65%, 55%)',
      '#ff0000',
      0x00ff00,
      'hsl(240, 100%, 50%)',
      'invalid-color'
    ];
    
    testColors.forEach(color => {
      const result = parseColor(color);
      console.log(`输入: ${color} -> hex: 0x${result.hex.toString(16)}, css: ${result.css}`);
    });
    console.log('=== 测试结束 ===');
  }

  // 真实API接口配置
  const API_CONFIG = {
    BASE_URL: 'http://127.0.0.1:8062', // 正式本地API服务
    // BASE_URL: 'https://6166qiyy8859.vicp.fun', // 远程API服务
    PATH_PREFIX: '/driver-appointment-service',
    ENDPOINTS: {
      ALL_SILOS: '/api/order-driver/siloStarWarehouseData',
      ALL_WEIGHBRIDGES: '/api/order-driver/weighbridgeData' // 正式地磅数据接口
    }
  };

  // 全局筒仓数据缓存
  let globalSiloData = null;
  let lastFetchTime = 0;
  const CACHE_DURATION = 5 * 60 * 1000; // 5分钟缓存
  
  // 请求去重机制：确保同一时间只有一个API请求
  let ongoingFetchPromise = null;

  // 全局地磅数据缓存
  let globalWeighbridgeData = null;
  let lastWeighbridgeFetchTime = 0;
  let ongoingWeighbridgeFetchPromise = null;

  // 从真实API获取所有筒仓数据
  async function fetchAllSilosFromAPI() {
    const now = Date.now();
    
    // 如果有缓存且未过期，直接使用缓存
    if (globalSiloData && (now - lastFetchTime) < CACHE_DURATION) {
      return globalSiloData;
    }
    
    // 如果已经有请求在进行中，等待该请求完成
    if (ongoingFetchPromise) {
      console.log('等待进行中的API请求完成...');
      return await ongoingFetchPromise;
    }

    // 创建新的请求Promise
    ongoingFetchPromise = performActualFetch();
    
    try {
      const result = await ongoingFetchPromise;
      return result;
    } finally {
      // 请求完成后清除Promise引用，允许后续请求
      ongoingFetchPromise = null;
    }
    
    async function performActualFetch() {
      try {
        const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.PATH_PREFIX}${API_CONFIG.ENDPOINTS.ALL_SILOS}`;
        console.log('正在从API获取筒仓数据:', apiUrl);
        
        const response = await fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
        }

        const apiResponse = await response.json();
        
        if (apiResponse.success && apiResponse.data) {
          // 将对象格式的数据转换为数组格式
          const siloList = [];
          const dataKeys = Object.keys(apiResponse.data);
          
          dataKeys.forEach(key => {
            const siloData = apiResponse.data[key];
            if (siloData && siloData.siloInfo) {
              siloList.push(siloData);
            }
          });
          
          // 构造前端期望的数据格式
          globalSiloData = {
            siloList: siloList,
            totalCount: siloList.length,
            timestamp: new Date().toISOString(),
            dataSource: 'production-api'
          };
          
          lastFetchTime = now;
          console.log(`成功获取 ${globalSiloData.totalCount} 个筒仓数据`);
          return globalSiloData;
        } else {
          throw new Error('API返回数据格式错误');
        }
      } catch (error) {
        console.error('获取API数据失败:', error);
        // 显示网络错误提示
        showNetworkError();
        throw new Error('网络繁忙，请稍后再试');
      }
    }
  }

  // 从真实API获取所有地磅数据
  async function fetchAllWeighbridgesFromAPI() {
    const now = Date.now();
    
    // 如果有缓存且未过期，直接使用缓存
    if (globalWeighbridgeData && (now - lastWeighbridgeFetchTime) < CACHE_DURATION) {
      return globalWeighbridgeData;
    }
    
    // 如果已经有请求在进行中，等待该请求完成
    if (ongoingWeighbridgeFetchPromise) {
      console.log('等待进行中的地磅API请求完成...');
      return await ongoingWeighbridgeFetchPromise;
    }

    // 创建新的请求Promise
    ongoingWeighbridgeFetchPromise = performActualWeighbridgeFetch();
    
    try {
      const result = await ongoingWeighbridgeFetchPromise;
      return result;
    } finally {
      // 请求完成后清除Promise引用，允许后续请求
      ongoingWeighbridgeFetchPromise = null;
    }
    
    async function performActualWeighbridgeFetch() {
      try {
        const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.PATH_PREFIX}${API_CONFIG.ENDPOINTS.ALL_WEIGHBRIDGES}`;
        console.log('🌐 正在从真实API获取地磅数据:', apiUrl);
        console.log('📡 数据源: 真实生产环境API (非模拟数据)');
        
        const response = await fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`地磅API请求失败: ${response.status} ${response.statusText}`);
        }

        const apiResponse = await response.json();
        
        // 适配正式接口返回格式: { success: true, code: 200, message: "SUCCESS", data: {MZDB11: {record}, MZDB21: {record}} }
        if (apiResponse.success && apiResponse.code === 200 && apiResponse.data) {
          
          const weighbridgeList = [];
          const dataKeys = Object.keys(apiResponse.data);
          
          // 检查是否有实际数据
          if (dataKeys.length === 0) {
            console.log('地磅API返回空数据对象，当前无地磅数据');
            globalWeighbridgeData = {
              weighbridgeList: [],
              totalCount: 0,
              timestamp: new Date().toISOString(),
              dataSource: 'api-empty-data'
            };
            
            lastWeighbridgeFetchTime = now;
            
            // 更新场景中所有地磅的显示状态，清空车辆
            try {
              updateAllWeighbridgesInScene();
            } catch (error) {
              // 静默处理场景更新错误
            }
            
            return globalWeighbridgeData;
          }
          
          // 处理按设备号分组的数据结构
          dataKeys.forEach(equipmentNo => {
            const recordData = apiResponse.data[equipmentNo];
            
            if (recordData) {
              // 新格式：每个设备号对应单个对象，不再是数组
              const record = recordData;
              
              // 设备号到地磅编号的映射
              let weighbridgeId;
              if (equipmentNo === 'MZDB11') {
                weighbridgeId = '1号磅'; // 地磅1
              } else if (equipmentNo === 'MZDB21') {
                weighbridgeId = '2号磅'; // 地磅2  
              } else if (equipmentNo === 'MZDB12') {
                weighbridgeId = '1号磅'; // 地磅1的另一个设备
              } else {
                // 其他设备号，尝试从设备号中提取数字
                const match = equipmentNo.match(/(\d+)$/);
                weighbridgeId = match ? `${match[1]}号磅` : equipmentNo;
              }
              
              console.log(`📊 设备 ${equipmentNo} -> 地磅 ${weighbridgeId}: 车牌 ${record.vehicleno}, 重量 ${(record.ponderation/1000).toFixed(2)}吨`);
              
          // 将分组后的数据转换为前端期望的格式
            // 将重量从kg转换为吨
            const weightInTons = record.ponderation ? (record.ponderation / 1000).toFixed(2) : 0;
            const correctedWeightInTons = record.correctPonderation ? (record.correctPonderation / 1000).toFixed(2) : null;
            
            // 判断地磅状态
            let status = '空闲';
            if (record.vehicleno && record.ponderation > 0) {
              status = '称重中';
            } else if (record.vehicleno) {
              status = '有车';
            }
            
            const convertedData = {
              weighbridgeInfo: {
                id: weighbridgeId, // 使用地磅编号作为ID
                equipmentNo: equipmentNo, // 保存原始设备号
                type: '地磅',
                status: status,
                currentWeight: parseFloat(weightInTons), // 当前重量（吨）
                plateNumber: record.vehicleno || '', // 车牌号
                vehicleType: '货车', // 默认车辆类型
                arrivalTime: record.regtimeV || record.regtime || '', // 过磅时间
                driver: record.driver || '', // 司机姓名
                driverid: record.driverid || '', // 司机身份证
                warehouseName: record.warehouseName || '', // 库区
                correctPonderation: correctedWeightInTons, // 纠正重量（吨）
                frontimg: record.frontimg || '', // 前端车牌图片
                backimg: record.backimg || '', // 后端车牌图片
                wholeimg: record.wholeimg || '', // 全景图片
                createTime: record.createOnV || record.createOn || '', // 记录时间
                recordId: record.id // 记录ID
              }
            };
            weighbridgeList.push(convertedData);
            }
          });
          
          // 构造前端期望的数据格式
          globalWeighbridgeData = {
            weighbridgeList: weighbridgeList,
            totalCount: weighbridgeList.length,
            timestamp: apiResponse.timestamp || new Date().toISOString(),
            dataSource: 'real-production-api', // 真实生产环境API
            apiEndpoint: apiUrl
          };
          
          lastWeighbridgeFetchTime = now;
          console.log(`✅ 成功从真实API获取 ${globalWeighbridgeData.totalCount} 个地磅数据`);
          console.log(`📊 数据来源: ${globalWeighbridgeData.dataSource} - ${apiUrl}`);
          
          // 更新场景中所有地磅的显示状态
          try {
            updateAllWeighbridgesInScene();
          } catch (error) {
            // 静默处理场景更新错误
          }
          
          return globalWeighbridgeData;
        } else {
          console.warn('地磅API返回数据格式错误，返回空数据结构');
          // 返回空的默认数据结构，不抛出错误
          globalWeighbridgeData = {
            weighbridgeList: [],
            totalCount: 0,
            timestamp: new Date().toISOString(),
            dataSource: 'format-error-fallback'
          };
          
          lastWeighbridgeFetchTime = now;
          
          // 更新场景中所有地磅的显示状态，清空车辆
          try {
            updateAllWeighbridgesInScene();
          } catch (error) {
            // 静默处理场景更新错误
          }
          
          return globalWeighbridgeData;
        }
      } catch (error) {
        console.error('获取地磅API数据失败:', error);
        // 显示网络错误提示
        showNetworkError();
        
        // 返回空的默认数据结构，不抛出错误
        console.warn('API调用失败，返回空的地磅数据结构');
        globalWeighbridgeData = {
          weighbridgeList: [],
          totalCount: 0,
          timestamp: new Date().toISOString(),
          dataSource: 'api-error-fallback'
        };
        
        lastWeighbridgeFetchTime = now;
        
        // 更新场景中所有地磅的显示状态，清空车辆
        try {
          updateAllWeighbridgesInScene();
        } catch (error) {
          // 静默处理场景更新错误
        }
        
        return globalWeighbridgeData;
      }
    }
  }

  // 自动刷新定时器
  let autoRefreshTimer = null;

  // 启动5秒定时轮询
  function startAutoRefresh() {
    // 安全检查：确保scene对象已经初始化
    if (typeof scene === 'undefined' || !scene) {
      console.warn('⚠️ Scene对象未初始化，延迟启动自动刷新');
      setTimeout(startAutoRefresh, 1000); // 1秒后重试
      return;
    }
    
    // 清除之前的定时器
    if (autoRefreshTimer) {
      clearInterval(autoRefreshTimer);
    }
    
    console.log('🚀 启动地磅数据5秒定时轮询');
    
    // 立即获取一次数据
    fetchAllWeighbridgesFromAPI().catch(error => {
      console.error('初始数据获取失败:', error);
    });
    
    // 每5秒自动刷新一次
    autoRefreshTimer = setInterval(async () => {
      try {
        console.log('🔄 执行5秒定时轮询...');
        
        // 强制清除缓存，确保每次都发送真实请求
        console.log('🗑️ 清除地磅数据缓存，强制发送API请求');
        globalWeighbridgeData = null;
        lastWeighbridgeFetchTime = 0;
        ongoingWeighbridgeFetchPromise = null;
        
        await fetchAllWeighbridgesFromAPI();
        console.log('✅ 地磅数据自动刷新完成 -', new Date().toLocaleTimeString());
      } catch (error) {
        console.error('❌ 定时轮询失败:', error);
      }
    }, 5000); // 5秒 = 5000毫秒
  }
  
  // 手动强制刷新功能（用于调试）
  function forceRefreshWeighbridges() {
    console.log('🔧 手动强制刷新地磅数据...');
    // 清除所有缓存
    globalWeighbridgeData = null;
    lastWeighbridgeFetchTime = 0;
    ongoingWeighbridgeFetchPromise = null;
    
    return fetchAllWeighbridgesFromAPI();
  }
  
  // 暴露到全局作用域供调试使用
  window.forceRefreshWeighbridges = forceRefreshWeighbridges;

  // 停止自动刷新
  function stopAutoRefresh() {
    if (autoRefreshTimer) {
      clearInterval(autoRefreshTimer);
      autoRefreshTimer = null;
      console.log('⏹️ 已停止地磅数据定时轮询');
    }
  }

  // 根据地磅编号从全局数据中获取单个地磅数据
  async function fetchWeighbridgeData(weighbridgeParams) {
    const { weighbridgeId, weighbridgeNumber, length, width, maxWeight } = weighbridgeParams;
    
    // 如果没有编号，直接返回默认数据
    if (!weighbridgeNumber) {
      console.log(`地磅 ID ${weighbridgeId} 没有分配编号，使用默认数据`);
      return {
        weighbridgeInfo: {
          id: `未分配编号-${weighbridgeId}`,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '空闲',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'no-number-assigned'
      };
    }
    
    // 获取所有地磅数据
    let allWeighbridgesData;
    try {
      allWeighbridgesData = await fetchAllWeighbridgesFromAPI();
    } catch (error) {
      console.warn('获取地磅API数据失败，使用默认数据:', error);
      // 如果API调用失败，直接返回默认数据，不抛出错误
      return {
        weighbridgeInfo: {
          id: weighbridgeNumber,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '离线',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'api-failed-fallback'
      };
    }
    
    if (!allWeighbridgesData || !allWeighbridgesData.weighbridgeList) {
      console.warn('地磅API数据格式异常，使用默认数据');
      // 如果数据格式异常，返回默认数据，不抛出错误
      return {
        weighbridgeInfo: {
          id: weighbridgeNumber,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '离线',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'data-format-error-fallback'
      };
    }

    // 直接使用传入的地磅编号查找API数据
    let targetWeighbridge;
    if (weighbridgeNumber) {
      // 优先使用传入的编号查找
      targetWeighbridge = allWeighbridgesData.weighbridgeList.find(wb => wb.weighbridgeInfo.id === weighbridgeNumber);
      console.log(`使用编号查找地磅: ${weighbridgeNumber}`, targetWeighbridge ? '找到' : '未找到');
    }
    
    // 如果按编号未找到，返回默认数据
    if (!targetWeighbridge) {
      console.warn(`API中未找到地磅编号: ${weighbridgeNumber}`);
      return {
        weighbridgeInfo: {
          id: weighbridgeNumber,
          type: '地磅',
          length: length,
          width: width,
          maxWeight: maxWeight,
          accuracy: '±20kg',
          manufacturer: '',
          installDate: '',
          lastCalibration: '',
          calibrationCycle: '',
          usageCount: 0,
          status: '空闲',
          currentWeight: 0,
          plateNumber: '',
          vehicleType: '',
          arrivalTime: ''
        },
        timestamp: Date.now(),
        dataSource: 'api-not-found'
      };
    }
    
    if (targetWeighbridge) {
      const actualId = targetWeighbridge.weighbridgeInfo.id;
      console.log(`成功获取地磅数据: ${actualId}`);
      
      return {
        weighbridgeInfo: targetWeighbridge.weighbridgeInfo,
        timestamp: Date.now(),
        dataSource: allWeighbridgesData.dataSource
      };
    }
  }

  // 根据筒仓编号从全局数据中获取单个筒仓数据
  async function fetchSiloAndMaterialData(siloParams) {
    const { siloId, siloNumber, siloType, radius, height, volume, capacity } = siloParams;
    
    // 如果没有编号，直接返回默认数据，表示接口中没有对应数据
    if (!siloNumber) {
      console.log(`筒仓 ID ${siloId} 没有分配编号，使用默认数据`);
      return {
        siloInfo: {
          id: `未分配编号-${siloId}`,
          type: siloType || '筒仓',
          radius: radius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '未配置'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'no-number-assigned'
      };
    }
    
    // 获取所有筒仓数据
    const allSilosData = await fetchAllSilosFromAPI();
    
    if (!allSilosData || !allSilosData.siloList) {
      console.error('无法获取筒仓数据');
      throw new Error('网络繁忙，请稍后再试');
    }

    // 直接使用传入的筒仓编号查找API数据
    let targetSilo;
    if (siloNumber) {
      // 优先使用传入的编号查找
      targetSilo = allSilosData.siloList.find(silo => silo.siloInfo.id === siloNumber);
      console.log(`使用编号查找筒仓: ${siloNumber}`, targetSilo ? '找到' : '未找到');
    }
    
    // 如果按编号未找到，不使用备用映射，直接返回空数据
    // 这样可以确保只有API中真正存在的编号才会显示数据
    if (!targetSilo) {
      console.warn(`API中未找到筒仓编号: ${siloNumber}`);
    }
    
    if (targetSilo) {
      const actualId = targetSilo.siloInfo.id;
      console.log(`成功找到筒仓数据: ${actualId}`, targetSilo);
      
      // 特殊处理：P01或以P开头的数据实际上是平仓数据
      const actualType = (actualId === 'P01' || actualId.startsWith('P')) ? '平仓P01' : targetSilo.siloInfo.type;
      
      if (actualId === 'P01' || actualId.startsWith('P')) {
        console.log(`检测到平仓数据: ${actualId}, 类型从 "${targetSilo.siloInfo.type}" 修正为 "${actualType}"`);
      }
      
      // 转换API数据格式为前端需要的格式
      return {
        siloInfo: {
          id: targetSilo.siloInfo.id,
          type: actualType,
          radius: targetSilo.siloInfo.radius,
          height: targetSilo.siloInfo.height,
          volume: targetSilo.siloInfo.volume,
          maxCapacity: targetSilo.siloInfo.maxCapacity,
          currentStorage: targetSilo.siloInfo.currentStorage,
          mainCargo: extractMainCargo(targetSilo.materialDetails),
          storageTime: targetSilo.siloInfo.storageTime,
          temperature: targetSilo.siloInfo.temperature,
          humidity: targetSilo.siloInfo.humidity,
          status: targetSilo.siloInfo.status,
          owner: extractOwner(targetSilo.materialDetails),
          specialMark: targetSilo.siloInfo.specialMark,
          arms: targetSilo.siloInfo.arms
        },
        materialDetails: targetSilo.materialDetails || [],
        timestamp: targetSilo.timestamp,
        dataSource: targetSilo.dataSource || 'production-api'
      };
    } else {
      console.warn(`未找到筒仓数据: 编号 ${siloNumber}, 数字ID ${siloId}`);
      // 返回默认的空筒仓数据，避免系统崩溃
      return {
        siloInfo: {
          id: `T${String(siloId).padStart(3, '0')}`,
          type: siloType || '筒仓',
          radius: siloParams.radius,
          height: siloParams.height,
          volume: siloParams.volume,
          maxCapacity: siloParams.capacity,
          currentStorage: 0,
          mainCargo: '空仓',
          storageTime: '',
          temperature: '',
          humidity: '',
          status: '空仓',
          owner: null
        },
        materialDetails: [],
        timestamp: new Date().toISOString(),
        dataSource: 'fallback-empty'
      };
    }
  }
  
  // 辅助函数：从物料详情中提取主要货物
  function extractMainCargo(materialDetails) {
    if (!materialDetails || materialDetails.length === 0) return '空仓';
    
    // 找到数量最大的物料
    const maxMaterial = materialDetails.reduce((max, current) => {
      const currentAmount = Math.abs(parseFloat(current.amount) || 0);
      const maxAmount = Math.abs(parseFloat(max.amount) || 0);
      return currentAmount > maxAmount ? current : max;
    }, materialDetails[0]);
    
    return maxMaterial.material || '未知';
  }
  
  // 辅助函数：从物料详情中提取所有者
  function extractOwner(materialDetails) {
    if (!materialDetails || materialDetails.length === 0) return null;
    
    // 获取所有公司名称，去重
    const companies = [...new Set(materialDetails.map(m => m.company).filter(Boolean))];
    return companies.length > 0 ? companies[0] : null;
  }




  // 网络错误处理
  const networkErrorPanel = document.getElementById('networkErrorPanel');
  const retryBtn = document.getElementById('retryBtn');

  function showNetworkError() {
    networkErrorPanel.style.display = 'block';
  }

  function hideNetworkError() {
    networkErrorPanel.style.display = 'none';
  }

  // 重试按钮事件监听
  retryBtn.addEventListener('click', () => {
    hideNetworkError();
    // 重新初始化系统
    location.reload();
  });

  const raycastTargets = [];
  const raycastTargetSet = new Set();
  const interactives = [];
  const interactiveSet = new Set();

  function registerPickable(obj) {
    if (!obj || raycastTargetSet.has(obj)) return;
    raycastTargets.push(obj);
    raycastTargetSet.add(obj);
  }

  function registerInteractive(obj) {
    if (!obj || interactiveSet.has(obj)) return;
    registerPickable(obj);
    interactives.push(obj);
    interactiveSet.add(obj);
  }
  let hovered = null;
  let selected = null;

  const actionBar = document.getElementById('actionBar');
  const btnLfs = document.getElementById('btnLfs');
  const btnTms = document.getElementById('btnTms');
  const btnFee = document.getElementById('btnFee');
  const btnMonitor = document.getElementById('btnMonitor');

  const isOwnedByCurrent = (obj) => !!currentUser && obj?.userData?.owner === currentUser;

  // 监控相关元素和变量
  const monitorPanel = document.getElementById('monitorPanel');
  const monitorVideo = document.getElementById('monitorVideo');
  const monitorClose = document.getElementById('monitorClose');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const monitorLoading = document.getElementById('monitorLoading');
  
  let flvPlayer = null;
  const YINGSHI_MONITOR_URL = 'https://rtmp05open.ys7.com:9188/v3/openlive/C54441328_1_1.flv?expire=1761814378&id=901513545338388480&t=d8d642746d1c4827d6a11f1a4cd035c7ae35f3b27af62bb14611d3b9eef52f82&ev=101&supportH265=1';

  // 监控播放器初始化函数
  function initFlvPlayer() {
    if (flvPlayer) {
      flvPlayer.destroy();
      flvPlayer = null;
    }

    if (flvjs.isSupported()) {
      flvPlayer = flvjs.createPlayer({
        type: 'flv',
        url: YINGSHI_MONITOR_URL,
        isLive: true,
        cors: true,
        withCredentials: false,
        hasAudio: false,
        hasVideo: true
      });
      
      flvPlayer.attachMediaElement(monitorVideo);
      
      // 播放器事件监听
      flvPlayer.on(flvjs.Events.LOADING_COMPLETE, () => {
        console.log('监控流加载完成');
        monitorLoading.style.display = 'none';
      });
      
      flvPlayer.on(flvjs.Events.ERROR, (errorType, errorDetail, errorInfo) => {
        console.error('监控播放错误:', errorType, errorDetail, errorInfo);
        monitorLoading.textContent = '监控流加载失败，请稍后重试';
        monitorLoading.style.color = '#dc2626';
      });
      
      try {
        flvPlayer.load();
      } catch (e) {
        console.error('FLV播放器加载失败:', e);
        monitorLoading.textContent = '监控播放器初始化失败';
        monitorLoading.style.color = '#dc2626';
      }
    } else {
      console.error('浏览器不支持FLV播放');
      monitorLoading.textContent = '当前浏览器不支持FLV视频播放';
      monitorLoading.style.color = '#dc2626';
    }
  }

  // 显示监控面板
  function showMonitorPanel(siloData) {
    const siloType = siloData.type === '星仓' ? '★星仓' : '筒仓';
    const monitorTitle = monitorPanel.querySelector('.monitor-title');
    monitorTitle.textContent = `${siloType} #${siloData.id} 监控播放`;
    
    monitorPanel.style.display = 'block';
    monitorLoading.style.display = 'block';
    monitorLoading.textContent = '正在连接监控流...';
    monitorLoading.style.color = '#888';
    
    // 延迟初始化播放器，确保面板已显示
    setTimeout(() => {
      initFlvPlayer();
    }, 100);
  }

  // 关闭监控面板
  function closeMonitorPanel() {
    monitorPanel.style.display = 'none';
    if (flvPlayer) {
      flvPlayer.pause();
      flvPlayer.unload();
      flvPlayer.detachMediaElement();
      flvPlayer.destroy();
      flvPlayer = null;
    }
  }

  function updateCompass() {
    const az = controls.getAzimuthalAngle();
    const deg = -THREE.MathUtils.radToDeg(az);
    compass.style.transform = `rotate(${deg}deg)`;
  }

  function fitCameraToYard(yardLength, yardWidth, maxHeight, fillRatio = 1.0) {
    const size = new THREE.Vector3(yardLength, maxHeight, yardWidth);
    const radius = size.length() / 2;
    const vFov = THREE.MathUtils.degToRad(camera.fov);
    const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect);
    const distV = radius / Math.tan(vFov / 2);
    const distH = radius / Math.tan(hFov / 2);
    const distance = Math.max(distV, distH) * fillRatio;

    const az = controls.getAzimuthalAngle();
    const phi = controls.getPolarAngle();
    const target = new THREE.Vector3(0, Math.max(0, maxHeight * 0.5), 0);
    controls.target.copy(target);
    camera.position.set(
      target.x + distance * Math.sin(phi) * Math.sin(az),
      target.y + distance * Math.cos(phi),
      target.z + distance * Math.sin(phi) * Math.cos(az)
    );
    camera.updateProjectionMatrix();

    controls.minDistance = Math.max(10, distance * 0.35);
    controls.maxDistance = distance * 3.0;
    controls.update();
  }

  function buildYardGrid(length, width) {
    const size = Math.max(length, width);
    const divisions = size / 10;
    const grid = new THREE.GridHelper(size, divisions, 0xaaaaaa, 0xcccccc);
    grid.scale.z = width / length;
    scene.add(grid);

    const halfL = length / 2, halfW = width / 2;
    const borderPts = [
      [-halfL, 0, -halfW], [halfL, 0, -halfW],
      [halfL, 0, halfW], [-halfL, 0, halfW],
      [-halfL, 0, -halfW]
    ].map(([x, y, z]) => new THREE.Vector3(x, y, z));
    const geom = new THREE.BufferGeometry().setFromPoints(borderPts);
    const border = new THREE.Line(geom, new THREE.LineBasicMaterial({color: 0x888888}));
    scene.add(border);
  }

  function buildMainRoad(roadWidth, length) {
    const halfL = length / 2;
    const halfW = roadWidth / 2;
    const sidewalk = 3;
    const laneEdge = halfW - sidewalk;

    const y = 0.02;
    const mkLine = (pts, material) => {
      const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p[0], y, p[1])));
      const line = new THREE.Line(g, material);
      return line;
    };

    const baseMat = new THREE.LineBasicMaterial({color: 0x444444});
    const dashedMat = new THREE.LineDashedMaterial({color: 0x888888, dashSize: 10, gapSize: 6});

    scene.add(mkLine([[-halfL, -halfW], [halfL, -halfW]], baseMat.clone()));
    scene.add(mkLine([[-halfL, halfW], [halfL, halfW]], baseMat.clone()));
    scene.add(mkLine([[-halfL, -laneEdge], [halfL, -laneEdge]], baseMat.clone()));
    scene.add(mkLine([[-halfL, laneEdge], [halfL, laneEdge]], baseMat.clone()));

    const gCenter = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-halfL, y, 0), new THREE.Vector3(halfL, y, 0)
    ]);
    const centerLine = new THREE.Line(gCenter, dashedMat);
    centerLine.computeLineDistances();
    scene.add(centerLine);
  }

  function buildSidewalkTrees(roadWidth, length, spacing = 10) {
    const halfL = length / 2;
    const halfW = roadWidth / 2;
    const sidewalk = 3;
    const zOnSidewalk = halfW - sidewalk / 2;

    for (let x = -halfL; x <= halfL + 1e-6; x += spacing) {
      addTree(x, zOnSidewalk);
      addTree(x, -zOnSidewalk);
    }

    function addTree(x, z) {
      const group = new THREE.Group();
      const trunkH = 6;
      const canopyH = 2;

      const trunkGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, trunkH, 0)
      ]);
      const trunk = new THREE.Line(trunkGeom, new THREE.LineBasicMaterial({color: lineColors.tree}));
      group.add(trunk);

      const coneGeo = new THREE.ConeGeometry(1.4, canopyH, 10);
      const edges = new THREE.EdgesGeometry(coneGeo);
      const canopy = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: lineColors.tree}));
      canopy.position.y = trunkH + canopyH / 2;
      group.add(canopy);

      group.position.set(x, 0, z);
      scene.add(group);
    }
  }

  function buildWarehouse({length, width, height, roofHeight}, centerX, centerZ, index) {
    const group = new THREE.Group();
    group.position.set(centerX, 0, centerZ);

    const wall = createWireframe(new THREE.BoxGeometry(length, height, width), lineColors.wall);
    wall.position.set(0, height / 2, 0);
    wall.userData = {type: '仓库', 序号: index + 1, 长: length, 宽: width, 高: height};
    group.add(wall);

    const hx = length / 2, hz = width / 2, yTop = height, yRidge = height + roofHeight;
    const roofColor = lineColors.roof;
    const roofLines = [];
    roofLines.push([[-hx, yTop, -hz], [0, yRidge, -hz], [hx, yTop, -hz], [-hx, yTop, -hz]]);
    roofLines.push([[-hx, yTop, hz], [0, yRidge, hz], [hx, yTop, hz], [-hx, yTop, hz]]);
    roofLines.push([[-hx, yRidge, 0], [hx, yRidge, 0]]);
    roofLines.push([[-hx, yTop, -hz], [-hx, yTop, hz]]);
    roofLines.push([[hx, yTop, -hz], [hx, yTop, hz]]);

    for (const pts of roofLines) {
      const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p[0], p[1], p[2])));
      const line = new THREE.Line(g, new THREE.LineBasicMaterial({color: roofColor}));
      group.add(line);
    }

    const idChar = String.fromCharCode(65 + (index % 26));
    const area = length * width;
    const services = [];
    const temperature = '0.0';
    const phone = '';
    group.userData.whInfo = {id: `#${idChar}`, area, temperature, services, phone};

    const labelEl = document.createElement('div');
    labelEl.className = 'whLabel';
    labelEl.textContent = group.userData.whInfo.id;
    const labelObj = new CSS2DObject(labelEl);
    labelObj.position.set(0, height + roofHeight + 6, 0);
    group.add(labelObj);

    scene.add(group);
    return group;
  }

  document.addEventListener('click', (e) => {
    // 不处理canvas区域的点击，避免与Three.js交互冲突
    if (e.target === renderer.domElement || renderer.domElement.contains(e.target)) return;
    
    if (e.target && (e.target.closest && e.target.closest('#actionBar'))) return;
    whPanel.style.display = 'none';
    clearSelection();
  });

  let stackIdSeq = 1;

  async function populateStacks(warehouseGroup, wConf, stackConf, index) {
    const {length, width, height} = wConf;
    const {length: sx, width: sz, height: sy} = stackConf.stackSize;

    const center = new THREE.Vector3();
    warehouseGroup.getWorldPosition(center);
    const cx = center.x, cz = center.z;

    // 只生成一个平仓P01在仓库中心
    const stack = createWireframe(new THREE.BoxGeometry(sx, sy, sz), lineColors.stack);
    stack.position.set(cx, sy / 2, cz);
    stack.material = new THREE.LineBasicMaterial({color: lineColors.stack});
    const vol = (sx * sy * sz).toFixed(0);
    const id = stackIdSeq++;
    const whInfo = warehouseGroup.userData?.whInfo || null;

    // 从API获取P01平仓的真实数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: id,
        siloNumber: 'P01', // 明确指定为P01，触发接口数据获取
        siloType: '平仓P01',
        radius: Math.max(sx, sz) / 2,
        height: sy,
        volume: vol,
        capacity: (vol * 0.75).toFixed(1) // 假设密度0.75吨/立方米
      });
      
      console.log('成功获取平仓P01数据:', apiData);
    } catch (error) {
      console.error('获取平仓P01数据失败:', error);
      // API调用失败时，使用空数据
      apiData = {
        siloInfo: {
          id: 'P01',
          type: '平仓P01',
          maxCapacity: '0.0',
          currentStorage: '0.0'
        },
        materialDetails: [],
        dataSource: 'api-failed'
      };
    }

    const { siloInfo, materialDetails } = apiData;
    const activeMaterials = Array.isArray(materialDetails)
      ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6)
      : [];
    const hasMaterialData = activeMaterials.length > 0;

    stack.userData = {
      type: siloInfo.type || '平仓P01',
      id: siloInfo.id || `P${String(id).padStart(2, '0')}`,
      编号: siloInfo.id || `P${String(id).padStart(2, '0')}`,
      owner: hasMaterialData ? siloInfo.owner : undefined,
      仓库序号: index + 1,
      体积_m3: vol,
      尺寸_m: `${sx}×${sy}×${sz}`,
      最大容量_t: siloInfo.maxCapacity,
      当前储量_t: siloInfo.currentStorage,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp,
      whInfo
    };

    // 根据是否有物料数据设置颜色
    const baseColor = hasMaterialData && siloInfo.owner === 'JF' ? lineColors.ownerJF : lineColors.stack;
    setStackColor(stack, baseColor);

    scene.add(stack);
    registerPickable(stack);

    // 所有平仓P01都注册为可交互对象，无论是否有物料数据
    registerInteractive(stack);
    console.log('平仓P01注册为交互对象:', stack.userData.type, stack.userData.id, '交互对象总数:', interactives.length);
  }

  // 交互逻辑
  const raycaster = new THREE.Raycaster();
  raycaster.params.Line.threshold = 2;
  const mouse = new THREE.Vector2();
  function resolveInteractiveTarget(object) {
    let current = object;
    let depth = 0;
    const maxDepth = 10; // 限制遍历深度，避免无限循环
    
    while (current && depth < maxDepth) {
      // 检查当前对象是否在可交互集合中
      if (interactiveSet.has(current)) {
        const userData = current.userData;
        if (userData?.type === '筒仓' || userData?.type === '星仓') {
          // 筒仓/星仓无论是否有数据都可以悬停显示名称
          return current;
        } else if (userData?.type === '平仓P01') {
          // 所有平仓P01都可以交互，无论是否有物料数据
          return current;
        } else if (userData?.type === '地磅') {
          // 地磅可以交互
          return current;
        }
      }
      current = current.parent;
      depth++;
    }
    return null;
  }

  function showHoverInfo(obj, clientX, clientY) {
    // 移除权限检查，所有对象都可以显示悬停信息

    const type = obj.userData?.type;
    if (type === '筒仓' || type === '星仓') {
      const cap = obj.userData?.最大容量_t || '-';
      const current = obj.userData?.当前储量_t || '0';
      const materials = obj.userData?.物料详情 || [];
      const label = type === '星仓' ? '★星仓' : '筒仓';
      
      let materialInfo = '';
      if (materials.length > 0) {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px;">';
        materials.forEach(m => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          console.log(`悬停面板颜色: 公司=${m.company}, 原始颜色=${m.companyColor}, 解析结果=${companyColor}`);
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          materialInfo += `<div style="margin: 2px 0; display: flex; align-items: center;">
            <div style="width: 10px; height: 10px; background: ${companyColor}; border-radius: 2px; margin-right: 6px; border: 1px solid #ccc;"></div>
            <span style="color: ${companyColor}; font-weight: bold;">${m.company}: <span style="${amountStyle}">${negativeIcon}${m.amount}吨</span> ${m.material}</span>
          </div>`;
        });
        materialInfo += '</div>';
      } else {
        // 当没有物料数据时显示空仓状态
        materialInfo = '<div style="margin-top: 6px; font-size: 12px; color: #888;">暂无物料数据</div>';
      }
      
      infoPanel.innerHTML = `
        <div><b>${label} ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>容量: ${cap} 吨</div>
        <div>当前: ${current} 吨</div>
        ${materialInfo}
      `;
    } else if (type === '地磅') {
      // 地磅悬停信息
      const status = obj.userData?.状态 || '未知';
      const currentWeight = obj.userData?.当前重量_t || 0;
      const plateNumber = obj.userData?.车牌号 || '';
      
      // 状态颜色
      let statusColor = '#666';
      if (status === '称重中') statusColor = '#FF5722';
      else if (status === '有车') statusColor = '#FF9800';
      else if (status === '空闲') statusColor = '#4CAF50';
      
      const vehicleType = obj.userData?.车辆类型 || '';
      const arrivalTime = obj.userData?.到达时间 || '';
      
      let vehicleInfo = '';
      if ((status === '称重中' || status === '有车') && plateNumber) {
        vehicleInfo = `
          <div style="border-top: 1px solid #ccc; margin-top: 4px; padding-top: 4px;">
            <div><b>🚛 车辆信息</b></div>
            <div>车牌号: <span style="color: #1976D2; font-weight: bold;">${plateNumber}</span></div>
            <div>重量: <span style="color: #FF5722; font-weight: bold;">${currentWeight} 吨</span></div>
            ${vehicleType ? `<div>类型: ${vehicleType}</div>` : ''}
            ${arrivalTime ? `<div>时间: ${arrivalTime}</div>` : ''}
          </div>
        `;
      }
      
      infoPanel.innerHTML = `
        <div><b>地磅 ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>状态: <span style="color: ${statusColor}; font-weight: bold;">${status}</span></div>
        ${vehicleInfo}
      `;
    } else {
      // 平仓P01悬停信息
      const v = obj.userData?.体积_m3;
      const cap = obj.userData?.最大容量_t || '-';
      const current = obj.userData?.当前储量_t || '0';
      const materials = obj.userData?.物料详情 || [];
      
      let materialInfo = '';
      if (materials.length > 0) {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px;">';
        materials.forEach(m => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          materialInfo += `<div style="margin: 2px 0; display: flex; align-items: center;">
            <div style="width: 10px; height: 10px; background: ${companyColor}; border-radius: 2px; margin-right: 6px; border: 1px solid #ccc;"></div>
            <span style="color: ${companyColor}; font-weight: bold;">${m.company}: <span style="${amountStyle}">${negativeIcon}${m.amount}吨</span> ${m.material}</span>
          </div>`;
        });
        materialInfo += '</div>';
      } else {
        materialInfo = '<div style="margin-top: 6px; font-size: 12px; color: #888;">暂无物料数据</div>';
      }
      
      infoPanel.innerHTML = `
        <div><b>平仓P01 ${obj.userData?.编号 || '#' + obj.userData?.id}</b></div>
        <div>体积: ${v} m³</div>
        <div>容量: ${cap} 吨</div>
        <div>当前: ${current} 吨</div>
        ${materialInfo}
      `;
    }

    infoPanel.style.display = 'block';
    infoPanel.style.left = (clientX + 14) + 'px';
    infoPanel.style.top = (clientY + 14) + 'px';
  }

  function hideHoverInfo() {
    infoPanel.style.display = 'none';
  }

  // 数字解析：去掉空格/单位，只留数字和小数点、负号
function toNumber(v) {
  if (v == null) return NaN;
  if (typeof v === 'number') return v;
  return parseFloat(String(v).replace(/[^\d.\-]/g, ''));
}

// 是否有有效物料（绝对值 > 0）
function hasActiveMaterials(materialDetails) {
  if (!Array.isArray(materialDetails)) return false;
  return materialDetails.some(item => Number.isFinite(toNumber(item?.amount)) && Math.abs(toNumber(item.amount)) > 1e-6);
}


function setStackColor(obj, color) {
    if (!obj) return;

    const type = obj.userData?.type;
    const isCylindricalSilo = type === '筒仓';
    const isStarSilo = type === '星仓';
    const isSilo = isCylindricalSilo || isStarSilo;
    const hasMaterialData = obj.userData?.hasMaterialData === true;

    let targetColor = color;
    if (isSilo && !hasMaterialData) {
      const looksLikeCompanyTint =
        color === lineColors.silo ||
        color === lineColors.siloOwnerJF ||
        color === lineColors.starSilo ||
        color === lineColors.starSiloOwnerJF;
      if (looksLikeCompanyTint) {
        targetColor = emptySiloColor;
      }
    }

    if (isSilo) {
      // 为筒仓/星仓设置颜色 - 同步主体与线框材质
      const isClickable = hasMaterialData; // 有物料数据的筒仓可以点击
      
      obj.children.forEach(child => {
        if (!child.material) return;
        
        // 检查是否是屋顶
        const isRoof = child.userData?.isRoof === true;
        
        if (child.material.type === 'LineBasicMaterial') {
          child.material.color.set(targetColor);
        } else if (child.material.type === 'MeshStandardMaterial') {
          if (isRoof) {
            // 屋顶颜色逻辑：可点击的为绿色，不可点击的为深灰色
            const roofColor = isClickable ? 0x33bb33 : 0xd7d7d7;
            child.material.color.set(roofColor);
          } else {
            // 非屋顶部分使用目标颜色
            child.material.color.set(targetColor);
          }
        }
      });
    } else if (obj.material) {
      // 为平仓P01设置颜色
      obj.material.color.set(targetColor);
    }
  }

function getStackBaseColor(obj) {
    const type = obj?.userData?.type;
    const owner = obj?.userData?.owner;
    const showCompanyColor = obj?.userData?.hasMaterialData === true;
    const isCylindricalSilo = type === '筒仓';
    const isStarSilo = type === '星仓';
    const hasNumber = obj?.userData?.编号 && obj?.userData?.编号 !== '未分配';

    if (isCylindricalSilo) {
      if (!hasNumber) {
        return noNumberSiloColor; // 没有编号的筒仓使用红色
      }
      if (!showCompanyColor) {
        return emptySiloColor;
      }
      return owner === 'JF' ? lineColors.siloOwnerJF : lineColors.silo;
    }
  if (isStarSilo) {
    if (!showCompanyColor) {
      return emptySiloColor; // 空星仓使用灰色
    }
    return owner === 'JF' ? lineColors.starSiloOwnerJF : lineColors.starSilo;
  }
    if (!showCompanyColor) {
      return lineColors.stack;
    }
    return owner === 'JF' ? lineColors.ownerJF : lineColors.stack;
  }

function getSiloHoverColor(obj) {
    const type = obj?.userData?.type;
    if (type === '星仓') {
      return lineColors.starSiloHover;
    }
    return lineColors.siloHover;
  }

function getSiloSelectedColor(obj) {
    const type = obj?.userData?.type;
    if (type === '星仓') {
      return lineColors.starSiloSelected;
    }
    return lineColors.siloSelected;
  }

  function clearHover() {
    if (hovered && hovered !== selected) {
      const hoveredType = hovered.userData?.type;
      if (hoveredType === '地磅') {
        setWeighbridgeColor(hovered, getWeighbridgeBaseColor(hovered));
      } else {
        setStackColor(hovered, getStackBaseColor(hovered));
      }
    }
    hovered = null;
    hideHoverInfo();
  }

  function layoutInfoPanels() {
    const gap = 12;
    const detailShown = detailPanel.style.display !== 'none';
    const whShown = whPanel.style.display !== 'none';
    detailPanel.style.bottom = '16px';
    whPanel.style.bottom = '16px';
    if (detailShown && whShown) {
      const h = detailPanel.offsetHeight || detailPanel.getBoundingClientRect().height || 0;
      whPanel.style.bottom = (16 + h + gap) + 'px';
    }
  }

  function updateActionBar() {
    if (selected) {
      actionBar.classList.add('show'); // 移除权限检查，选中任何对象都显示操作按钮
    } else {
      actionBar.classList.remove('show');
    }
  }

  function updateDetailPanel() {
    if (!selected) {
      detailPanel.style.display = 'none';
      updateActionBar();
      return;
    }
    const wp = new THREE.Vector3();
    selected.getWorldPosition(wp);
    const ud = selected.userData || {};

    if (ud.type === '筒仓' || ud.type === '星仓') {
      const typeLabel = ud.type === '星仓' ? '★星仓详情' : '筒仓详情';
      const materials = ud.物料详情 || [];
      
      
      let materialsHtml = '';
      if (materials.length > 0) {
        materialsHtml = '<div style="margin-top: 8px;"><b>物料详情:</b></div>';
        materials.forEach((m, index) => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          console.log(`详情面板颜色: 公司=${m.company}, 原始颜色=${m.companyColor}, 解析结果=${companyColor}`);
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          const negativeLabel = isNegative ? ' (出库)' : '';
          materialsHtml += `
            <div style="background: #f8f9fa; padding: 6px; margin: 4px 0; border-radius: 4px; border-left: 3px solid ${companyColor};">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <div style="width: 12px; height: 12px; background: ${companyColor}; border-radius: 2px; margin-right: 8px; border: 1px solid #ccc;"></div>
                <span style="font-weight: bold; color: ${companyColor};">${m.company}${negativeLabel}</span>
              </div>
              <div style="font-size: 13px;">物料: ${m.material} | 数量: <span style="${amountStyle}">${negativeIcon}${m.amount} 吨</span></div>
              <div style="font-size: 12px; color: #666;">入仓时间: ${m.storageDate}</div>
            </div>
          `;
        });
      } else {
        materialsHtml = '<div style="margin-top: 8px; color: #888;">暂无物料</div>';
      }
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">${typeLabel} ${ud.编号 || '#' + ud.id}</div>
        ${ud.特殊标识 ? `<div style="color: #FFD700; font-weight: bold; text-align: center; margin-bottom: 6px;">${ud.特殊标识}</div>` : ''}        <div>半径: ${ud.半径_m} 米</div>
        <div>高度: ${ud.高度_m} 米</div>
        <div>容积: ${ud.容积_m3} m³</div>
        <div>最大容量: ${ud.最大容量_t} 吨</div>
        <div>当前储量: ${ud.当前储量_t || '-'} 吨</div>
        <div>仓内温度: ${ud.仓内温度_c || '-'} ℃</div>
        <div>仓内湿度: ${ud.仓内湿度_percent || '-'}%</div>
        ${materialsHtml}
      `;
    } else if (ud.type === '地磅') {
      // 处理地磅详情
      let vehicleDetailsHtml = '';
      if ((ud.状态 === '称重中' || ud.状态 === '有车') && ud.车牌号) {
        // 显示车辆图片（如果有）
        let vehicleImagesHtml = '';
        if (ud.frontimg || ud.backimg || ud.wholeimg) {
          vehicleImagesHtml = '<div style="margin-top: 8px;"><b>车辆图片:</b><div style="display: flex; gap: 4px; margin-top: 4px;">';
          if (ud.frontimg) {
            vehicleImagesHtml += `<a href="${ud.frontimg}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px;">前视图</a>`;
          }
          if (ud.backimg) {
            vehicleImagesHtml += `<a href="${ud.backimg}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px;">后视图</a>`;
          }
          if (ud.wholeimg) {
            vehicleImagesHtml += `<a href="${ud.wholeimg}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px;">全景图</a>`;
          }
          vehicleImagesHtml += '</div></div>';
        }
        
        vehicleDetailsHtml = `
          <div style="margin-top: 12px; padding: 8px; background: #f5f5f5; border-radius: 4px;">
            <div style="font-weight: 600; margin-bottom: 4px; color: #2196F3;">🚛 当前车辆信息</div>
            <div>车牌号: <span style="font-weight: bold; color: #1976D2;">${ud.车牌号}</span></div>
            <div>车辆类型: ${ud.车辆类型}</div>
            <div>当前重量: <span style="font-weight: bold; color: #FF5722;">${ud.当前重量_t} 吨</span></div>
            ${ud.correctPonderation ? `<div>纠正重量: <span style="font-weight: bold; color: #4CAF50;">${ud.correctPonderation} 吨</span></div>` : ''}
            <div>过磅时间: ${ud.到达时间}</div>
            ${ud.driver ? `<div>司机: ${ud.driver}</div>` : ''}
            ${ud.warehouseName ? `<div>库区: ${ud.warehouseName}</div>` : ''}
            ${ud.createTime ? `<div>记录时间: ${ud.createTime}</div>` : ''}
            ${vehicleImagesHtml}
          </div>
        `;
      }
      
      // 数据来源信息
      let dataSourceHtml = '';
      if (ud.数据来源) {
        const sourceColor = ud.数据来源 === 'production-api' ? '#4CAF50' : 
                           ud.数据来源 === 'api-not-found' ? '#FF9800' : '#9E9E9E';
        const sourceText = ud.数据来源 === 'production-api' ? '接口数据' : 
                          ud.数据来源 === 'api-not-found' ? '接口无数据' : '默认数据';
        dataSourceHtml = `
          <div style="margin-top: 8px; padding: 6px; background: #f9f9f9; border-radius: 4px; border-left: 3px solid ${sourceColor};">
            <div style="font-size: 12px; color: #666;">数据来源: <span style="color: ${sourceColor}; font-weight: bold;">${sourceText}</span></div>
            ${ud.更新时间 ? `<div style="font-size: 11px; color: #999;">更新时间: ${new Date(ud.更新时间).toLocaleString()}</div>` : ''}
          </div>
        `;
      }

      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">地磅详情 ${ud.编号 || '#' + ud.id}</div>
        <div>状态: <span style="color: ${ud.状态 === '称重中' ? '#FF5722' : '#4CAF50'}; font-weight: bold;">${ud.状态}</span></div>
        ${vehicleDetailsHtml}
        ${dataSourceHtml}
      `;
    } else {
      // 处理平仓P01详情
      const materials = ud.物料详情 || [];
      
      let materialsHtml = '';
      if (materials.length > 0) {
        materialsHtml = '<div style="margin-top: 8px;"><b>物料详情:</b></div>';
        materials.forEach((m, index) => {
          const colorData = parseColor(m.companyColor);
          const companyColor = colorData.css || '#666666';
          const isNegative = parseFloat(m.amount) < 0;
          const amountStyle = isNegative ? 'color: #d32f2f; font-weight: bold;' : '';
          const negativeIcon = isNegative ? '⬇️ ' : '';
          const negativeLabel = isNegative ? ' (出库)' : '';
          materialsHtml += `
            <div style="background: #f8f9fa; padding: 6px; margin: 4px 0; border-radius: 4px; border-left: 3px solid ${companyColor};">
              <div style="display: flex; align-items: center; margin-bottom: 4px;">
                <div style="width: 12px; height: 12px; background: ${companyColor}; border-radius: 2px; margin-right: 8px; border: 1px solid #ccc;"></div>
                <span style="font-weight: bold; color: ${companyColor};">${m.company}${negativeLabel}</span>
              </div>
              <div style="font-size: 13px;">物料: ${m.material} | 数量: <span style="${amountStyle}">${negativeIcon}${m.amount} 吨</span></div>
              <div style="font-size: 12px; color: #666;">入仓时间: ${m.storageDate}</div>
            </div>
          `;
        });
      } else {
        materialsHtml = '<div style="margin-top: 8px; color: #888;">暂无物料</div>';
      }
      
      detailPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:6px;">平仓P01详情 #${ud.编号 || ud.id}</div>
        <div>最大堆叠体积: ${ud.体积_m3} m³</div>
        <div>最大堆叠尺寸: ${ud.尺寸_m}</div>
        <div>最大容量: ${ud.最大容量_t || '-'} 吨</div>
        <div>当前储量: ${ud.当前储量_t || '-'} 吨</div>
        ${materialsHtml}
      `;
    }

    detailPanel.style.display = 'block';
    layoutInfoPanels();
    updateActionBar();
  }

  function handlePointerMove(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    // 对所有可交互对象进行射线检测，获取所有相交点
    const allHits = raycaster.intersectObjects(raycastTargets, true);
    let target = null;

    // 只考虑最近的第一个交互对象，避免穿透空筒仓命中后方目标
    if (allHits.length > 0) {
      target = resolveInteractiveTarget(allHits[0].object);
      if (!target && allHits.length > 0) {
        console.log('射线检测到对象但无法解析为交互目标:', allHits[0].object.userData?.type, '射线目标总数:', raycastTargets.length, '交互对象总数:', interactives.length);
      }
    }
    if (target) {
      if (hovered !== target) {
        if (hovered && hovered !== selected) setStackColor(hovered, getStackBaseColor(hovered));
        hovered = target;
        console.log('悬停对象变更:', target.userData?.type, target.userData?.id);
      }
      if (hovered !== selected) {
        const hoveredType = hovered.userData?.type;
        let hoverColor;
        if (hoveredType === '筒仓' || hoveredType === '星仓') {
          hoverColor = getSiloHoverColor(hovered);
        } else if (hoveredType === '地磅') {
          hoverColor = lineColors.weighbridgeHover;
        } else {
          hoverColor = lineColors.hover;
        }
        
        if (hoveredType === '地磅') {
          setWeighbridgeColor(hovered, hoverColor);
        } else {
          setStackColor(hovered, hoverColor);
        }
      }
      showHoverInfo(target, e.clientX, e.clientY);
    } else {
      clearHover();
    }
  }

  function handleClick(e) {
    // 事件冒泡已在调用此函数前被阻止，这里不需要再次处理
    if (!hovered) return; // 移除权限检查，只要有悬停对象就可以点击
    if (selected === hovered) {
      clearSelection();
      return;
    }
    if (selected) {
      const selectedType = selected.userData?.type;
      if (selectedType === '地磅') {
        setWeighbridgeColor(selected, getWeighbridgeBaseColor(selected));
      } else {
        setStackColor(selected, getStackBaseColor(selected));
      }
    }
    selected = hovered;
    const selectedType = selected.userData?.type;
    let selectedColor;
    if (selectedType === '筒仓' || selectedType === '星仓') {
      selectedColor = getSiloSelectedColor(selected);
    } else if (selectedType === '地磅') {
      selectedColor = lineColors.weighbridgeSelected;
    } else {
      selectedColor = lineColors.selected;
    }
    
    if (selectedType === '地磅') {
      setWeighbridgeColor(selected, selectedColor);
    } else {
      setStackColor(selected, selectedColor);
    }
    updateDetailPanel();
    const info = selected.userData?.whInfo;
    if (info) {
      whPanel.innerHTML = `
          <div style="font-weight:600;margin-bottom:6px;">仓库 ${info.id}</div>
          <div>面积: ${info.area} m²</div>
          <div>仓内温度: ${info.temperature} ℃</div>
          <div>增值作业: ${info.services.join('、')}</div>
          <div>当日值勤: ${info.phone}</div>
        `;
      whPanel.style.display = 'block';
      layoutInfoPanels();
    } else {
      whPanel.style.display = 'none';
    }
    updateActionBar();
  }

  renderer.domElement.addEventListener('mousemove', handlePointerMove);
  renderer.domElement.addEventListener('mouseleave', clearHover);
  // 统一的点击处理函数，避免多重事件监听器导致的冒泡问题
  renderer.domElement.addEventListener('click', (ev) => {
    // 阻止事件冒泡和默认行为
    ev.stopPropagation();
    ev.preventDefault();
    
    console.log('Canvas点击事件触发, hovered:', hovered?.userData?.type, hovered?.userData?.id);
    
    // 处理对象选择逻辑
    if (hovered) {
      handleClick(ev);
    } else {
      clearSelection();
    }
    
  });

  function clearSelection() {
    if (!selected) {
      updateActionBar();
      return;
    }
    const selectedType = selected.userData?.type;
    if (selectedType === '地磅') {
      setWeighbridgeColor(selected, getWeighbridgeBaseColor(selected));
    } else {
      setStackColor(selected, getStackBaseColor(selected));
    }
    selected = null;
    updateDetailPanel();
    updateActionBar();
    whPanel.style.display = 'none';
  }

  btnLfs.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '平仓P01';
    alert(`查看LFS订单：${type} #${id}`);
  });
  btnTms.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '平仓P01';
    alert(`查看相关TMS运输订单：${type} #${id}`);
  });
  btnFee.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const id = selected.userData?.id;
    const type = selected.userData?.type || '平仓P01';
    let feeType;
    if (type === '筒仓' || type === '星仓') {
      feeType = '筒仓仓储费用';
    } else if (type === '地磅') {
      feeType = '地磅使用费用';
    } else {
      feeType = '平仓P01仓储费用';
    }
    alert(`查看${feeType}：${type} #${id}`);
  });

  // 监控按钮事件监听
  btnMonitor.addEventListener('click', (e) => {
    e.stopPropagation();
    if (!selected) return;
    const userData = selected.userData;
    const type = userData?.type;
    
    // 只有筒仓和星仓才有监控功能
    if (type === '筒仓' || type === '星仓') {
      showMonitorPanel(userData);
    } else {
      alert('只有筒仓和星仓支持监控查看功能');
    }
  });

  // 监控面板控制按钮事件监听
  monitorClose.addEventListener('click', closeMonitorPanel);

  playBtn.addEventListener('click', () => {
    if (flvPlayer && monitorVideo.paused) {
      flvPlayer.play().catch(e => {
        console.error('播放失败:', e);
      });
    }
  });

  pauseBtn.addEventListener('click', () => {
    if (flvPlayer && !monitorVideo.paused) {
      flvPlayer.pause();
    }
  });

  fullscreenBtn.addEventListener('click', () => {
    if (monitorVideo.requestFullscreen) {
      monitorVideo.requestFullscreen();
    } else if (monitorVideo.webkitRequestFullscreen) {
      monitorVideo.webkitRequestFullscreen();
    } else if (monitorVideo.msRequestFullscreen) {
      monitorVideo.msRequestFullscreen();
    }
  });

  // 点击面板外部关闭监控面板
  document.addEventListener('click', (e) => {
    if (monitorPanel.style.display === 'block' && 
        !monitorPanel.contains(e.target) && 
        e.target !== btnMonitor) {
      closeMonitorPanel();
    }
  });

  function onResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    labelRenderer.setSize(w, h);


    layoutInfoPanels();
  }

  window.addEventListener('resize', onResize);

  controls.addEventListener('change', () => {
    updateCompass();
  });

  // 车辆3D模型构建函数
  function buildVehicle(type = 'truck') {
    const vehicleGroup = new THREE.Group();
    
    if (type === 'truck') {
      // 卡车车身
      const bodyGeometry = new THREE.BoxGeometry(8, 2.5, 2.2);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 1.25, 0);
      vehicleGroup.add(body);
      
      // 驾驶室
      const cabGeometry = new THREE.BoxGeometry(2.5, 2.8, 2.2);
      const cabMaterial = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
      const cab = new THREE.Mesh(cabGeometry, cabMaterial);
      cab.position.set(-4.75, 1.4, 0);
      vehicleGroup.add(cab);
      
      // 车轮
      const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.3, 12);
      const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
      
      const wheelPositions = [
        [-3.5, 0.6, -1.2], [-3.5, 0.6, 1.2], // 前轮
        [1.5, 0.6, -1.2], [1.5, 0.6, 1.2],   // 后轮1
        [3.5, 0.6, -1.2], [3.5, 0.6, 1.2]    // 后轮2
      ];
      
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.position.set(pos[0], pos[1], pos[2]);
        wheel.rotation.z = Math.PI / 2;
        vehicleGroup.add(wheel);
      });
      
    } else if (type === 'car') {
      // 小轿车车身
      const bodyGeometry = new THREE.BoxGeometry(4.5, 1.5, 1.8);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6347 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.75, 0);
      vehicleGroup.add(body);
      
      // 车顶
      const roofGeometry = new THREE.BoxGeometry(3, 1.2, 1.6);
      const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xDC143C });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.set(-0.3, 1.6, 0);
      vehicleGroup.add(roof);
      
      // 车轮
      const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 12);
      const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
      
      const wheelPositions = [
        [-1.5, 0.4, -1], [-1.5, 0.4, 1], // 前轮
        [1.5, 0.4, -1], [1.5, 0.4, 1]    // 后轮
      ];
      
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.position.set(pos[0], pos[1], pos[2]);
        wheel.rotation.z = Math.PI / 2;
        vehicleGroup.add(wheel);
      });
    }
    
    return vehicleGroup;
  }

  // 地磅构建函数
  function buildWeighbridge(length = 50, width = 58, height = 0.3) {
    const group = new THREE.Group();
    
    // 地磅平台
    const platformGeo = new THREE.BoxGeometry(length, height, width);
    const platformMat = new THREE.MeshStandardMaterial({
      color: 0x4A4A4A,
      roughness: 0.8,
      metalness: 0.2
    });
    const platform = new THREE.Mesh(platformGeo, platformMat);
    platform.position.y = height / 2;
    platform.castShadow = true;
    platform.receiveShadow = true;
    group.add(platform);
    
    // 地磅边框线框
    const platformWireframe = createWireframe(platformGeo, 0x333333);
    platformWireframe.position.y = height / 2;
    group.add(platformWireframe);
    
    // 称重传感器支撑（4个角）
    const sensorGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8);
    const sensorMat = new THREE.MeshStandardMaterial({
      color: 0x666666,
      roughness: 0.7,
      metalness: 0.3
    });
    
    const sensorPositions = [
      [-length/2 + 2, -0.4, -width/2 + 0.5],
      [length/2 - 2, -0.4, -width/2 + 0.5],
      [-length/2 + 2, -0.4, width/2 - 0.5],
      [length/2 - 2, -0.4, width/2 - 0.5]
    ];
    
    sensorPositions.forEach(pos => {
      const sensor = new THREE.Mesh(sensorGeo, sensorMat);
      sensor.position.set(pos[0], pos[1], pos[2]);
      sensor.castShadow = true;
      group.add(sensor);
    });
    
    // 控制箱
    const controlBoxGeo = new THREE.BoxGeometry(1.2, 1.5, 0.8);
    const controlBoxMat = new THREE.MeshStandardMaterial({
      color: 0x2E7D32,
      roughness: 0.6,
      metalness: 0.1
    });
    const controlBox = new THREE.Mesh(controlBoxGeo, controlBoxMat);
    controlBox.position.set(length/2 + 2, 0.75, 0);
    controlBox.castShadow = true;
    group.add(controlBox);
    
    // 控制箱线框
    const controlBoxWireframe = createWireframe(controlBoxGeo, 0x1B5E20);
    controlBoxWireframe.position.set(length/2 + 2, 0.75, 0);
    group.add(controlBoxWireframe);
    
    return group;
  }

  // 筒仓构建函数
  function buildSiloWireframe(radius, height, radialSegments = 24) {
    const cyl = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 1, false);
    const edges = new THREE.EdgesGeometry(cyl);
    const mat = new THREE.LineBasicMaterial({color: lineColors.silo});
    const mesh = new THREE.LineSegments(edges, mat);
    mesh.position.y = height / 2;
    return mesh;
  }

  function buildSiloMesh(radius, height, materials = [], radialSegments = 32) {
    const group = new THREE.Group();

    // 如果没有物料数据，创建空筒仓
    if (!materials || materials.length === 0) {
      const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 8, false);
      const mat = new THREE.MeshStandardMaterial({
        color: emptySiloColor,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = height / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);
      return group;
    }

    // 分离正数和负数物料，3D模型只显示正数物料
    const positiveMaterials = materials.filter(m => parseFloat(m.amount) > 0);
    
    // 如果没有正数物料，显示为空仓
    if (positiveMaterials.length === 0) {
      const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 8, false);
      const mat = new THREE.MeshStandardMaterial({
        color: emptySiloColor,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = height / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);
      return group;
    }
    
    const totalAmount = positiveMaterials.reduce((sum, m) => sum + parseFloat(m.amount), 0);
    let currentY = 0;

    // 为每个公司的正数物料创建分段
    positiveMaterials.forEach((material, index) => {
      const proportion = parseFloat(material.amount) / totalAmount;
      const segmentHeight = height * proportion * 0.8; // 0.8是填充率
      
      if (segmentHeight > 0.1) { // 只显示足够高的分段
        const geo = new THREE.CylinderGeometry(radius, radius, segmentHeight, radialSegments, 1, false);
        const colorData = parseColor(material.companyColor);
        const companyColor = colorData.hex || emptySiloColor;
        
        const mat = new THREE.MeshStandardMaterial({
          color: companyColor,
          roughness: 0.9,
          metalness: 0.05,
          flatShading: false
        });
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = currentY + segmentHeight / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = {
          company: material.company,
          material: material.material,
          amount: material.amount
        };
        
        group.add(mesh);
        currentY += segmentHeight;
      }
    });

    // 如果有剩余空间，添加空的顶部分段
    if (currentY < height) {
      const emptyHeight = height - currentY;
      const geo = new THREE.CylinderGeometry(radius, radius, emptyHeight, radialSegments, 1, false);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xF0F0F0, // 浅灰色表示空仓
        roughness: 0.95,
        metalness: 0.02,
        flatShading: false,
        transparent: true,
        opacity: 0.3
      });
      
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = currentY + emptyHeight / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { isEmpty: true };
      
      group.add(mesh);
    }

    return group;
  }

  function buildSiloRoof(radius, height = 3) {
    const geo = new THREE.ConeGeometry(radius * 1.05, height, 24);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xD0D0D0, // 更亮的灰色，避免看起来太黑
      roughness: 0.6,
      metalness: 0.2
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    mesh.receiveShadow = true; // 添加接受阴影，让光照更自然
    mesh.userData = { isRoof: true }; // 标识这是屋顶
    return mesh;
  }

  function buildSiloLadder(radius, height) {
    const points = [];
    const turns = height / 15;
    const segments = Math.ceil(turns * 32);

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const angle = t * turns * Math.PI * 2;
      const y = t * height;
      const x = Math.cos(angle) * (radius + 0.3);
      const z = Math.sin(angle) * (radius + 0.3);
      points.push(new THREE.Vector3(x, y, z));
    }

    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 2 });
    return new THREE.Line(geo, mat);
  }

  function buildConnectingBridge(x1, z1, x2, z2, height) {
    const dx = x2 - x1;
    const dz = z2 - z1;
    const len = Math.sqrt(dx * dx + dz * dz);
    const angle = Math.atan2(dz, dx);

    const geo = new THREE.CylinderGeometry(0.4, 0.4, len, 8);
    const mat = new THREE.MeshStandardMaterial({
      color: 0x808080,
      roughness: 0.6,
      metalness: 0.4
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.z = Math.PI / 2;
    mesh.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
    mesh.rotation.y = angle;
    return mesh;
  }

  let siloIdSeq = 1;
  
  // 星仓编号计数器 - 全局声明
  let starSiloRowIndex = 0;
  let starSiloColIndex = 0;
  
  // 筒仓编号映射表 - 按照实际创建顺序排列
  const siloNumberMap = {
    // 所有筒仓编号 - 按照 rowGroupCounts: [2, 2, 2, 1, 1, 1] 的实际创建顺序
    silo: [
      // 第1排第1组 (rowGroupCounts[0] = 2组中的第1组)
      ['T105', 'T205', 'T305', 'T405'],
      // 第1排第2组 (rowGroupCounts[0] = 2组中的第2组)  
      ['T503', 'T603', 'T703', 'T803'],
      // 第2排第1组 (rowGroupCounts[1] = 2组中的第1组)
      ['T104', 'T204', 'T304', 'T404'],
      // 第2排第2组 (rowGroupCounts[1] = 2组中的第2组)
      ['T502', 'T602', 'T702', 'T802'],
      // 第3排第1组 (rowGroupCounts[2] = 2组中的第1组)
      ['T103', 'T203', 'T303', 'T403'],
      // 第3排第2组 (rowGroupCounts[2] = 2组中的第2组)
      ['T501', 'T601', 'T701', 'T801'],
      // 第4排第1组 (rowGroupCounts[3] = 1组)
      ['T102', 'T202', 'T302', 'T402'],
      // 第5排第1组 (rowGroupCounts[4] = 1组)
      ['T101', 'T201', 'T301', 'T401'],
      // 第6排第1组 (rowGroupCounts[5] = 1组) - 您新增的编号
      ['T1011', 'T2011', 'T3011', 'T4011']
    ],
    // 星仓编号 - 按照实际创建顺序分配（共18个）
    starSilo: [
      // 第一组（一排星仓）：4个星仓 - 对应代码第2547-2551行
      ['X104', 'X101', 'X103', 'X102'],
      // 第二组（二排星仓）：4个星仓 - 对应代码第2552-2556行
      ['X204', 'X203', 'X202', 'X201'],
      // 第三组（三排星仓）：4个星仓 - 对应代码第2557-2561行
      ['X304', 'X303', 'X302', 'X301'],
      // 第四组（四排星仓）：2个星仓 - 对应代码第2562-2564行
      ['X402', 'X401'],
      // 第五组（五排星仓）：2个星仓 - 对应代码第2565-2567行
      ['X502', 'X501'],
      // 第六组（六排星仓）：2个星仓 - 对应代码第2568-2570行
      ['X602', 'X601']
    ]
  };

  // ================== 星仓位置与编号对应关系说明 ==================
  /**
   * 星仓布局说明（共18个星仓）：
   * 
   * 根据用户提供的编号规则和实际代码创建顺序：
   * 
   * 第一组（一排星仓，X=-31.92）：4个星仓
   * - X104: 位置(-31.92, -24.30, 49) - 代码第2548行
   * - X101: 位置(-31.92, -56.50, 49) - 代码第2549行  
   * - X103: 位置(-31.92, -35.00, 49) - 代码第2550行
   * - X102: 位置(-31.92, -45.00, 49) - 代码第2551行
   * 
   * 第二组（二排星仓，X≈-21.92）：4个星仓
   * - X204: 位置(-21.92, -24.30, 49) - 代码第2553行
   * - X203: 位置(-21.92, -35.00, 49) - 代码第2554行
   * - X202: 位置(-21.92, -45.50, 49) - 代码第2555行
   * - X201: 位置(-22.92, -56.50, 49) - 代码第2556行
   * 
   * 第三组（三排星仓，X≈-11.92）：4个星仓
   * - X304: 位置(-11.92, -24.30, 49) - 代码第2558行
   * - X303: 位置(-11.92, -35.00, 49) - 代码第2559行
   * - X302: 位置(-11.92, -45.50, 49) - 代码第2560行
   * - X301: 位置(-12.92, -56.50, 49) - 代码第2561行
   * 
   * 第四组（四排星仓，X=8.92）：2个星仓
   * - X402: 位置(8.92, -24.30, 49) - 代码第2563行
   * - X401: 位置(8.92, -35.00, 49) - 代码第2564行
   * 
   * 第五组（五排星仓，X=18.92）：2个星仓
   * - X502: 位置(18.92, -24.30, 49) - 代码第2566行
   * - X501: 位置(18.92, -35.00, 49) - 代码第2567行
   * 
   * 第六组（六排星仓，X=28.92）：2个星仓
   * - X602: 位置(28.92, -24.30, 49) - 代码第2569行
   * - X601: 位置(28.92, -35.00, 49) - 代码第2570行
   * 
   * 编号规则：
   * - 格式：X + 数字编号（X101-X602）
   * - 第一位数字：表示排号（1-6）
   * - 第二、三位数字：表示该排内的序号（01-04）
   * - 编号按照实际创建顺序分配，确保与代码中的placeStarSilo调用顺序一致
   */

  /**
   * 星仓编号验证和查询功能
   */
  
  // 调试：检查场景中的星仓对象
  function debugStarSilos() {
    // 安全检查：确保scene对象存在
    if (typeof scene === 'undefined' || !scene || typeof scene.traverse !== 'function') {
      console.warn('⚠️ Scene对象未初始化，无法调试星仓');
      return [];
    }
    
    const starSilos = [];
    scene.traverse((child) => {
      if (child.userData?.type === '星仓') {
        starSilos.push({
          编号: child.userData.编号 || child.userData.id,
          位置: {
            x: child.position.x.toFixed(2),
            y: child.position.y.toFixed(2), 
            z: child.position.z.toFixed(2)
          },
          状态: child.userData.状态,
          数据来源: child.userData.数据来源
        });
      }
    });
    
    console.log('=== 场景中的星仓对象 ===');
    console.log(`找到 ${starSilos.length} 个星仓:`);
    starSilos.forEach((silo, index) => {
      console.log(`${index + 1}. ${silo.编号} - 位置(${silo.位置.x}, ${silo.位置.y}, ${silo.位置.z}) - 状态: ${silo.状态} - 数据来源: ${silo.数据来源}`);
    });
    
    // 检查缺失的星仓
    const expectedSilos = siloNumberMap.starSilo.flat();
    const foundSilos = starSilos.map(s => s.编号);
    const missingSilos = expectedSilos.filter(expected => !foundSilos.includes(expected));
    
    if (missingSilos.length > 0) {
      console.log(`\n⚠️ 缺失的星仓: ${missingSilos.join(', ')}`);
    } else {
      console.log(`\n✅ 所有星仓都已创建`);
    }
    
    return { found: starSilos, missing: missingSilos };
  }
  
  // 将调试函数暴露到全局
  window.debugStarSilos = debugStarSilos;
  
  /**
   * 调试星仓编号分配过程
   */
  function debugStarSiloNumbering() {
    console.log('=== 星仓编号分配调试 ===');
    console.log(`当前星仓行索引: ${starSiloRowIndex}`);
    console.log(`当前星仓列索引: ${starSiloColIndex}`);
    console.log('星仓编号映射表:');
    siloNumberMap.starSilo.forEach((group, index) => {
      console.log(`  第${index + 1}组: [${group.join(', ')}]`);
    });
    
    // 下一个星仓编号分配
    if (starSiloRowIndex < siloNumberMap.starSilo.length && starSiloColIndex < siloNumberMap.starSilo[starSiloRowIndex].length) {
      const nextNumber = siloNumberMap.starSilo[starSiloRowIndex][starSiloColIndex];
      console.log(`下一个分配的编号: ${nextNumber}`);
    } else {
      console.log('已超出预定义编号范围，将使用自动生成编号');
    }
  }
  
  // 暴露到全局
  window.debugStarSiloNumbering = debugStarSiloNumbering;
  
  /**
   * 重置星仓编号计数器
   */
  function resetStarSiloCounters() {
    starSiloRowIndex = 0;
    starSiloColIndex = 0;
    console.log('星仓编号计数器已重置');
    debugStarSiloNumbering();
  }
  
  // 暴露到全局
  window.resetStarSiloCounters = resetStarSiloCounters;
  function validateStarSiloNumbering() {
    const expectedTotal = 18;
    const actualTotal = siloNumberMap.starSilo.flat().length;
    
    console.log('=== 星仓编号验证 ===');
    console.log(`预期总数: ${expectedTotal}`);
    console.log(`实际总数: ${actualTotal}`);
    console.log(`验证结果: ${actualTotal === expectedTotal ? '✓ 通过' : '✗ 失败'}`);
    
    // 打印每组编号
    siloNumberMap.starSilo.forEach((group, index) => {
      console.log(`第${index + 1}组: [${group.join(', ')}] (${group.length}个)`);
    });
    
    return actualTotal === expectedTotal;
  }

  /**
   * 根据编号获取星仓位置信息（调试用）
   */
  function getStarSiloPositionByNumber(number) {
    // 位置映射表（与代码中的placeStarSilo调用对应）
    const positionMap = {
      // 第一组
      'X104': { x: -31.92, y: -24.30, z: 49, line: 2548 },
      'X101': { x: -31.92, y: -56.50, z: 49, line: 2549 },
      'X103': { x: -31.92, y: -35.00, z: 49, line: 2550 },
      'X102': { x: -31.92, y: -45.00, z: 49, line: 2551 },
      // 第二组
      'X204': { x: -21.92, y: -24.30, z: 49, line: 2553 },
      'X203': { x: -21.92, y: -35.00, z: 49, line: 2554 },
      'X202': { x: -21.92, y: -45.50, z: 49, line: 2555 },
      'X201': { x: -22.92, y: -56.50, z: 49, line: 2556 },
      // 第三组
      'X304': { x: -11.92, y: -24.30, z: 49, line: 2558 },
      'X303': { x: -11.92, y: -35.00, z: 49, line: 2559 },
      'X302': { x: -11.92, y: -45.50, z: 49, line: 2560 },
      'X301': { x: -12.92, y: -56.50, z: 49, line: 2561 },
      // 第四组
      'X402': { x: 8.92, y: -24.30, z: 49, line: 2563 },
      'X401': { x: 8.92, y: -35.00, z: 49, line: 2564 },
      // 第五组
      'X502': { x: 18.92, y: -24.30, z: 49, line: 2566 },
      'X501': { x: 18.92, y: -35.00, z: 49, line: 2567 },
      // 第六组
      'X602': { x: 28.92, y: -24.30, z: 49, line: 2569 },
      'X601': { x: 28.92, y: -35.00, z: 49, line: 2570 }
    };
    
    return positionMap[number] || null;
  }


  
  // 筒仓编号计数器
  let siloRowIndex = 0;
  let siloColIndex = 0;

  function createStarOutlinePoints(outerRadius, innerRadius, arms = 5) {
    const pts = [];
    const total = arms * 2;
    for (let i = 0; i < total; i++) {
      const angle = (i / total) * Math.PI * 2 - Math.PI / 2;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      pts.push(new THREE.Vector2(Math.cos(angle) * radius, Math.sin(angle) * radius));
    }
    return pts;
  }

  function computePolygonArea2D(points) {
    let area = 0;
    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % points.length];
      area += p1.x * p2.y - p2.x * p1.y;
    }
    return Math.abs(area) / 2;
  }

  function buildStarSiloBody(outerRadius, innerRadius, height, materials = [], arms = 5) {
    const outline = createStarOutlinePoints(outerRadius, innerRadius, arms);
    const shape = new THREE.Shape();
    shape.moveTo(outline[0].x, outline[0].y);
    for (let i = 1; i < outline.length; i++) {
      shape.lineTo(outline[i].x, outline[i].y);
    }
    shape.closePath();

    const extrude = new THREE.ExtrudeGeometry(shape, {
      steps: 1,
      depth: height,
      bevelEnabled: false
    });
    extrude.rotateX(-Math.PI / 2);
    extrude.translate(0, height / 2, 0);

    // 根据是否有物料决定颜色：空星仓用灰色，有物料用金色
    const hasMaterials = materials && materials.length > 0;
    const bodyColor = hasMaterials ? lineColors.starSilo : emptySiloColor;

    const bodyMat = new THREE.MeshStandardMaterial({
      color: bodyColor,
      roughness: 0.55,
      metalness: 0.25
    });
    const body = new THREE.Mesh(extrude, bodyMat);
    body.castShadow = true;
    body.receiveShadow = true;

    return {body, outline};
  }

  async function placeSilo(x, z, radius, height, addDetails = true) {
    const group = new THREE.Group();

    // 计算基本参数
    const volume = Math.PI * radius * radius * height;
    const capacity = (volume * 0.75).toFixed(1); // 假设密度0.75吨/立方米
    
    // 使用新的编号系统
    let siloNumber;
    if (siloRowIndex < siloNumberMap.silo.length && siloColIndex < siloNumberMap.silo[siloRowIndex].length) {
      siloNumber = siloNumberMap.silo[siloRowIndex][siloColIndex];
      siloColIndex++;
      if (siloColIndex >= siloNumberMap.silo[siloRowIndex].length) {
        siloColIndex = 0;
        siloRowIndex++;
      }
    } else {
      siloNumber = null; // 不分配编号，表示接口中没有对应数据
    }
    const siloId = siloIdSeq++;

    // 通过接口获取筒仓和物料数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: siloId,
        siloNumber: siloNumber, // 传递本地编号用于API数据查找
        siloType: '筒仓',
        radius: radius,
        height: height,
        volume: volume,
        capacity: capacity
      });
    } catch (error) {
      console.error(`获取筒仓 ${siloNumber} 数据失败:`, error);
      // 使用默认数据继续创建筒仓，避免完全失败
      apiData = {
        siloInfo: {
          id: siloNumber,
          type: '筒仓',
          radius: radius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '离线'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'fallback-default'
      };
    }

    const { siloInfo, materialDetails } = apiData;
    const activeMaterials = Array.isArray(materialDetails)
    ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6): [];
    const hasMaterialData = activeMaterials.length > 0;


    // 只有有物料数据时才传递物料详情，否则传递空数组
    const shell = buildSiloMesh(radius, height, activeMaterials);
    const outline = buildSiloWireframe(radius, height);
    group.add(shell);
    group.add(outline);

    if (addDetails) {
      const roof = buildSiloRoof(radius, 3);
      roof.position.y = height + 1.5;
      group.add(roof);

      const ladder = buildSiloLadder(radius, height);
      group.add(ladder);

      const ventGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
      const ventMat = new THREE.MeshStandardMaterial({ 
        color: 0x888888, // 更亮的灰色
        roughness: 0.7,
        metalness: 0.3
      });
      const vent = new THREE.Mesh(ventGeo, ventMat);
      vent.position.y = height + 3.75;
      group.add(vent);
    }

    // 使用接口返回的数据设置筒仓信息
    group.userData = {
      type: siloInfo.type,
      id: siloInfo.id,
      编号: siloNumber || '未分配', // 使用本地编号，如果没有则显示"未分配"
      owner: hasMaterialData ? siloInfo.owner : undefined,
      半径_m: siloInfo.radius,
      高度_m: siloInfo.height,
      容积_m3: siloInfo.volume,
      最大容量_t: siloInfo.maxCapacity,
      当前储量_t: siloInfo.currentStorage,
      仓内温度_c: siloInfo.temperature,
      仓内湿度_percent: siloInfo.humidity,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    group.position.set(x, 0, z);
    scene.add(group);
    registerPickable(group);

    // 所有筒仓都注册为可交互对象，无论是否有物料数据
    registerInteractive(group);
    
    // 根据编号和物料数据设置颜色
    if (!siloNumber) {
      // 没有编号的筒仓使用红色，表示接口中没有对应数据
      setStackColor(group, noNumberSiloColor);
    } else if (hasMaterialData) {
      // 有编号且有物料数据的筒仓设置正常颜色
      setStackColor(group, getStackBaseColor(group));
    } else {
      // 有编号但无物料数据的筒仓使用灰色
      setStackColor(group, emptySiloColor);
    }

    return group;
  }

  // 地磅状态管理
  const weighbridgeStates = new Map(); // 存储每个地磅的状态
  
  // 根据状态更新地磅颜色
  function updateWeighbridgeColor(weighbridge) {
    if (!weighbridge || !weighbridge.userData) return;
    
    const status = weighbridge.userData.状态;
    let color;
    
    switch (status) {
      case '称重中':
        color = 0xFF5722; // 红色 - 正在称重
        break;
      case '有车':
        color = 0xFF9800; // 橙色 - 有车辆但未称重
        break;
      case '空闲':
        color = 0x4CAF50; // 绿色 - 空闲状态
        break;
      default:
        color = lineColors.weighbridge; // 默认颜色
    }
    
    setWeighbridgeColor(weighbridge, color);
    console.log(`🎨 地磅 ${weighbridge.userData.编号} 状态: ${status}, 颜色更新为: 0x${color.toString(16)}`);
  }
  
  // 车辆称重模拟函数
  function simulateVehicleWeighing(weighbridge) {
    const vehicleTypes = ['truck', 'car'];
    const plateNumbers = ['京A12345', '沪B67890', '粤C11111', '川D22222', '鲁E33333'];
    
    return {
      type: vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)],
      plateNumber: plateNumbers[Math.floor(Math.random() * plateNumbers.length)],
      weight: Math.round((Math.random() * 30 + 20) * 100) / 100, // 20-50吨
      driver: '模拟司机',
      arrivalTime: new Date().toLocaleTimeString()
    };
  }

  // 更新场景中所有地磅的显示状态
  function updateAllWeighbridgesInScene() {
    // 尝试多种方式获取scene对象
    const sceneRef = scene || window.globalScene;
    
    // 安全检查：确保scene对象存在且有traverse方法
    if (typeof sceneRef === 'undefined' || !sceneRef || typeof sceneRef.traverse !== 'function') {
      console.warn('⚠️ Scene对象未初始化，跳过地磅更新');
      console.warn('调试信息:', {
        sceneType: typeof scene,
        sceneExists: !!scene,
        windowSceneType: typeof window.globalScene,
        windowSceneExists: !!window.globalScene,
        sceneRefType: typeof sceneRef,
        sceneRefExists: !!sceneRef
      });
      return;
    }
    
    if (!globalWeighbridgeData || !globalWeighbridgeData.weighbridgeList) {
      return;
    }
    
    // 如果API返回空数据，清空所有地磅的车辆
    if (globalWeighbridgeData.weighbridgeList.length === 0) {
      console.log('🧹 API返回空数据，清空所有地磅车辆');
      
      // 使用已验证的sceneRef对象
      sceneRef.traverse((object) => {
        if (object.userData && object.userData.type === '地磅') {
          const weighbridgeId = object.userData.编号 || object.userData.id;
          const state = weighbridgeStates.get(weighbridgeId);
          
          if (state && state.hasVehicle) {
            console.log(`🚫 清空地磅 ${weighbridgeId} 的车辆`);
            removeVehicleFromWeighbridge(object, true); // API驱动的清空
          }
        }
      });
      return;
    }
    
    // 遍历场景中的所有对象，找到地磅并更新
    sceneRef.traverse((object) => {
      if (object.userData && object.userData.type === '地磅') {
        const weighbridgeId = object.userData.编号 || object.userData.id;
        
        // 在API数据中查找对应的地磅数据
        const apiData = globalWeighbridgeData.weighbridgeList.find(wb => 
          wb.weighbridgeInfo.id === weighbridgeId
        );
        
        if (apiData) {
          const { weighbridgeInfo } = apiData;
          
          // 获取地磅状态管理器
          const state = weighbridgeStates.get(weighbridgeId);
          if (!state) {
            console.warn(`⚠️ 地磅 ${weighbridgeId} 状态管理器不存在`);
            return;
          }
          
          // 检查状态变化，决定是否需要添加/移除车辆
          const newStatus = weighbridgeInfo.status || '空闲';
          const hasVehicleInAPI = (newStatus === '称重中' || newStatus === '有车') && weighbridgeInfo.plateNumber;
          
          // 更新地磅的userData
          Object.assign(object.userData, {
            状态: newStatus,
            当前重量_t: weighbridgeInfo.currentWeight || 0,
            车牌号: weighbridgeInfo.plateNumber || '',
            车辆类型: weighbridgeInfo.vehicleType || '',
            到达时间: weighbridgeInfo.arrivalTime || '',
            driver: weighbridgeInfo.driver || '',
            driverid: weighbridgeInfo.driverid || '',
            warehouseName: weighbridgeInfo.warehouseName || '',
            correctPonderation: weighbridgeInfo.correctPonderation || null,
            frontimg: weighbridgeInfo.frontimg || '',
            backimg: weighbridgeInfo.backimg || '',
            wholeimg: weighbridgeInfo.wholeimg || '',
            createTime: weighbridgeInfo.createTime || '',
            recordId: weighbridgeInfo.recordId || '',
            数据来源: 'production-api',
            更新时间: Date.now()
          });
          
          // 根据API数据同步车辆3D模型
          if (hasVehicleInAPI && !state.hasVehicle) {
            // API显示有车，但3D场景中没有车辆 -> 添加车辆
            console.log(`🚗 地磅 ${weighbridgeId} 添加车辆: ${weighbridgeInfo.plateNumber}`);
            addVehicleToWeighbridgeFromAPI(object, weighbridgeInfo);
          } else if (!hasVehicleInAPI && state.hasVehicle) {
            // API显示无车，但3D场景中有车辆 -> 移除车辆
            console.log(`🚫 地磅 ${weighbridgeId} 移除车辆`);
            removeVehicleFromWeighbridge(object, true); // API驱动的清空
          } else if (hasVehicleInAPI && state.hasVehicle) {
            // 都有车辆，更新车辆信息
            console.log(`🔄 地磅 ${weighbridgeId} 更新车辆信息: ${weighbridgeInfo.plateNumber}`);
            updateVehicleInfo(state, weighbridgeInfo);
          }
          
          // 更新地磅颜色
          updateWeighbridgeColor(object);
          
          console.log(`🔄 地磅 ${weighbridgeId} 数据已更新: ${newStatus}, 重量: ${weighbridgeInfo.currentWeight}吨, 车牌: ${weighbridgeInfo.plateNumber}`);
        } else {
          // API数据中没有找到对应的地磅数据，清空车辆
          const state = weighbridgeStates.get(weighbridgeId);
          if (state && state.hasVehicle) {
            console.log(`🚫 API中未找到地磅 ${weighbridgeId} 数据，清空车辆`);
            removeVehicleFromWeighbridge(object, true); // API驱动的清空
          }
        }
      }
    });
  }
  
  // 根据API数据添加车辆到地磅
  function addVehicleToWeighbridgeFromAPI(weighbridge, weighbridgeInfo) {
    const weighbridgeId = weighbridge.userData.编号 || weighbridge.userData.id;
    const state = weighbridgeStates.get(weighbridgeId);
    
    if (state.hasVehicle) {
      console.log(`⚠️ 地磅 ${weighbridgeId} 已有车辆，跳过添加`);
      return;
    }
    
    // 创建车辆信息对象
    const vehicleInfo = {
      type: weighbridgeInfo.vehicleType === '小轿车' ? 'car' : 'truck',
      plateNumber: weighbridgeInfo.plateNumber || '',
      weight: weighbridgeInfo.currentWeight || 0,
      driver: weighbridgeInfo.driver || '',
      arrivalTime: weighbridgeInfo.arrivalTime || ''
    };
    
    // 创建车辆3D模型
    const vehicleModel = buildVehicle(vehicleInfo.type);
    
    // 设置车辆位置（在地磅上）
    const weighbridgePos = weighbridge.position;
    const weighbridgeRotation = weighbridge.rotation.y;
    
    vehicleModel.position.set(
      weighbridgePos.x,
      weighbridgePos.y + 0.4, // 稍微抬高避免z-fighting
      weighbridgePos.z
    );
    vehicleModel.rotation.y = weighbridgeRotation;
    vehicleModel.scale.set(1, 1, 1);  // 车辆放大5倍
    
    // 添加车辆标识
    vehicleModel.userData = {
      type: 'vehicle',
      weighbridgeId: weighbridgeId,
      plateNumber: vehicleInfo.plateNumber,
      vehicleType: vehicleInfo.type
    };
    
    // 添加到场景
    if (typeof scene !== 'undefined' && scene && typeof scene.add === 'function') {
      scene.add(vehicleModel);
    } else {
      console.warn('⚠️ Scene对象未初始化，无法添加车辆模型');
      return; // 如果无法添加到场景，直接返回
    }
    
    // 更新状态
    state.hasVehicle = true;
    state.vehicle = vehicleInfo;
    state.vehicleModel = vehicleModel;
    state.currentWeight = vehicleInfo.weight;
    state.isWeighing = true;
    
    console.log(`✅ 车辆已添加到地磅 ${weighbridgeId}: ${vehicleInfo.plateNumber}`);
  }
  
  // 更新车辆信息
  function updateVehicleInfo(state, weighbridgeInfo) {
    if (state.vehicle) {
      state.vehicle.plateNumber = weighbridgeInfo.plateNumber || '';
      state.vehicle.weight = weighbridgeInfo.currentWeight || 0;
      state.vehicle.driver = weighbridgeInfo.driver || '';
      state.currentWeight = weighbridgeInfo.currentWeight || 0;
    }
  }
  

  // 地磅放置函数
  async function placeWeighbridge(x, z, id, options = {}) {
    const {
      length = 50,
      width = 58,
      height = 0.3,
      rotation = 0
    } = options;

    const group = buildWeighbridge(length, width, height);
    
    // 初始化地磅状态
    const weighbridgeState = {
      hasVehicle: false,
      vehicle: null,
      vehicleModel: null,
      currentWeight: 0,
      isWeighing: false
    };
    weighbridgeStates.set(id, weighbridgeState);

    // 立即创建默认地磅数据，确保地磅能立即渲染
    let apiData = {
      weighbridgeInfo: {
        id: id,
        type: '地磅',
        status: '空闲',
        currentWeight: 0,
        plateNumber: '',
        vehicleType: '',
        arrivalTime: ''
      },
      timestamp: Date.now(),
      dataSource: 'immediate-default'
    };

    // 异步获取API数据更新地磅信息（不阻塞渲染）
    fetchWeighbridgeData({
      weighbridgeId: id,
      weighbridgeNumber: id
    }).then(fetchedData => {
      console.log(`✅ 地磅 ${id} API数据获取成功，更新信息`);
      // 更新地磅的userData
      if (group && group.userData) {
        const { weighbridgeInfo } = fetchedData;
        Object.assign(group.userData, {
          状态: weighbridgeInfo.status || '空闲',
          当前重量_t: weighbridgeInfo.currentWeight || 0,
          车牌号: weighbridgeInfo.plateNumber || '',
          车辆类型: weighbridgeInfo.vehicleType || '',
          到达时间: weighbridgeInfo.arrivalTime || '',
          driver: weighbridgeInfo.driver || '',
          driverid: weighbridgeInfo.driverid || '',
          warehouseName: weighbridgeInfo.warehouseName || '',
          correctPonderation: weighbridgeInfo.correctPonderation || null,
          frontimg: weighbridgeInfo.frontimg || '',
          backimg: weighbridgeInfo.backimg || '',
          wholeimg: weighbridgeInfo.wholeimg || '',
          createTime: weighbridgeInfo.createTime || '',
          recordId: weighbridgeInfo.recordId || '',
          数据来源: fetchedData.dataSource,
          更新时间: fetchedData.timestamp
        });
        
        // 根据状态更新地磅颜色
        updateWeighbridgeColor(group);
      }
    }).catch(error => {
      console.warn(`⚠️ 地磅 ${id} API数据获取失败，使用默认数据:`, error);
    });

    const { weighbridgeInfo } = apiData;

    // 设置地磅信息（使用接口返回的数据）
    group.userData = {
      type: '地磅',
      id: weighbridgeInfo.id,
      编号: weighbridgeInfo.id,
      状态: weighbridgeInfo.status || '空闲',
      当前重量_t: weighbridgeInfo.currentWeight || 0,
      车牌号: weighbridgeInfo.plateNumber || '',
      车辆类型: weighbridgeInfo.vehicleType || '',
      到达时间: weighbridgeInfo.arrivalTime || '',
      hasMaterialData: true, // 地磅总是有基本数据
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    // 设置位置和旋转
    group.position.set(x, 0, z);
    if (rotation !== 0) {
      group.rotation.y = rotation;
    }

    scene.add(group);
    registerPickable(group);
    registerInteractive(group);

    // 设置地磅颜色
    setWeighbridgeColor(group, lineColors.weighbridge);

    // 添加车辆上磅功能（定时模拟）
    setTimeout(() => {
      if (Math.random() < 0.7) { // 70%概率有车辆上磅
        addVehicleToWeighbridge(group);
      }
    }, Math.random() * 10000 + 5000); // 5-15秒后可能有车辆上磅

    return group;
  }

  // 车辆上磅函数
  function addVehicleToWeighbridge(weighbridge) {
    const weighbridgeId = weighbridge.userData.编号 || weighbridge.userData.id;
    const state = weighbridgeStates.get(weighbridgeId);
    
    if (state.hasVehicle) return; // 已有车辆
    
    // 模拟车辆称重
    const vehicleInfo = simulateVehicleWeighing(weighbridge);
    
    // 创建车辆3D模型
    const vehicleModel = buildVehicle(vehicleInfo.type);
    
    // 设置车辆位置（在地磅上）
    const weighbridgePos = weighbridge.position;
    const weighbridgeRotation = weighbridge.rotation.y;
    
    vehicleModel.position.set(
      weighbridgePos.x,
      weighbridgePos.y + 0.4, // 稍微抬高避免z-fighting
      weighbridgePos.z
    );
    vehicleModel.rotation.y = weighbridgeRotation;
    // 在第2897行后添加
    vehicleModel.scale.set(5, 5, 5);  // 车辆放大5倍
    
    // 添加到场景
    if (typeof scene !== 'undefined' && scene && typeof scene.add === 'function') {
      scene.add(vehicleModel);
    } else {
      console.warn('⚠️ Scene对象未初始化，无法添加车辆模型');
      return; // 如果无法添加到场景，直接返回
    }
    
    // 更新状态
    state.hasVehicle = true;
    state.vehicle = vehicleInfo;
    state.vehicleModel = vehicleModel;
    state.currentWeight = vehicleInfo.weight;
    state.isWeighing = true;
    
    // 更新地磅userData
    weighbridge.userData.状态 = '称重中';
    weighbridge.userData.当前重量_t = vehicleInfo.weight;
    weighbridge.userData.车牌号 = vehicleInfo.plateNumber;
    weighbridge.userData.车辆类型 = vehicleInfo.type === 'truck' ? '卡车' : '轿车';
    weighbridge.userData.到达时间 = vehicleInfo.arrivalTime;
    
    // 设置车辆离开定时器
    setTimeout(() => {
      removeVehicleFromWeighbridge(weighbridge);
    }, Math.random() * 15000 + 10000); // 10-25秒后车辆离开
    
    console.log(`车辆上磅: ${weighbridgeId}, 车牌: ${vehicleInfo.plateNumber}, 重量: ${vehicleInfo.weight}吨`);
  }
  
  // 车辆下磅函数
  function removeVehicleFromWeighbridge(weighbridge, isApiDriven = false) {
    const weighbridgeId = weighbridge.userData.编号 || weighbridge.userData.id;
    const state = weighbridgeStates.get(weighbridgeId);
    
    // 安全检查：确保state存在
    if (!state) {
      console.warn(`⚠️ 地磅 ${weighbridgeId} 状态管理器不存在，无法移除车辆`);
      return;
    }
    
    if (!state.hasVehicle) return; // 没有车辆
    
    // 移除车辆模型
    if (state.vehicleModel) {
      // 安全检查scene对象
      if (typeof scene !== 'undefined' && scene && typeof scene.remove === 'function') {
        scene.remove(state.vehicleModel);
      } else {
        console.warn('⚠️ Scene对象未初始化，无法移除车辆模型');
      }
    }
    
    // 重置状态
    state.hasVehicle = false;
    state.vehicle = null;
    state.vehicleModel = null;
    state.currentWeight = 0;
    state.isWeighing = false;
    
    // 更新地磅userData
    weighbridge.userData.状态 = '空闲';
    weighbridge.userData.当前重量_t = 0;
    weighbridge.userData.车牌号 = '';
    weighbridge.userData.车辆类型 = '';
    weighbridge.userData.到达时间 = '';
    weighbridge.userData.使用次数++;
    
    console.log(`车辆下磅: ${weighbridgeId}${isApiDriven ? ' (API驱动)' : ' (模拟驱动)'}`);
    
    // 只有在非API驱动的情况下才设置下一辆车上磅的定时器
    if (!isApiDriven) {
      setTimeout(() => {
        if (Math.random() < 0.8) { // 80%概率有下一辆车
          addVehicleToWeighbridge(weighbridge);
        }
      }, Math.random() * 20000 + 5000); // 5-25秒后可能有下一辆车
    }
  }

  // 地磅颜色设置函数
  function setWeighbridgeColor(obj, color) {
    if (!obj) return;
    
    obj.children.forEach(child => {
      if (child.material && child.material.type === 'LineBasicMaterial') {
        child.material.color.set(color);
      }
    });
  }

  // 获取地磅基础颜色
  function getWeighbridgeBaseColor(obj) {
    return lineColors.weighbridge;
  }

  async function placeStarSilo(x, z, height, options = {}) {
    const {
      outerRadius = 3.2,
      innerRadius = outerRadius * 0.55,
      arms = 5,
      densityTPerM3 = 0.75,
      addDetails = true
    } = options;

    // 计算基本参数
    const area = computePolygonArea2D(createStarOutlinePoints(outerRadius, innerRadius, arms));
    const volume = area * height;
    const rawCapacity = volume * densityTPerM3;
    const capacity = rawCapacity.toFixed(1);
    
    // 使用星仓专用编号系统
    let starSiloNumber;
    
    if (starSiloRowIndex < siloNumberMap.starSilo.length && starSiloColIndex < siloNumberMap.starSilo[starSiloRowIndex].length) {
      starSiloNumber = siloNumberMap.starSilo[starSiloRowIndex][starSiloColIndex];
      starSiloColIndex++;
      if (starSiloColIndex >= siloNumberMap.starSilo[starSiloRowIndex].length) {
        starSiloColIndex = 0;
        starSiloRowIndex++;
      }
    } else {
      starSiloNumber = `X${String(siloIdSeq).padStart(3, '0')}`;
    }
    const siloId = siloIdSeq++;

    // 通过接口获取星仓和物料数据
    let apiData;
    try {
      apiData = await fetchSiloAndMaterialData({
        siloId: siloId,
        siloNumber: starSiloNumber, // 传递本地编号用于API数据查找
        siloType: '星仓',
        radius: outerRadius,
        height: height,
        volume: volume,
        capacity: capacity
      });
    } catch (error) {
      console.error(`获取星仓 ${starSiloNumber} 数据失败:`, error);
      // 使用默认数据继续创建星仓，避免完全失败
      apiData = {
        siloInfo: {
          id: starSiloNumber,
          type: '星仓',
          radius: outerRadius,
          height: height,
          volume: volume,
          maxCapacity: capacity,
          currentStorage: 0,
          owner: undefined,
          status: '离线'
        },
        materialDetails: [],
        timestamp: Date.now(),
        dataSource: 'fallback-default'
      };
    }

    const { siloInfo: rawSiloInfo = {}, materialDetails = [] } = apiData;
    const siloInfo = {
      ...rawSiloInfo,
      type: '星仓',
      arms: rawSiloInfo?.arms ?? arms
    };
    const activeMaterials = Array.isArray(materialDetails)
    ? materialDetails.filter(m => Number.isFinite(toNumber(m?.amount)) && Math.abs(toNumber(m.amount)) > 1e-6)
    : [];
    const hasMaterialData = activeMaterials.length > 0;


    const group = new THREE.Group();
    // 只有有物料数据时才传递物料详情，否则传递空数组
    const {body, outline} = buildStarSiloBody(outerRadius, innerRadius, height, activeMaterials, arms);
    group.add(body);

    // 为星仓添加线框（简化为轮廓线）
    const outlineGeometry = new THREE.BufferGeometry().setFromPoints([
      ...outline.map(p => new THREE.Vector3(p.x, 0, p.y)),
      new THREE.Vector3(outline[0].x, 0, outline[0].y) // 闭合
    ]);
    const outlineBottom = new THREE.Line(outlineGeometry, new THREE.LineBasicMaterial({color: lineColors.starSilo}));

    const outlineTop = outlineBottom.clone();
    outlineTop.position.y = height;

    group.add(outlineBottom);
    group.add(outlineTop);

    if (addDetails) {
      const capBaseGeo = new THREE.CylinderGeometry(innerRadius * 0.6, innerRadius * 0.6, 1.5, arms * 2);
      const capBaseMat = new THREE.MeshStandardMaterial({
        color: 0xffc75f,
        roughness: 0.45,
        metalness: 0.35
      });
      const capBase = new THREE.Mesh(capBaseGeo, capBaseMat);
      capBase.position.y = height + 0.75;
      capBase.castShadow = true;
      capBase.receiveShadow = true;
      group.add(capBase);

      const spireGeo = new THREE.ConeGeometry(innerRadius * 0.45, 2.2, Math.max(arms * 2, 6));
      const spireMat = new THREE.MeshStandardMaterial({
        color: 0xffe59f,
        roughness: 0.35,
        metalness: 0.3
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.y = height + 2.0;
      spire.castShadow = true;
      group.add(spire);
    }

    // 使用接口返回的数据设置星仓信息
    group.userData = {
      type: '星仓',
      id: starSiloNumber, // 使用本地分配的星仓编号
      编号: starSiloNumber, // 使用本地分配的星仓编号，不使用API返回的编号
      owner: hasMaterialData ? siloInfo.owner : undefined,
      半径_m: siloInfo.radius,
      高度_m: siloInfo.height,
      容积_m3: siloInfo.volume,
      最大容量_t: siloInfo.maxCapacity,
      当前储量_t: siloInfo.currentStorage,
      仓内温度_c: siloInfo.temperature,
      仓内湿度_percent: siloInfo.humidity,
      星角数: siloInfo.arms ?? arms,
      物料详情: hasMaterialData ? activeMaterials : [],
      hasMaterialData: hasMaterialData,
      // 添加特殊标识
      特殊标识: siloInfo.specialMark,
      // 添加接口数据来源标识
      数据来源: apiData.dataSource,
      更新时间: apiData.timestamp
    };

    group.position.set(x,-36, z); // 星仓放置在地面
    scene.add(group);
    registerPickable(group);

    // 所有星仓都注册为可交互对象，无论是否有物料数据
    registerInteractive(group);
    
    // 根据是否有物料数据设置颜色
    if (hasMaterialData) {
      setStackColor(group, getStackBaseColor(group));
    } else {
      // 确保空星仓使用灰色
      setStackColor(group, emptySiloColor);
    }

    return group;
  }

  async function addSiloGroup(centerX, centerZ, D, spacingIntra, height) {
    const r = D / 2;
    const step = D + spacingIntra;
    const offsets = [-1.5, -0.5, 0.5, 1.5];
    const silos = [];

    // 并行创建所有筒仓
    const siloPromises = offsets.map(k => 
      placeSilo(centerX + k * step, centerZ, r, height, true)
    );

    const createdSilos = await Promise.all(siloPromises);
    silos.push(...createdSilos);

    const bridgeHeight = height * 0.65;
    for (let i = 0; i < silos.length - 1; i++) {
      const pos1 = silos[i].position;
      const pos2 = silos[i + 1].position;
      const bridge = buildConnectingBridge(pos1.x, pos1.z, pos2.x, pos2.z, bridgeHeight);
      scene.add(bridge);
    }

    const platformGeo = new THREE.PlaneGeometry(step * 4, D * 0.8);
    const platformMat = new THREE.MeshStandardMaterial({
      color: 0xC0C0C0,
      roughness: 0.85,
      side: THREE.DoubleSide
    });
    const platform = new THREE.Mesh(platformGeo, platformMat);
    platform.rotation.x = -Math.PI / 2;
    platform.position.set(centerX, 0.05, centerZ + D * 0.6);
    platform.receiveShadow = true;
    scene.add(platform);

    return silos;
  }

  async function layoutSilosAtEastOfWarehouses(warehouses, warehouseConfig, options = {}) {
    const densityTPerM3 = options.densityTPerM3 ?? 0.75;
    const capacityTons = options.capacityTons ?? 5000;
    const height = options.height ?? 35;
    const spacingIntra = options.spacingIntra ?? 5;
    const spacingInter = options.spacingInter ?? 10;
    const rowGroupCounts = options.rowGroupCounts ?? [1, 1, 2, 4];
    const roadSouthMargin = options.roadSouthMargin ?? 5;
    const xOffset = options.xOffset ?? 0; // X方向偏移量
    const zOffset = options.zOffset ?? 0; // Z方向偏移量

    const volumeM3 = capacityTons / densityTPerM3;
    const radius = options.radius ?? Math.sqrt(volumeM3 / (Math.PI * height));
    const D = radius * 2;
    const groupWidth = 4 * D + 3 * spacingIntra;
    const groupDepth = D;

    // 计算筒仓位置时使用仓库的原始位置，不受仓库移动影响
    const {length: wL, width: wW, gap} = warehouseConfig;
    const cols = 1;
    const totalRowSpan = cols * wL + (cols - 1) * gap;
    const originalLeftStart = -totalRowSpan / 122 + wL / 2 - 100; // 仓库的原始位置
    const originalXEast = originalLeftStart + wL / 2; // 原始仓库东侧边界
    const xEast = originalXEast;
    const corridor = 20;

    let zStart = -(roadSouthMargin + groupDepth / 2) + zOffset; // 应用Z方向偏移量

    // 收集所有筒仓组创建的Promise
    const groupPromises = [];

    for (let row = 0; row < rowGroupCounts.length; row++) {
      const groupsInRow = rowGroupCounts[row];
      let xStart = xEast + corridor + (groupWidth / 2) + xOffset; // 应用X方向偏移量

      for (let gi = 0; gi < groupsInRow; gi++) {
        const cx = xStart + gi * (groupWidth + spacingInter);
        groupPromises.push(addSiloGroup(cx, zStart, D, spacingIntra, height));
      }
      zStart -= (groupDepth + spacingInter);
    }

    // 并行创建所有筒仓组
    await Promise.all(groupPromises);

    return {D, height, radius, count: rowGroupCounts.reduce((a, b) => a + b, 0) * 4};
  }

  async function init() {
    // 测试颜色解析功能
    testColorParsing();
    
    const cfg = await fetchYardConfig();
    const {length: yardL, width: yardW, roadWidth} = cfg.yard;
    buildYardGrid(yardL, yardW);
    buildMainRoad(roadWidth, yardL);
    buildSidewalkTrees(roadWidth, yardL);

    const {length: wL, width: wW, height: wH, roofHeight: rH, gap} = cfg.warehouse;
    const cols = 1;
    const rows = 1;
    const totalRowSpan = cols * wL + (cols - 1) * gap;
    const leftStart = -totalRowSpan / 2 + wL / 2 + 90; // 将仓库#A向右移动米

    const zRowOffset = -(roadWidth / 2 + wW / 2 + 5);
    const rowZs = [zRowOffset];

    const warehouses = [];
    for (let r = 0; r < rows; r++) {
      const cz = rowZs[r];
      for (let c = 0; c < cols; c++) {
        const cx = leftStart + c * (wL + gap);
        const wh = buildWarehouse({length: wL, width: wW, height: wH, roofHeight: rH}, cx, cz, r * cols + c);
        warehouses.push(wh);
        const stkConf = await fetchWarehouseStackConfig(r * cols + c);
        await populateStacks(wh, {length: wL, width: wW, height: wH}, stkConf, r * cols + c);
      }
    }

    try {
      await layoutSilosAtEastOfWarehouses(warehouses, {length: wL, width: wW, gap}, {
        radius: 4.5,
        height: 35,
        spacingIntra: 0.5,
        spacingInter: 1.5,
        rowGroupCounts: [2, 2, 2, 1, 1], // 筒仓
        roadSouthMargin: 15, // 减少南侧边距，更好地利用空间
        xOffset: 0, // X方向偏移量（正值向东，负值向西）
        zOffset: 0  // Z方向偏移量（正值向北，负值向南）
      });

      // 并行创建所有星仓
      const starSiloPromises = [
         // 一排星仓
        placeStarSilo(-31.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-31.92, -56.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-31.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-31.92, -45.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 二排星仓
        placeStarSilo(-21.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-21.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-21.92, -45.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-22.92, -56.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 三排星仓
        placeStarSilo(-11.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-11.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-11.92, -45.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(-12.92, -56.50, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 四排星仓
        placeStarSilo(8.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(8.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 五排星仓
        placeStarSilo(18.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(18.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        // 六排星仓
        placeStarSilo(28.92, -24.30, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false }),
        placeStarSilo(28.92, -35.00, 49, { outerRadius: 2.0, innerRadius: 1.1, arms: 5, addDetails: false })
      ];

      await Promise.all(starSiloPromises);

      // 添加地磅 - 立即渲染，不等待任何条件
      console.log('🚀 开始立即添加地磅...');
      
      // 立即创建地磅，不使用await等待，确保立即渲染
      placeWeighbridge(-60, -40, '1号磅', { 
        length: 20, 
        width: 20, 
        rotation: Math.PI / 2 // 90度旋转，使地磅垂直于道路
      }).then(() => {
        console.log('✅ 1号磅渲染完成');
      }).catch(error => {
        console.error('❌ 1号磅渲染失败:', error);
      });
      
      placeWeighbridge(10, 50, '2号磅', { 
        length: 20, 
        width: 20, 
        rotation: Math.PI / 2 // 90度旋转，使地磅垂直于道路
      }).then(() => {
        console.log('✅ 2号磅渲染完成');
      }).catch(error => {
        console.error('❌ 2号磅渲染失败:', error);
      });
      
      console.log('🎯 地磅立即渲染启动完成（不等待API数据）');

    } catch (error) {
      console.error('初始化失败:', error);
      // 网络错误已在API调用中显示，这里不再重复显示
      return; // 停止初始化过程
    }
   


    fitCameraToYard(yardL, yardW, wH + rH, 1.0);
    updateCompass();
    
    // 初始化完成后启动自动刷新
    console.log('🎯 场景初始化完成，启动地磅数据自动刷新');
    startAutoRefresh();
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);

  }

  init();
  animate();
</script>
</body>
</html>










